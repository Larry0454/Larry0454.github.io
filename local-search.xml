<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>『machine vision-1』projective geometry</title>
    <link href="/2024/07/27/machine_vision/projective-geometry/"/>
    <url>/2024/07/27/machine_vision/projective-geometry/</url>
    
    <content type="html"><![CDATA[<h2 id="射影几何与变换">射影几何与变换</h2><h3 id="一2d-射影几何">一、2D 射影几何</h3><ul><li><p>欧式几何与射影几何：</p><ul><li>欧氏几何：描述物体角度和形状的几何，两条平行线永不相交；欧式空间记作<span class="math inline">\(\text{IR}^n\)</span></li><li>射影几何：欧氏空间的扩展，<strong>任意两条直线都相交</strong>，两条平行直线相交于"无穷远点"（理想点）处；射影空间记作<span class="math inline">\(\text{IP}^n\)</span></li></ul></li><li><p>点与直线的表示方法：</p><ul><li>直线的齐次表示：平面上的一条直线用方程 <span class="math inline">\(ax + by + c = 0\)</span> 表示，或者用齐次向量<span class="math inline">\(k(a, b, c)^T\)</span> 表示</li><li>点的齐次表示：平面上的一个点用非齐次有序对 <span class="math inline">\((x, y)^T\)</span> 表示，或者用齐次坐标 <span class="math inline">\(k(x, y, 1)\)</span> 表示</li></ul><blockquote><p><strong>注意</strong>：点 <span class="math inline">\(x\)</span>在平面直线 <span class="math inline">\(I\)</span> 上 <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(x^TI = 0\)</span>，其中 <span class="math inline">\(x\)</span> 是齐次形式的平面坐标</p></blockquote></li><li><p>直线的交点 与 两点的连线：</p><ul><li>直线的交点：设两条直线为 <span class="math inline">\(I\)</span> 和<span class="math inline">\(I&#39;\)</span>，则 两直线的交点为 <span class="math inline">\(x = I \times I&#39;\)</span></li><li>两点的连线：设两个点为 <span class="math inline">\(x\)</span> 和<span class="math inline">\(x&#39;\)</span>，则 两点的连线为 <span class="math inline">\(I = x \times x&#39;\)</span></li></ul><blockquote><p><strong>注意</strong>：两条<u>平行线</u>的交点形式为 <span class="math inline">\((x, y, 0)\)</span>，其非齐次表示为 <span class="math inline">\((\dfrac{x}{0}, \dfrac{y}{0})\)</span>，可见其在<span class="math inline">\(\text{IR}^2\)</span> 上是无意义的</p></blockquote></li><li><p>理想点：又称"无穷远点"，形式为 <span class="math inline">\((x_1,x_2, 0)^T\)</span>，在"无穷远直线" <span class="math inline">\(I_{\infty} = (0, 0, 1)^T\)</span> 上</p></li><li><p><span class="math inline">\(\text{IP}^2\)</span> 和 <span class="math inline">\(\text{IR}^3\)</span> 的关系：</p><ul><li><span class="math inline">\(\text{IR}^3\)</span> 中过原点的射线<span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(\text{IP}^2\)</span> 中的点；当 <span class="math inline">\(k\)</span> 变化时，向量 <span class="math inline">\(k(x_1, x_2, x_3)\)</span>形成一条过原点的射线</li><li><span class="math inline">\(\text{IR}^3\)</span> 中过原点的平面<span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(\text{IP}^2\)</span> 中的直线；两相异的 <span class="math inline">\(\text{IR}^3\)</span> 平面相交成一条射线 <span class="math inline">\(\rightarrow\)</span> 两相异的 <span class="math inline">\(\text{IP}^2\)</span> 直线相交于一个点</li></ul><blockquote><p><strong>注意</strong>：<span class="math inline">\(\text{IP}^2\)</span> 中的点和直线可用 <span class="math inline">\(\text{IR}^3\)</span> 中的<strong>平面 <span class="math inline">\(x_3 = 1\)</span></strong> 截取 <span class="math inline">\(\text{IR}^3\)</span>中的射线和平面得到，如下图所示</p></blockquote><p><img src="/2024/07/27/machine_vision/projective-geometry/射影平面.jpg" width="50%"></p><hr></li><li><p>二次曲线 与 二次对偶曲线：</p><ul><li><p>二次曲线的非齐次表示：<span class="math inline">\(ax^2 + bxy +cy^2 + dx + ey + f = 0\)</span></p></li><li><p>二次曲线的齐次表示：令 <span class="math inline">\(x \rightarrow\dfrac{x_1}{x_3}\)</span>、<span class="math inline">\(y \rightarrow\dfrac{x_2}{x_3}\)</span>，则 <span class="math inline">\(ax_1^2 +bx_1b_2 + cx_2^2 + dx_1x_2 + ex_2 x_3 + fx_3 = 0\)</span> <span class="math display">\[\begin{align}&amp;x^T Cx = 0 \\\text{其中 }C =&amp; \begin{bmatrix} a &amp; \dfrac{b}{2} &amp;\dfrac{d}{2} \\ \dfrac{b}{2} &amp; c &amp; \dfrac{e}{2} \\ \dfrac{d}{2}&amp; \dfrac{e}{2} &amp; f  \end{bmatrix}\end{align}\]</span></p><blockquote><p><strong>注意</strong>：平面上二次曲线的一般位置可由<strong>5</strong> 点唯一确定</p></blockquote></li></ul></li><li><p>退化二次曲线：若矩阵 <span class="math inline">\(C\)</span><strong>不是满秩</strong>的，则该曲线为退化二次曲线；若 <span class="math inline">\(\text{rk}(C) = 2\)</span> 退化为两条直线，<span class="math inline">\(\text{rk}(C) = 1\)</span>则退化为一条重线</p></li><li><p>二次曲线的<strong>切线</strong>：（齐次坐标表示下）与二次曲线<span class="math inline">\(C\)</span> 相切于点 <span class="math inline">\(x\)</span> 的直线 <span class="math inline">\(I\)</span> 由 <span class="math inline">\(I =Cx\)</span> 确定 <span class="math display">\[\begin{align}\text{证明：}&amp;\text{由相切于点 }x \text{ 可知，}x^TI = x^TCx = 0\text{ ，故 }I = Cx \text{ 过点 }x \\&amp;\text{假设 }I \text{ 与 } C \text{相较于另一点 }y \text{ ，则有}x^TCx = x^TI = y^TCy = 0 \\&amp;\text{故 }(x + \alpha y)^T C(x + \alpha y) = 0 \text{ ，可知连接}x,y \text{的直线上所有点都在曲线 }C\text{ 上，故 }C \text{是退化的，证毕。}\end{align}\]</span></p></li><li><p>对偶二次曲线：设二次曲线为 <span class="math inline">\(C_{3\times 3}\)</span>，则 <span class="math inline">\(C\)</span>的<strong><u>伴随矩阵</u></strong> <span class="math inline">\(C^{*}\)</span> 表示一个对偶曲线，由 <span class="math inline">\(C\)</span> 的切线定义</p><ul><li>伴随矩阵：<ul><li>余因子矩阵：<span class="math inline">\(C^{*}_{ij} = (-1)^{ij}|\hat{C}_{ij}|\)</span>，其中 <span class="math inline">\(\hat{C}_{ij}\)</span> 为划掉 <span class="math inline">\(C\)</span> 的第 <span class="math inline">\(i\)</span> 行 和 第 <span class="math inline">\(j\)</span> 列余下的矩阵</li><li>伴随矩阵：余因子矩阵的转置，即 <span class="math inline">\(C^{*T}\)</span>；对于非奇异 <span class="math inline">\(C\)</span>（需是对称的），有 <span class="math inline">\(C^{*} = C^{-1}\)</span></li></ul></li><li>对于二次曲线 <span class="math inline">\(C\)</span> 的任意切线 <span class="math inline">\(I\)</span>，均满足 <span class="math inline">\(I^TC^{*} I = 0\)</span></li></ul><p><img src="/2024/07/27/machine_vision/projective-geometry/对偶二次曲线.jpg" width="70%"></p><hr></li><li><p>射影映射的定义：是一个 <span class="math inline">\(\text{IP}^2\)</span><u>到自身</u>的<strong>可逆</strong>映射 <span class="math inline">\(h\)</span>：三点 <span class="math inline">\(x_1,x_2, x_3\)</span> 共线 <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(h(x_1), h(x_2), h(x_3)\)</span>也<strong><u>共线</u></strong></p></li><li><p>射影映射的充要条件：映射 <span class="math inline">\(h:\text{IP}^2 \rightarrow \text{IP}^2\)</span> 是射影映射 <span class="math inline">\(\Leftrightarrow\)</span> 存在一个 <span class="math inline">\(3 \times 3\)</span> 的<strong><u>非奇异阵</u></strong> <span class="math inline">\(H\)</span>，使对 <span class="math inline">\(\forall x \in \text{IP}^2, h(x) =Hx\)</span></p></li><li><p>由充要条件导出的射影变换定义：一个平面（保线）变换是关于 3维齐次向量的一种线性变换，<span class="math inline">\(x&#39; =Hx\)</span>，其中 <span class="math inline">\(H\)</span> 为非奇异阵<span class="math display">\[\begin{bmatrix}x_1&#39; \\ x_2&#39; \\ x_3 &#39;\end{bmatrix} =\begin{bmatrix}h_{11} &amp; h_{12} &amp; h_{13} \\h_{21} &amp; h_{22} &amp; h_{23} \\h_{31} &amp; h_{32} &amp; h_{33} \\\end{bmatrix}\begin{bmatrix}x_1 \\ x_2 \\ x_3\end{bmatrix}\]</span></p><blockquote><p><strong>注意</strong>：该变换矩阵是一个齐次矩阵，由 8个<strong><u>比率</u></strong>决定其意义，故 9 个元素中只有 8个自由度</p></blockquote></li><li><p>直线与二次曲线的变换：</p><ul><li>直线的变换：在点变换 <span class="math inline">\(x&#39; =Hx\)</span> 下，直线变换 <span class="math inline">\(I\)</span> 为 <span class="math inline">\(I&#39; = H^{-T}I\)</span></li><li>二次曲线的变换：在点变换 <span class="math inline">\(x&#39; =Hx\)</span> 下，二次曲线 <span class="math inline">\(C\)</span> 变换为<span class="math inline">\(C&#39; = H^{-T}CH^{-1}\)</span></li><li>对偶二次曲线的变换：在点变换 <span class="math inline">\(x&#39; =Hx\)</span> 下，对偶二次曲线 <span class="math inline">\(C^{*}\)</span>变换为 <span class="math inline">\(C^{*}{&#39;} = HC^*H^T\)</span></li></ul><hr></li><li><p>不同层次的变换：等距变换 <span class="math inline">\(\Rightarrow\)</span> 相似变换 <span class="math inline">\(\Rightarrow\)</span> 仿射变换 <span class="math inline">\(\Rightarrow\)</span> 射影变换，逐步失真</p><ul><li><p>等距变换：平面 <span class="math inline">\(\text{IR}^2\)</span>上的变换，保持欧式距离不变，3dof，可表示为： <span class="math display">\[\begin{bmatrix}x&#39; \\ y&#39; \\ 1\end{bmatrix} =\begin{bmatrix}\epsilon \cos \theta &amp; -\sin \theta &amp; t_x \\\epsilon \sin \theta &amp; \cos \theta &amp; t_y \\0 &amp; 0 &amp; 1\end{bmatrix}\begin{bmatrix}x \\ y \\ 1\end{bmatrix}\]</span>该变换的<strong><u>不变量</u></strong>是长度、角度、面积等；<span class="math inline">\(\epsilon = 1\)</span>则等距变换时<strong>保向</strong>的（欧式变换 或刚体运动），否则是反射</p></li><li><p>相似变换：<u>等距变换</u> 和 <u>均匀缩放</u>的复合，4dof（新增缩放自由度），在不考虑反射变换的条件下可表示为： <span class="math display">\[\begin{bmatrix}x&#39; \\ y&#39; \\ 1\end{bmatrix} =\begin{bmatrix}s \cos \theta &amp; -s\sin \theta &amp; t_x \\s \sin \theta &amp; s\cos \theta &amp; t_y \\0 &amp; 0 &amp; 1\end{bmatrix}\begin{bmatrix}x \\ y \\ 1\end{bmatrix}\]</span>该变换的<strong><u>不变量</u></strong>是角度、长度间比率、面积间比率；<span class="math inline">\(s\)</span>是缩放系数，在保持形状不变的条件下改变图形大小</p></li><li><p>仿射变换：<u>非奇异线性变换</u> 与 <u>平移变换</u>的复合，6dof（新增两个正交轴上的拉伸自由度），可表示为： <span class="math display">\[\begin{bmatrix}x&#39; \\ y&#39; \\ 1\end{bmatrix} =\begin{bmatrix}a_{11} &amp; a_{12} &amp; t_x \\a_{21} &amp; a_{22} &amp; t_y \\0 &amp; 0 &amp; 1\end{bmatrix}\begin{bmatrix}x \\ y \\ 1\end{bmatrix}\]</span> 其中 <span class="math inline">\(A\)</span> 是一个 <span class="math inline">\(2 \times 2\)</span> 的非奇异矩阵，可拆解为： <span class="math display">\[A = R(\theta)R(-\phi)\begin{bmatrix} \lambda_1 &amp; 0 \\ 0 &amp;\lambda_2 \end{bmatrix}R(\phi)\]</span> 即 旋转 <span class="math inline">\(\phi\)</span> <span class="math inline">\(\rightarrow\)</span> <strong>在 x 和 y方向上分别按比例 <span class="math inline">\(\lambda_1\)</span> 和 <span class="math inline">\(\lambda_2\)</span> 缩放</strong> <span class="math inline">\(\rightarrow\)</span> 回旋 <span class="math inline">\(\phi\)</span> <span class="math inline">\(\rightarrow\)</span> 旋转 <span class="math inline">\(\theta\)</span><br>该变换的<strong><u>不变量</u></strong>是平行线关系、平行线段长度比、面积比等；<span class="math inline">\(\det{A} = \lambda_1\lambda_2\)</span>，<span class="math inline">\(\det{A} &gt; 0\)</span>说明是<u>保向的</u></p></li><li><p>射影变换：<strong>非齐次</strong> <u>非奇异线性变换</u> 与<u>平移变换</u> 的复合，8dof，可表示为： <span class="math display">\[x&#39; = H_px = \begin{bmatrix} A &amp; t \\ v^T &amp; u \end{bmatrix}x\]</span></p><blockquote><p><strong>注意</strong>：射影变换 和 仿射变换 的根本区别在于射影变换的向量 <span class="math inline">\(v \ne0\)</span>，可将理想点变换为非理想点</p></blockquote></li></ul><p><img src="/2024/07/27/machine_vision/projective-geometry/四层次变换.jpg" width="70%"></p><ul><li><p>射影变换的分解：一个一般的射影变换 <span class="math inline">\(H\)</span> 可以分解为如下形式 <span class="math display">\[\begin{align}H &amp;= H_SH_AH_P \\&amp;= \begin{bmatrix} sR &amp; t \\ 0^T &amp; 1\end{bmatrix} \begin{bmatrix} K &amp; 0\\ 0^T&amp; 1\end{bmatrix}\begin{bmatrix} I &amp; 0 \\ v^T &amp; u \end{bmatrix} \\&amp;= \begin{bmatrix} A &amp; vt \\ v^T &amp; u \end{bmatrix}\end{align}\]</span> 其中 <span class="math inline">\(A = sRK + tv^T\)</span>为非奇异矩阵；<span class="math inline">\(u \ne 0\)</span> 且 当<span class="math inline">\(s &gt; 0\)</span>时分解是唯一的（保向）</p><ul><li><span class="math inline">\(H_P\)</span> 为 射影变换，<span class="math inline">\(I\)</span>是单位矩阵；该变换的dof=2，负责移动无穷远直线</li><li><span class="math inline">\(H_A\)</span> 为 仿射变换，<span class="math inline">\(K\)</span> 是满足 <span class="math inline">\(|K|= 1\)</span>的归一化上三角矩阵；该变换的dof=2，进一步影响仿射性质，不移动 <span class="math inline">\(I_{\infty}\)</span></li><li><span class="math inline">\(H_S\)</span> 为 一般的相似变换，<span class="math inline">\(R\)</span>是旋转矩阵；该变换的dof=4，不影响仿射和射影性质</li></ul><blockquote><p><strong>注意</strong>：由于 <span class="math inline">\(H_P^{-1}\)</span>、<span class="math inline">\(H_A^{-1}\)</span>、<span class="math inline">\(H_{S}^{-1}\)</span> 仍分别是射影变换、仿射变换和相似变换，故 <span class="math inline">\(H^{-1} =H_P^{-1}H_A^{-1}H_{S}^{-1}\)</span> 同样仍是射影变换</p></blockquote></li></ul><hr></li><li><p>由图像恢复仿射和度量性质：</p><ul><li><p>无穷远直线：在射影变换 <span class="math inline">\(H\)</span>下，无穷远直线 <span class="math inline">\(I_{\infty}\)</span>仍为无穷远直线 <span class="math inline">\(\Leftrightarrow\)</span><span class="math inline">\(H\)</span>是<strong>仿射变换</strong>，证明如下 <span class="math display">\[\begin{align}&amp;\text{必要性：设 }H\text{ 是仿射变换：}I&#39;_{\infty} = H_A^{-T}I_{\infty} = \begin{bmatrix} A^{-T} &amp; 0 \\ -t^TA^{-T} &amp; 1  \\\end{bmatrix} \begin{bmatrix} 0 \\ 0 \\ 1 \end{bmatrix} =\begin{bmatrix} 0 \\ 0 \\ 1 \end{bmatrix} = I_{\infty}  \\&amp;\text{充分性：若要让无穷远点被映射为一个无穷远点，由于 }\begin{bmatrix} A &amp; t \\ v^T &amp; u \end{bmatrix} \begin{bmatrix}x_1 \\ x_2 \\ 0 \end{bmatrix} = \begin{bmatrix} A\begin{bmatrix} x_1 \\x_2 \end{bmatrix} \\ v_1x_1 + v_2x_2 \end{bmatrix} \\ &amp; \text{只需令} v_{1} = v_{2} = 0\text{ ，即该变换是仿射变换，证毕。}\end{align}\]</span></p></li><li><p>恢复仿射性质：关键在于辨认出透视图象上的<strong><u>无穷远直线</u></strong></p><ul><li><p>核心思想：世界图像中两直线 相交于 <span class="math inline">\(I_{\infty}\)</span> 在 <span class="math inline">\(\text{IP}^2\)</span> 的像上 <span class="math inline">\(\Rightarrow\)</span> 世界图像中的两直线平行</p><ul><li>欧式平面中的平行线相交于 <span class="math inline">\(I_{\infty}\)</span> <span class="math inline">\(\Rightarrow\)</span> 射影空间中的平行线相交于<span class="math inline">\(I\)</span></li><li>射影变换保持交点不变 <span class="math inline">\(\Rightarrow\)</span>经过射影变换后的两条直线仍相交于 <span class="math inline">\(I_{\infty}\)</span> 经射影变换的像 <span class="math inline">\(I\)</span> 上</li></ul><blockquote><p><strong>注意</strong>：<span class="math inline">\(I_{\infty}\)</span>在真实世界内是看不见的，但其转换到 <span class="math inline">\(\text{IP}^2\)</span>中是<strong>可视</strong>的直线 <span class="math inline">\(I\)</span></p></blockquote></li><li><p>仿射矫正：设 无穷远直线 的<strong>像</strong>是 <span class="math inline">\(I = (l_1, l_2, l_3)^T\)</span>（<span class="math inline">\(l_3 \ne 0\)</span>），则把 <span class="math inline">\(I\)</span> 映射回<u>不可见</u>的 <span class="math inline">\(I_{\infty} = (0, 0, 1)^T\)</span>的合适的射影变换如下： <span class="math display">\[\begin{align}H = H_A \begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ l_1&amp; l_2 &amp; l_3  \end{bmatrix}\end{align}\]</span> 其中 <span class="math inline">\(H_A\)</span>可以为<u>任何的<strong>仿射</strong>变换</u>；且总有 <span class="math inline">\(H^{-T}(l_1, l_2, l_3)^T = (0, 0, 1)^T =I_{\infty}\)</span>，即把无穷远直线的像映射回 <span class="math inline">\(I_{\infty}\)</span></p><p><img src="/2024/07/27/machine_vision/projective-geometry/消影线.jpg" width="70%"></p></li><li><p>消影点：世界平行线的交点在 <span class="math inline">\(\text{IP}^2\)</span>中的像，也就是欧氏空间中的<u><strong>无穷远点</strong></u></p><ul><li><p>利用长度比例计算消影点：设世界直线上的共线三点为 <span class="math inline">\(a, b,c\)</span>，图像上<strong>对应</strong>的共线三点为 <span class="math inline">\(a&#39;, b&#39;, c&#39;\)</span></p><ol type="1"><li>确定现实世界中的距离比：<span class="math inline">\(d(a, b):d(b,c) =a:b\)</span>，设世界齐次坐标为 <span class="math inline">\((0,1)^T,(a,1)^T,(a+b, 1)^T\)</span></li><li>在图像上量出距离比：设 <span class="math inline">\(d(a&#39;, b&#39;): d(b&#39;,c&#39;) = a&#39;:b&#39;\)</span>，设图像齐次坐标为 <span class="math inline">\((0, 1)^T, (a&#39;, 1)^T, (a&#39;+b&#39;,1)^T\)</span></li><li>计算使 <span class="math inline">\(a \rightarrowa&#39;\)</span>，<span class="math inline">\(b \rightarrowb&#39;\)</span>，<span class="math inline">\(c \rightarrowc&#39;\)</span> 的 1D 射影变换 <span class="math inline">\(H_{2 \times2}\)</span></li><li>直线 <span class="math inline">\(a&#39;b&#39;c&#39;\)</span>的消影点是变换 <span class="math inline">\(H_{2 \times 2}\)</span>下无穷远点 <span class="math inline">\((1, 0)^T\)</span> 的像</li></ol><p><img src="/2024/07/27/machine_vision/projective-geometry/由长度比例确定消影点.jpg" width="70%"></p></li><li><p>由长度比确定消影点的几何作图法：具体如下图所示</p><ol type="1"><li>确定现实世界中的距离比：<span class="math inline">\(d(a, b):d(b,c) =a:b\)</span></li><li>在图像上量出距离比：<span class="math inline">\(d(a&#39;, b&#39;) :d(b&#39;,c&#39;) = a&#39;:b&#39;\)</span></li><li>过图上 <span class="math inline">\(a&#39;\)</span> 画任意直线 <span class="math inline">\(l\)</span>，令直线上 <span class="math inline">\(a= a&#39;\)</span>、<span class="math inline">\(||ab|| : ||bc|| = a :b\)</span></li><li>连接 <span class="math inline">\(bb&#39;\)</span> 和 <span class="math inline">\(cc&#39;\)</span> 并交于图上点 <span class="math inline">\(o\)</span>；过 <span class="math inline">\(o\)</span> 作平行于 <span class="math inline">\(l\)</span> 的直线，交 <span class="math inline">\(a&#39;c&#39;\)</span>于<strong><u>消影点</u></strong> <span class="math inline">\(v&#39;\)</span></li></ol><p><img src="/2024/07/27/machine_vision/projective-geometry/作图法确定消影点.jpg" width="70%"></p></li></ul><p>已知图上两个<strong>消影点</strong> <span class="math inline">\(\Rightarrow\)</span>连接该两点得到图上<strong>消影线</strong></p><hr></li><li><p>虚圆点及其对偶：</p><ul><li><p>虚圆点：在任何<u><strong>相似变换</strong></u>下，<span class="math inline">\(I = (1, i, 0)^T\)</span> 和 <span class="math inline">\(J = (1, -i, 0)^T\)</span> 是 <span class="math inline">\(I_{\infty}\)</span>的两个不动点（共轭<strong><u>理想点</u></strong>），即： <span class="math display">\[\begin{align}I&#39; &amp;= H_s I \\&amp; = \begin{bmatrix}s\cos \theta &amp; -s \sin \theta &amp; t_s \\s \sin \theta &amp; s \cos \theta &amp; t_y \\0 &amp; 0 &amp; 1 \\\end{bmatrix}\begin{bmatrix}1 \\ i \\ 0\end{bmatrix} = se^{-i\theta} \begin{bmatrix} 1 \\ i \\ 0 \end{bmatrix}= I\end{align}\]</span></p><blockquote><p><strong>注意</strong>：在射影变换 <span class="math inline">\(H\)</span> 下，虚圆点 <span class="math inline">\(I\)</span> 和 <span class="math inline">\(J\)</span> 为不动点 <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(H\)</span> 为<strong><u>相似变换</u></strong></p></blockquote></li><li><p>虚圆点的意义：任意平面圆周与 <span class="math inline">\(I_{\infty}\)</span> 相交于 虚圆点，证明如下：<span class="math display">\[\begin{align}&amp;\text{当二次曲线为圆时有：}x_1^2 + x_2^2 + dx_1x_2 + ex_2x_3 +fx_3^2 = 0 \\&amp;\text{令该二次曲线与 }I_{\infty} 相交于 \textbf{理想点，即 }x_3 = 0\text{ ，则 } x_1^2 + x_2^2 = 0 \\&amp;\text{解得 }I = (1, i, 0)^T \text{，}J = (1, -i, 0)^T \text{，证毕。}\end{align}\]</span></p></li><li><p>虚圆点的对偶：二次曲线 <span class="math inline">\(C_{\infty}^{*}= IJ^T + JI^T\)</span> 与 虚圆点 对偶；<span class="math inline">\(C_{\infty}^{*}\)</span>表示两个虚圆点构成的<u><strong>退化二次曲线</strong></u>（<span class="math inline">\(\text{rk} =2\)</span>），在欧式坐标系下具体表示为： <span class="math display">\[\begin{align}C_{\infty}^* &amp;= \begin{bmatrix} 1 \\ i \\ 0 \end{bmatrix}\begin{bmatrix} 1 &amp; -i &amp; 0  \end{bmatrix} + \begin{bmatrix} 1 \\-i \\ 0 \end{bmatrix}\begin{bmatrix} 1 &amp; i &amp; 0 \end{bmatrix} \\&amp;= \begin{bmatrix} 1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 0\end{bmatrix}\end{align}\]</span> <span class="math inline">\(I_{\infty}\)</span> 是 <span class="math inline">\(C_{\infty}^*\)</span> 的零向量：<span class="math inline">\(C_{\infty}^* I_{\infty} = I(J^TI_{\infty}) +J(I^TI_{\infty}) = 0\)</span> <br>（虚圆点在 <span class="math inline">\(I_{\infty}\)</span> 上，故有 <span class="math inline">\(I^TI_{\infty} = J^T I_{\infty} =0\)</span>）</p></li><li><p><span class="math inline">\(C_{\infty}^{*}\)</span> 在射影变换<span class="math inline">\(H\)</span> 下不变 <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(H\)</span> 是<strong>相似变换</strong></p></li></ul></li><li><p>射影平面上的夹角：</p><ul><li>欧氏几何两直线夹角：<span class="math inline">\(\cos \theta =\dfrac{l_1m_1 + l_2 m_2}{\sqrt{(l_1^2 + l_2^2)  (m_1^2 +m_2^2)}}\)</span>，其中直线 <span class="math inline">\(l = (l_1, l_2,l_3)^T\)</span>，直线 <span class="math inline">\(m = (m_1, m_2,m_3)^T\)</span></li><li>射影几何两直线夹角：<span class="math inline">\(\cos \theta =\dfrac{l^TC_{\infty}^*m}{\sqrt{(l^TC_\infty^*l)(m^TC_{\infty}^*m)}}\)</span>，该公式在射影变换前后保持不变</li><li><span class="math inline">\(l^T C_{\infty}^{*}m = 0\)</span> <span class="math inline">\(\Rightarrow\)</span> 直线 <span class="math inline">\(l\)</span> 和 <span class="math inline">\(m\)</span> 垂直</li></ul></li></ul></li><li><p>恢复度量性质：关键在于辨认出射影平面上的 <span class="math inline">\(C_{\infty}^{*}\)</span>；设点变换为 <span class="math inline">\(x&#39; = Hx\)</span>，由 <span class="math inline">\(H\)</span> 的链式分解： <span class="math display">\[\begin{align}C_{\infty}^{*}{&#39;} &amp;= (H_PH_AH_S)C_{\infty}^{*} (H_PH_AH_S)^T \\&amp;= \begin{bmatrix}KK^T &amp; K^Kv \\ v^TKK^T &amp; v^TKK^Tv \\\end{bmatrix}\end{align}\]</span> 根据上面的分解式可知，<u><strong>射影成分</strong></u> <span class="math inline">\(v\)</span> 和 <u><strong>仿射成分</strong></u><span class="math inline">\(K\)</span> 可直接根据 <span class="math inline">\(C_{\infty}^{*}\)</span> 的像确定；同时由 SVD分解： <span class="math display">\[\begin{align}C_{\infty}^{*}{&#39;} &amp;= UC_{\infty}^{*} U^T \\   &amp;=U\begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ 0 &amp; 0&amp; 0 \end{bmatrix} U^T\end{align}\]</span> 通过将上式 与 <span class="math inline">\(H\)</span>的分解式做对比，可以解得 <span class="math inline">\(K\)</span> 和 <span class="math inline">\(v\)</span>，从而求出 <u>仅相差一个相似变换</u>的矫正射影变换 <span class="math inline">\(H = U\)</span></p><ul><li><p>在<u>已经过仿射矫正</u>的图像上进行度量矫正：设图像中直线 <span class="math inline">\(I&#39;\)</span> 和 <span class="math inline">\(m&#39;\)</span> 与世界平面中的一对<u><strong>垂直直线</strong></u> <span class="math inline">\(I\)</span> 和 <span class="math inline">\(m\)</span> 相对应</p><ul><li><p>由夹角公式推论可知，即便经过射影变换，仍有<strong>不变式</strong><span class="math inline">\(I&#39; C_{\infty}^{*}{&#39;} m&#39;=0\)</span>，令 <span class="math inline">\(v = 0\)</span>并展开为矩阵方程形式为： <span class="math display">\[\begin{align}&amp;\begin{pmatrix} l_1&#39;, l_2&#39;, l_3&#39; \end{pmatrix}\begin{bmatrix} KK^T &amp; \textbf{0} \\ \textbf{0}^T &amp; 0\end{bmatrix} \begin{pmatrix} m_1&#39; \\ m_2&#39; \\m_3&#39;  \end{pmatrix} = 0 \\&amp;\text{即 }\begin{pmatrix} l_1&#39;, l_2&#39; \end{pmatrix} KK^T(m_1&#39;, m_2&#39;)^T = 0\end{align}\]</span></p></li><li><p><span class="math inline">\(KK^T\)</span>是实对称正定阵；由上式求出 <span class="math inline">\(KK^T\)</span>后，进一步利用分解算法（如 Cholesky 分解法）求出 <span class="math inline">\(K\)</span></p></li></ul><blockquote><p><strong>注意</strong>：由于仍相差一步相似变换，故矫正后的图像和真实图像间存在缩放差距</p></blockquote><p><img src="/2024/07/27/machine_vision/projective-geometry/度量矫正.jpg" width="80%"></p></li></ul></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>machine vision</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>『cyber security-2』asymmetric encryption</title>
    <link href="/2024/07/22/cyber_security/asymmetric-encryption/"/>
    <url>/2024/07/22/cyber_security/asymmetric-encryption/</url>
    
    <content type="html"><![CDATA[<h2 id="公钥密码体系">公钥密码体系</h2><h3 id="一非对称加密概述">一、非对称加密概述</h3><ul><li><p>非对称加密方法：用<strong>两个<u>不同</u></strong>的密钥进行加密or 解密</p></li><li><p>两个密钥：公钥 + 私钥</p><ul><li>公开密钥：公开的，可用于加密 + 验签</li><li>私有密钥：秘密的，可用于解密 + 签名</li></ul></li><li><p>非对称的内涵：用于 <strong>加密 + 验签</strong> 的密钥 无法<strong>解密 or 签名</strong></p></li><li><p>公钥算法的条件：加密可行 + 破密不可行</p><ul><li>加密可行：<ul><li>产生一对密钥是计算可行的</li><li>已知公钥 + 明文，<u><strong>产生密文</strong></u>是计算可行的</li><li>接收方<u><strong>利用私钥解密</strong></u>是计算可行的</li></ul></li><li>破密不可行：<ul><li>利用<u><strong>公钥推断私钥</strong></u>是计算不可行的</li><li>已知公钥和密文，<u><strong>破解明文</strong></u>是计算不可行的</li></ul></li></ul></li><li><p>公钥加密的用途</p><ul><li>密钥分发：共享<u>对称密钥</u></li><li>数字签名：商业和个人应用</li></ul><p><strong>注意</strong>：公钥密码不一定比对称密钥更安全（取决于<strong>密钥长度</strong>）；且公钥密码计算开销很大，暂时难以取代传统密码</p></li><li><p>对称密钥加密 VS. 非对称密钥加密：</p><p><img src="/2024/07/22/cyber_security/asymmetric-encryption/算法对比.png" width="80%"></p></li></ul><hr><h3 id="二rsa算法">二、RSA算法</h3><ul><li><p>算法描述：大整数素因子分解系统，由图灵奖得主 Ronald L. Rivest +Adi Shamir 发明</p><ul><li>RSA是应用最广泛的<strong>公钥密码算法</strong></li><li>一种<strong>分组密码</strong>，其明文和密文均为 0 ~ n-1之间的整数（mod n）。</li></ul></li><li><p>产生密钥对：选择两个<strong>大素数</strong>p和q，p <span class="math inline">\(\ne\)</span> q</p><ul><li>计算 <span class="math inline">\(n = pq\)</span> 和 欧拉函数 <span class="math inline">\(\phi(n) = (p-1)(q-1)\)</span></li><li>选择整数e，使得 <span class="math inline">\(\gcd(e, \phi(n)) =1\)</span></li><li>选择整数d，使得 <span class="math inline">\(d  e \text{ mod }\phi(n) = 1\)</span></li><li>公钥KU = <span class="math inline">\(\{e, n\}\)</span>，私钥KR =<span class="math inline">\(\{d, n\}\)</span></li></ul></li><li><p>算法流程：设明文分组为M，密文分组为C；收发双方均知道 n 和e（即公钥），但只有接收方知道 d（即私钥）</p><ul><li>加密：<span class="math inline">\(\text{C} = \text{M}^\text{e}\text{ mod } n\)</span></li><li>解密：<span class="math inline">\(\text{M} = \text{C}^\text{d}\text{ mod } n = \text{M}^{\text{ed}} \text{ mod } n\)</span></li></ul></li><li><p>RSA算法需要满足的三个条件：<u>加解密</u> + <u>难破解</u></p><ul><li>能够找到 e、d、n 使得 <span class="math inline">\(\text{M}^{\text{ed}} \text{ mod } n =\text{M}\)</span>（<span class="math inline">\(\text{M} &lt;n\)</span>）</li><li>计算 <span class="math inline">\(\text{M}^\text{e}\)</span> 和 <span class="math inline">\(\text{C}^\text{d}\)</span> 相对容易</li><li>从 e 和 n （公钥）得到 d （私钥）是在计算上不可行的（所以应使 e 和 n的值尽可能大）</li></ul></li><li><p>RSA安全性分析：破解方法主要包括 <u>蛮力攻击</u> +<u>素因子分解攻击</u> + <u>选择密文攻击</u></p><ul><li>已知的破解方法至少跟<strong>因子分解</strong>难度相同：将大数 n分解为两个素因子很困难<ul><li>因子分解：将 n 分解为两个素因子p和q <span class="math inline">\(\Rightarrow\)</span> 计算 <span class="math inline">\(\phi(n) = (p-1) \times (q-1)\)</span> <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(d\equiv e^{-1}\)</span>(mod <span class="math inline">\(\phi(n)\)</span>)</li><li>另解：直接确定<span class="math inline">\(\phi(n)\)</span>，或直接确定 d</li></ul></li><li>尚未发现<strong>多项式时间</strong>的因子分解算法</li><li>512位的RSA已被证明是不安全的</li></ul><p><strong>注意</strong>：<span class="math inline">\(a \equivb\)</span> (mod) <span class="math inline">\(n\)</span> 指的是 <span class="math inline">\(a\)</span> 除以 <span class="math inline">\(n\)</span> 余数为 <span class="math inline">\(b\)</span></p></li><li><p>如何提高RSA安全性？</p><ul><li>选择足够大的 n（512bit已经不安全了）</li><li>e 和 d 相差不太大，也不太小</li><li>p 和 q 长度仅相差几位</li></ul></li></ul><hr><h3 id="三国产密码算法">三、国产密码算法</h3><ul><li><p>用途：保障<strong>商用密码</strong>（SM）的安全性</p></li><li><p>分类：主要包含 SM1、SM2、SM3、SM4、SM7，由国家密码局制定标准</p><ul><li>SM1：算法不公开，要调用专用加密芯片的接口<ul><li>对称密码</li><li>分组密码，分组长度为128bit</li><li>用于研制智能IC卡、智能密码钥匙、加密卡或加密机器等安全产品（政务通、警务通）</li></ul></li><li>SM2：算法已公开<ul><li>非对称密码，属于椭圆曲线密码机制（ECC）</li><li>多方面优于<strong>RSA</strong>（比RSA更新）</li><li>用于数字签名、密钥交换协议和公钥加密算法</li></ul></li><li>SM3：算法已公开<ul><li>类似MD5，使用<strong>Hash</strong>生成长度为256bit的摘要（或称杂凑值）</li><li>用于数字签名和验证，消息验证码生成和验证、随机数生成</li></ul></li><li>SM4：算法已公开<ul><li>对称密码</li><li>分组密码，分组长度为128bit；密钥长度为128bit</li><li>采用Feistel结构的分组密码算法（见对称加密算法），解密与加密结构相同</li><li>用于无线局域网产品</li></ul></li><li>SM7：算法不公开，要调用专用加密芯片的接口<ul><li>分组密码，分组长度为128bit；密钥长度为128bit</li><li>用于非接触式IC卡、工作门禁等身份识别应用、票务类应用</li></ul></li></ul><hr><h3 id="四diffie-hellman算法">四、Diffie-Hellman算法</h3><ul><li><p>素数的原根：设大素数是<span class="math inline">\(p\)</span>，若<span class="math inline">\(a\)</span>是素数<span class="math inline">\(p\)</span>的原根，则 <span class="math inline">\(a^1\)</span> mod <span class="math inline">\(p\)</span>, ..., <span class="math inline">\(a^{p-1}\)</span> mod <span class="math inline">\(p\)</span> 各不相同，且是 1 ~ p-1的一个置换</p></li><li><p>密钥交换算法：设<u>素数</u><span class="math inline">\(p\)</span>和其<u>本原根</u>为<span class="math inline">\(a\)</span>，都是<strong>公开</strong>的；A和B意图交换密钥</p><ol type="1"><li>A设置<strong>私钥</strong>，交换<strong>公钥</strong>（握手）：A选择一个随机整数<span class="math inline">\(X_A &lt; p\)</span>，并计算 <span class="math inline">\(Y_A = a^{X_A}\)</span> mod <span class="math inline">\(p\)</span>，把 <span class="math inline">\(Y_A\)</span> 发送给B</li><li>B设置<strong>私钥</strong>，交换<strong>公钥</strong>（握手）：B选择一个随机整数<span class="math inline">\(X_B &lt; p\)</span>，并计算<span class="math inline">\(Y_B = a^{X_B}\)</span> mod <span class="math inline">\(p\)</span>，把 <span class="math inline">\(Y_B\)</span> 发送给A</li><li>A计算共享密钥：根据B发来的<span class="math inline">\(Y_B\)</span>，求得 <span class="math inline">\(K =(Y_B)^{X_A}\)</span> mod <span class="math inline">\(p\)</span></li><li>B计算共享密钥：根据A发来的<span class="math inline">\(Y_A\)</span>，求得 <span class="math inline">\(K =(Y_A)^{X_B}\)</span> mod <span class="math inline">\(p\)</span></li></ol></li><li><p>DH算法安全性分析：有限域中<strong>离散对数</strong>计算的困难性</p><ul><li>求模指数：<span class="math inline">\(Y_B = a^{X_B}\)</span> mod<span class="math inline">\(p\)</span>，较容易</li><li>求一个数的离散对数：找出 <span class="math inline">\(X_B\)</span>使得 <span class="math inline">\(Y_B = a^{X_B}\)</span> mod <span class="math inline">\(p\)</span>，很困难</li></ul></li><li><p>中间人攻击：DH算法对中间人攻击并不安全，中间人可能跟A共享一个密钥<span class="math inline">\(K_2\)</span>、而跟B共享一个密钥<span class="math inline">\(K_1\)</span></p><p><img src="/2024/07/22/cyber_security/asymmetric-encryption/DH中间人.png" width="60%"></p><ul><li><p>攻击方式：</p><ul><li>窃听风险：A向中间人发送加密消息<span class="math inline">\(E(K_2,M)\)</span>，中间人使用<span class="math inline">\(K_2\)</span><strong>恢复并窃听</strong>消息<span class="math inline">\(M\)</span></li><li>重放风险：中间人截获并恢复了<span class="math inline">\(E(K_2,M)\)</span>，并向B发送了<strong>篡改</strong>后的<span class="math inline">\(E(K_1, M&#39;)\)</span></li><li>暴力破解：客户端私钥随机生成，而服务器方私钥固定 <span class="math inline">\(\Rightarrow\)</span>依据<u>海量密钥协商数据</u><strong>暴力破解</strong>服务器私钥</li></ul></li><li><p>解决方法：双方私钥在每次进行密钥交换通信时，都是<u>随机生成的<strong>临时私钥</strong></u>，也称DH<strong>E</strong>算法（<strong>E</strong>phemeral，临时性的）</p></li><li><p>ECDHE：基于<u>椭圆曲线</u>的密钥交换算法，在DHE的基础上利用ECC椭圆曲线特性</p><ul><li><p>特点：支持前向安全性（破解当前的密钥，则之前的加密数据也会被破解）</p><blockquote><p><strong>注意</strong>：RSA算法不支持前向安全性</p></blockquote></li><li><p>工作流程：</p><ol type="1"><li>客户端和服务端各随机选择一个椭圆曲线私钥，并生成椭圆曲线公钥</li><li>握手阶段，双方<strong>交换</strong>椭圆曲线公钥</li><li>双方各自使用自己的私钥 + 对方的公钥 通过<u>椭圆曲线运算</u>生成<strong>共享密钥</strong></li></ol></li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>cyber security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>『robotics-2』forward kinematics</title>
    <link href="/2024/07/22/robotics/forward-kinematics/"/>
    <url>/2024/07/22/robotics/forward-kinematics/</url>
    
    <content type="html"><![CDATA[<h2 id="正向运动学">正向运动学</h2><h3 id="一d-h-参数法">一、D-H 参数法</h3><ul><li><p>什么是"正向运动学"：已知开链机构各<strong><u>关节</u></strong>转角，求<strong><u>末端</u></strong>的位置和姿态</p></li><li><p>设置坐标系位置：</p><ul><li><p>确定 轴<span class="math inline">\(i\)</span> 的 <span class="math inline">\(\hat{z_i}\)</span>轴：<span class="math inline">\(\hat{z}_i\)</span> 的正方向与 关节轴<span class="math inline">\(i\)</span>的轴线重合，正方向由轴旋转下的<strong>右手螺旋定则</strong>确定</p></li><li><p>确定连杆坐标系的<strong>原点</strong>：设 <span class="math inline">\(\hat{z}_{i-1}\)</span> 和 <span class="math inline">\(\hat{z}_{i}\)</span>有唯一的<strong><u>公法线</u></strong>，令该公法线连接轴 <span class="math inline">\(\hat{z}_{i-1}\)</span> 和 轴 <span class="math inline">\(\hat{z}_i\)</span><br>系 {i-1} 的坐标原点就放在<u>轴i-1</u> 和 <u>公法线</u> 的交点处（系 {i}的原点暂时不确定）</p></li><li><p>确定 <span class="math inline">\(\hat{x}\)</span> 和 <span class="math inline">\(\hat{y}\)</span> 的正方向：{i-1} 的 <span class="math inline">\(\hat{x}\)</span>常选在对应的<strong>公法线</strong>上，指向 轴i；{i-1} 的 <span class="math inline">\(\hat{y}\)</span> 方向由右手系规范确定，即 <span class="math inline">\(\hat{x} \times \hat{y} = \hat{z}\)</span></p><blockquote><p><strong>注意</strong>：如果两个旋转轴相交导致<strong>公法线长度=0</strong>，任选一条平面<span class="math inline">\((\hat{z}_{i-1},\hat{z_i})\)</span>的法线即可；如果两个旋转轴平行，从<strong>无数条</strong>公法线中任选一条即可</p></blockquote></li></ul></li><li><p>定义 4 个参数：</p><ul><li><p>连杆长度 <span class="math inline">\(a_{i-1}\)</span>：公法线的长度，即 <span class="math inline">\(\hat{z}_{i-1}\xrightarrow{\text{沿}\hat{x}_{i-1}\text{平移}}\hat{z}_i\)</span>的距离</p><blockquote><p><strong>注意</strong>：这里不应该望文生义，<u>不是真实连杆的物理长度</u></p></blockquote></li><li><p>连杆扭转角度 <span class="math inline">\(\alpha_{i-1}\)</span>：<span class="math inline">\(\hat{z}_{i-1} \xrightarrow{\text{绕}\hat{x}_{i-1}\text{旋转}} \hat{z}_i\)</span> 的角度</p></li><li><p>连杆偏距 <span class="math inline">\(d_i\)</span>：从 <span class="math inline">\(\hat{x}_{i-1}\)</span> 与 <span class="math inline">\(\hat{z}_i\)</span> 的交点到连杆坐标系 {i}原点的<strong><u>有向</u>距离</strong>，即 <span class="math inline">\(\hat{x}_{i-1}  \xrightarrow{\text{沿}\hat{z}_i\text{平移}}\hat{x}_i\)</span> 的距离</p></li><li><p>关节转角 <span class="math inline">\(\phi_i\)</span>：<span class="math inline">\(\hat{x}_{i-1} \xrightarrow{\text{绕}\hat{z}_i旋转}\hat{x}_i\)</span> 的角度</p></li></ul><p><img src="/2024/07/22/robotics/forward-kinematics/四个参数.png" width="80%"></p></li></ul><hr><h3 id="二机器人正向运动学">二、机器人正向运动学</h3><ul><li><p>齐次变换矩阵：由 <strong><u>D-H 参数</u></strong>决定变换矩阵<span class="math inline">\(T_{i-1,i}\)</span>，每个连杆坐标系对应的齐次变换矩阵都有如下形式：<br><span class="math display">\[T_{i-1,i} = \mathbf{Rot}(\hat{x}, \alpha_{i-1})\mathbf{Trans}(\hat{x}, a_{i-1}) \mathbf{Trans}(\hat{z},d_i)\mathbf{Rot}(\hat{z}, \phi_i) \\= \begin{bmatrix} \cos \phi_i &amp;-\sin \phi_i &amp; 0 &amp; a_{i-1} \\ \sin \phi_i \cos \alpha_{i-1}&amp;\cos phi_i \cos \alpha_{i-1} &amp; -\sin \alpha_{i-1} &amp; -d_i\sin \alpha_{i-1} \\ \sin \phi_i \sin \alpha_{i-1} &amp; \cos \phi_i\sin \alpha_{i-1} &amp; \cos \alpha_{i-1} &amp; d_i \cos \alpha_{i-1} \\0 &amp; 0 &amp; 0 &amp; 1 \\ \end{bmatrix}\]</span></p><ul><li><p>旋转算子 1： <span class="math display">\[\mathbf{Rot}(\hat{x},\alpha_{i-1}) = \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp;\cos \alpha_{i-1} &amp; -\sin \alpha_{i-1} &amp; 0 \\0 &amp; \sin\alpha_{i-1} &amp; \cos \alpha_{i-1} &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp;1 \\ \end{bmatrix}\]</span></p></li><li><p>平移算子 1： <span class="math display">\[\mathbf{Trans}(\hat{x},a_{i-1}) = \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; a_{i-1} \\ 0 &amp; 1&amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp;1 \end{bmatrix}\]</span></p></li><li><p>平移算子 2： <span class="math display">\[\mathbf{Trans}(\hat{z},d_i) = \begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0&amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; d_i \\ 0 &amp; 0 &amp; 0 &amp; 1\end{bmatrix}\]</span></p></li><li><p>旋转算子 2： <span class="math display">\[\mathbf{Rot}(\hat{z},\phi_i) = \begin{bmatrix} \cos \phi_{i-1} &amp; -\sin \phi_{i-1} &amp; 0&amp; 0 \\ \sin \phi_{i-1} &amp; \cos \phi_{i-1} &amp; 0 &amp; 0 \\ 0&amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp;1  \end{bmatrix}\]</span></p></li></ul><p>则该开链机构的正向运动学方程为 <span class="math inline">\(T_{0n}(\theta_1, \dots ,\theta_n) =T_{01}(\theta_1)T_{12}(\theta_2)\dots T_{n-1,n}(\theta_n)\)</span><br><span class="math inline">\(T_{i-1,i}\)</span>表示<strong>相邻两个连杆</strong> {i-1} 和 {i} 的相对位移</p></li><li><p>齐次变换过程：从连杆坐标系{i-1} 变换到 连杆坐标系{i}</p><ol type="1"><li>绕 {i-1} 的 <span class="math inline">\(\hat{x}\)</span> 旋转 <span class="math inline">\(\alpha_{i-1}\)</span></li><li>沿 {i-1} 的 <span class="math inline">\(\hat{x}\)</span> 平移 <span class="math inline">\(a_{i-1}\)</span></li><li>沿 {i} 的 <span class="math inline">\(\hat{z}\)</span> 平移 <span class="math inline">\(d_{i}\)</span></li><li>绕 {i} 的 <span class="math inline">\(\hat{z}\)</span> 旋转 <span class="math inline">\(\phi_i\)</span></li></ol></li></ul><hr><h3 id="三实际算例">三、实际算例</h3><ul><li><p>求解时额外需要注意的：</p><ul><li>选取基坐标系：一般令 {0} 与 <strong>{1}</strong>重合，保证当关节为转动副时 <span class="math inline">\(a_0 = \alpha_0 =d_1 = 0\)</span>，为移动副时 <span class="math inline">\(a_o = \alpha_0= \phi_1 = 0\)</span></li><li>选取末端坐标系：一般把 {n}放在<strong>末端执行器</strong>上的某个参考点</li><li>关节是移动副：坐标系设置方式与 转动副 不同<ul><li><span class="math inline">\(\hat{z}\)</span>轴与移动副作用线方向相同（转动副的 <span class="math inline">\(\hat{z}\)</span> 满足右手螺旋）</li><li>连杆偏距 <span class="math inline">\({d}\)</span> 成为变量，关节转角<span class="math inline">\({\phi}\)</span>成为常量（转动副则相反）</li></ul></li><li>齐次变换的求解顺序：1 和 2 可颠倒，3 和 4 可颠倒</li><li><span class="math inline">\(\phi\)</span>转动的正方向：满足右手定则，大拇指沿轴方向，四指指向的方向是旋转正方向</li></ul></li><li><p>例题：下面以空间开链RRRP机器人为例，同时包含移动副和转动副</p><p><img src="/2024/07/22/robotics/forward-kinematics/RRRP.png" width="70%"></p><p><img src="/2024/07/22/robotics/forward-kinematics/表格法.png" width="70%"></p><ul><li>上表格中的 <span class="math inline">\((i, j)\)</span> 表示从 {i-1}到 {i} 需要经过 变换j</li><li>变换j 的值是在经过 变换j-1 后才求出的（不是开始时一次性量出的）</li><li>对于填充最后一个变量 <span class="math inline">\(\phi\)</span>，保持{i-1} 不动、先把 {i} 旋转 <span class="math inline">\(\phi_i\)</span>度，再看把 {i-1} 绕<span class="math inline">\(\hat{z}_i\)</span>旋转多少度可得到 {i}</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>robotics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>『signal and system-3』Fourier transform</title>
    <link href="/2024/07/12/signal_and_system/Fourier-transform/"/>
    <url>/2024/07/12/signal_and_system/Fourier-transform/</url>
    
    <content type="html"><![CDATA[<h2 id="傅里叶变换">傅里叶变换</h2><h3 id="一傅里叶级数">一、傅里叶级数</h3><ul><li><p>傅立叶级数的非复数表达形式：设 <span class="math inline">\(x(t)\)</span> 以 <span class="math inline">\(T_0\)</span> 为周期，则有 <span class="math display">\[\begin{align}&amp;x(t) = B_0 + \sum_{k=1}^\infty B_k \cos(k \omega_0 t) +\sum_{k=1}^\infty C_k \sin(k \omega_0 t) \\&amp;\text{其中} \begin{cases}B_0 = \frac{1}{T_0} \int_0^{T_0} x(t) dt \\ \\B_k = \frac{2}{T_0} \int_{0}^{T_0} x(t) \cos(k \omega_0 t) dt \\ \\C_k = \frac{2}{T_0} \int_{0}^{T_0} x(t) \sin(k \omega_0 t) dt \\\end{cases}\end{align}\]</span></p><blockquote><p><strong>注意</strong>：若 <span class="math inline">\(x(t)\)</span>为偶函数，最后一项必然=0；若 <span class="math inline">\(x(t)\)</span>为奇函数，前两项之和必然=0</p></blockquote></li><li><p>傅立叶级数的<strong>复数</strong>表达形式：更简洁，更常用，<strong><u>与上面的表述等价</u></strong><span class="math display">\[\begin{align}&amp;x(t) = \sum_{k=-\infty}^{+\infty} a_k e^{jk\omega_0 t} \\&amp;\text{其中 } a_k = \frac{1}{T_0} \int_0^{T_0} x(t) e^{-jk\omega t}dt \text{，} \omega_0 = \frac{2 \pi}{T_0} \\\end{align}\]</span> 其中 <span class="math inline">\(\omega_0\)</span>是基波频率，<span class="math inline">\(T_0 = \dfrac{2\pi}{T_0}\)</span> 是基波周期</p></li><li><p>两种傅立叶级数间的<u>转换关系</u>：互相可推导 <span class="math display">\[\begin{cases}B_0 = a_0 \\ \\B_k = a_{-k} + a_k \\ \\C_k = j(a_k - a_{-k}) \\\end{cases}\text{ }\text{ }\text{ }\text{ }\begin{cases}a_0 = B_0 \\ \\a_k = \frac{1}{2} (B_k - jC_k) \\ \\a_{-k} = \frac{1}{2} (B_k + jC_k) \\\end{cases}\]</span></p></li></ul><hr><h3 id="二函数的正交分解">二、函数的正交分解</h3><ul><li><p>内积运算：设二元运算 <span class="math inline">\(&lt;.,.&gt;\)</span> 满足以下性质：</p><ul><li>交换律：<span class="math inline">\(&lt;x, y&gt; = \overline{&lt;y,x&gt;}\)</span>，即交换运算顺序等于其<strong>共轭</strong></li><li>齐次性：<span class="math inline">\(&lt;\lambda x, y&gt; =\lambda&lt;x, y&gt;\)</span></li><li>叠加性：<span class="math inline">\(&lt;x + y, z&gt; = &lt;x,z&gt; +&lt;y + z&gt;\)</span></li><li>非负性：<span class="math inline">\(&lt;x, y&gt; = 0 \Leftrightarrowx = y\)</span>，<span class="math inline">\(&lt;x, y&gt; \ge0\)</span></li></ul></li><li><p>信号的内积运算：</p><ul><li>连续信号：<span class="math inline">\(&lt;x(t), y(t)&gt; =\int_{a}^{b} x(t) \overline{y(t)} dt\)</span></li><li>离散信号：<span class="math inline">\(&lt;x[n], y[n]&gt; = \sum_{k =a}^{k = b}x[n]\overline{y[n]}\)</span></li></ul><hr></li><li><p>正交函数族：设函数族为 <span class="math inline">\(\{e_k\}_{k=1,\dots , +\infty}\)</span>，则该函数族为正交函数族 <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(\forall k_i \ne k_j, &lt;e_{k_i}, e_{k_j}&gt; =0\)</span>，且 <span class="math inline">\(\forall k, &lt;e_k, e_k&gt;\ne 0\)</span> <br>该定义下的函数内积为 <span class="math inline">\(&lt;x(t), y(t)&gt; = \int_{T_0}x(t)\overline{y(t)} dt\)</span>，即任意<u>基波周期</u>下的内积运算</p><blockquote><p><strong>注意</strong>："正交函数族"的定义严格依赖于"内积运算"的定义</p></blockquote></li><li><p>标准正交基函数：设函数族为 <span class="math inline">\(\{e_k\}_{k=1, \dots,+\infty}\)</span>，则该函数族为<strong><u>标准</u></strong>正交基函数族<span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(\forall k_i \ne k_j, &lt;e_{k_i}, e_{k_j}&gt; =0\)</span>，且 <span class="math inline">\(\forall k, &lt;e_k, e_k&gt; =1\)</span></p><blockquote><p><strong>正交基标准化</strong>：<span class="math inline">\(e_k&#39; =\dfrac{e_k}{\sqrt{&lt;e_k,e_k&gt;}}\)</span>，可保证不同函数间内积为0，同时相同函数自己<strong>内积结果标准化为1</strong></p></blockquote></li><li><p>例：使用正交基推导傅立叶级数的复数形式</p><ol type="1"><li><p>证明 <span class="math inline">\(\{e^{jk\omega_{0}t}\}_{k=1,\dots,\infty}\)</span> 为正交基： <span class="math display">\[\begin{align}&amp;\text{同一函数自内积： }&lt;e^{jk\omega_0 t}, e^{jk\omega_0 t}&gt;= \int_{0}^{T_0} e^{jk\omega_0t} \overline{e^{jk\omega_0t}} dt=  \int_{0}^{T_0} e^{jk\omega_0 t} e^{-jk\omega_0 t} dt = T_0 &gt; 0 \\&amp;\text{不同函数做内积：}&lt;e^{jk_1\omega_0t}, e^{jk_2\omega_0t}&gt;= \int_{0}^{T_0} e^{jk_1\omega_0 t} \overline{e^{jk_2\omega_0 t}} dt =\int_{0}^{T_0} e^{j(k_1-k_2)\omega_0t} dt = e^{j(k_1-k_2)\omega_0T_0} -1 = e^{2jk\pi} - 1 = 0\end{align}\]</span></p></li><li><p>求解 <span class="math inline">\(x(t)\)</span> 展开级数的系数<span class="math inline">\(a_k\)</span>： <span class="math display">\[\begin{align}&amp;\text{求谁就“跟谁内积”：}&lt;x(t), e^{jk\omega_0 t}&gt; =&lt;\sum_{u=-\infty}^{+\infty} a_u e^{ju\omega_0t}, e^{jk\omega_0 t}&gt;\\&amp;\text{由内积的叠加性：} &lt;\sum_{u=-\infty}^{+\infty} a_ue^{ju\omega_0t}, e^{jk\omega_0 t}&gt; = \sum_{u=-\infty}^{+\infty}&lt;a_ue^{ju\omega_0 t}, e^{jk\omega_0 t}&gt; = T_0a_k \\&amp;\text{故 }a_k = \dfrac{&lt;x(t), e^{jk\omega_0t}&gt;}{T_0} =\dfrac{1}{T_0} \int_{T_0} x(t) \overline{e^{jk\omega_0 t}} dt =\dfrac{1}{T_0} \int_{T_0} x(t) e^{-jk\omega_0t} dt \text{ ，证毕。}\end{align}\]</span></p></li></ol><hr></li><li><p>正交基函数：</p><ul><li><p>Fourier 正交基：<span class="math inline">\(\{1\} \cup \{\cos(k\omega_0x)\}_{k=1, \dots+\infty} \cup \{\sin (k\omega_0x)\}_{k=1,\dots ,+\infty}\)</span></p></li><li><p>Legendre 多项式：<span class="math inline">\(P_n(x) =\dfrac{1}{2^n n!} \dfrac{d^n[(x^2 - 1)^n]}{dx^2}\)</span>；表示 <span class="math inline">\([-1, +1]\)</span> 上的函数 <span class="math inline">\(f(x) = \sum_{k=1}^{+\infty} a_k P_k(x)\)</span><span class="math display">\[\begin{align}&amp;\text{与自身做内积：} \int_{-1}^{+1} [P_n(x)]^2 dx = \dfrac{2}{2n +1} &gt; 0 \\&amp;\text{两不同函数内积：} \int_{-1}^{+1} P_m(x)P_n(x) dx = 0 \text{}\text{ }(m \ne n) \\\end{align}\]</span></p></li><li><p>Haar 小波：短时域上的方波</p></li></ul></li></ul><hr><h3 id="三傅里叶变换">三、傅里叶变换</h3><ul><li><p>傅里叶正逆变换的推导：定义 <span class="math inline">\(X(j\omega)= \int_{T_0} x(t) e^{-j\omega t}dt\)</span>，则有 <span class="math inline">\(a_k = \dfrac{1}{T_0} \int_{T_0} x(t)e^{-jk\omega_0 t} dt = \dfrac{1}{T_0} X(jk\omega_0)\)</span> <span class="math display">\[\begin{align}&amp;\text{则原傅里叶级数可改写为：} x(t) = \sum_{k=-\infty}^{+\infty}a_k e^{jk\omega_0t} = \dfrac{1}{\omega_0T_0} \sum_{k=-\infty}^{+\infty}X(jk\omega_0) e^{jk\omega_0} \omega_0 =\dfrac{1}{2\pi}\sum_{k=-\infty}^{+\infty} X(jk\omega_0) e^{jk\omega_0}\omega_0\\&amp; \text{将傅里叶级数推广到}\textbf{非周期}\text{函数上：令 }T_0\rightarrow +\infty \text{ ，则 }{\omega_0} \rightarrow 0 \\&amp;\text{由黎曼积分定义：}x(t) = \dfrac{1}{2\pi}\int_{-\infty}^{+\infty} X(j\omega)e^{j\omega t} d\omega \\&amp;\text{结合上述推导：}\begin{cases}X(j\omega) = \int_{-\infty}^{+\infty} x(t) e^{-j\omega t} dt \text{（正变换）} \\ \\x(t) = \dfrac{1}{2\pi} \int_{-\infty}^{+\infty} X(j\omega) e^{j\omega t}d\omega \text{ （逆变换）}\end{cases}\end{align}\]</span> 其中 <span class="math inline">\(x(t)\)</span> 为时域、<span class="math inline">\(X(j\omega)\)</span> 为频域；记傅里叶变换为 <span class="math inline">\(x(t) \xrightarrow{F} X(j\omega)\)</span>，逆变换为<span class="math inline">\(X(j\omega) \xrightarrow{F^{-1}}x(t)\)</span></p><blockquote><p><strong>注意</strong>：傅里叶变换揭示了同一个信号<strong>时域</strong> 和 <strong>频域</strong> 之间的互相转换关系</p></blockquote></li><li><p>典型信号的傅里叶变换：</p><ul><li><p><span class="math inline">\(e^{-at}u(t) \xrightarrow{F}\dfrac{1}{a + j\omega}\)</span>（<span class="math inline">\(a &gt;0\)</span>），又称"低通滤波器"：只允许<u>频率绝对值小</u>的通过，频率大的被抑制</p><ul><li><p>推导过程：按 Fourier 变换的定义积分即可 <span class="math display">\[\begin{align}X(j\omega) = \int_{-\infty}^{+\infty} x(t) e^{-j\omega t} dt =\int_{0}^{+\infty} e^{-at} \times e^{-j\omega t} dt = \dfrac{1}{a +j\omega}\text{ ，证毕。}\end{align}\]</span></p></li><li><p>模长-相位图：一般将信号拆解为 <span class="math inline">\(X(j\omega) = |X(j\omega)|\theta(j\omega)\)</span>，前者为 Amplitude，后者为 Phase</p><p><img src="/2024/07/12/signal_and_system/Fourier-transform/模长1.jpg" width="50%"><img src="/2024/07/12/signal_and_system/Fourier-transform/相位1.jpg" width="50%"></p><blockquote><p><strong>注意</strong>：对于复数 <span class="math inline">\(a +bj\)</span>，其模长=<span class="math inline">\(\dfrac{1}{\sqrt{a^2 +b^2}}\)</span>，相位 <span class="math inline">\(\theta\)</span>=<span class="math inline">\(\arctan{\dfrac{b}{a}}\)</span></p></blockquote></li></ul></li><li><p><span class="math inline">\(\delta(t) \xrightarrow{F}1\)</span>，<span class="math inline">\(1 \xrightarrow{F} 2\pi\delta(\omega)\)</span></p><ul><li>推导过程： <span class="math display">\[\begin{align}\text{左式推导：} &amp;x(j\omega) = \int_{-\infty}^{+\infty} x(t)e^{-j\omega t} dt = \int_{-\infty}^{+\infty} \delta(t) e^{-j\omega t} dt\\&amp;\text{由 } \int_{-\infty}^{+\infty} x(t) \delta(t) dt = x(0) \text{，} \int_{-\infty}^{+\infty} \delta(t) e^{-j\omega t} dt = e^{-j \omega\times 0} = 1 \\\text{右式推导：} &amp;x(j\omega) = \int_{-\infty}^{+\infty} e^{-j\omega t} dt = \lim_{N \rightarrow +\infty} \int_{-N}^{+N} e^{-j \omegat} dt = \lim_{N \rightarrow +\infty} \dfrac{1}{j\omega} ({e^{j\omega N}- e^{-j\omega N}}) \\ &amp;= \lim_{N \rightarrow +\infty}\dfrac{1}{j\omega} {2j \sin(\omega N)} = 2 \lim_{N \rightarrow +\infty}\dfrac{\sin(\omega N)}{\omega} = 2\pi \delta(\omega) \text{ ，证毕。}\end{align}\]</span></li></ul></li><li><p><span class="math inline">\([-\dfrac{\tau}{2},\dfrac{\tau}{2}]\text{ 上值为 }E\text{ 的方波} \xrightarrow{F} E \tau(Sa(\omega \dfrac{\tau}{2})) = \dfrac{2E\sin(\omega\dfrac{\tau}{2})}{\omega}\)</span>，其中 <span class="math inline">\(Sa\)</span> 指<strong>采样函数</strong></p><ul><li>推导过程： <span class="math display">\[\begin{align}X(j\omega) &amp;= \int_{-\dfrac{\tau}{2}}^{+\dfrac{\tau}{2}} Ee^{-j\omega t} dt = E \times \dfrac{1}{j\omega} (e^{j\omega\dfrac{\tau}{2}} - e^{-j\omega \dfrac{\tau}{2}}) \\&amp;=E \times \dfrac{1}{j\omega} \times 2j\sin(\omega \dfrac{\tau}{2})= \dfrac{2E\sin(\omega \dfrac{\tau}{2})}{\omega} \text{ ，证毕。}\end{align}\]</span></li></ul></li><li><p><span class="math inline">\(\dfrac{\sin(\omega_c t)}{\pi t}\xrightarrow{F}\)</span> <span class="math inline">\([-\omega_c,\omega_c]\)</span> 上 值为 1 的方波</p><ul><li>推导过程： <span class="math display">\[\begin{align}X(j\omega) &amp;= \int_{-\infty}^{+\infty} \dfrac{\sin(\omega_c t)}{\pit} e^{-j\omega t} dt = \int_{-\infty}^{+\infty}\dfrac{\sin(\omega_ct)}{\pi t} [\cos(\omega t) - j\sin(\omega t)] dt \\&amp;= \int_{-\infty}^{+\infty} \dfrac{\sin(\omega_c t)}{\pit}\cos(\omega t) dt - j\int_{-\infty}^{+\infty}\dfrac{\sin(\omega_ct)}{\pi t}\sin(\omega t) dt = \int_{-\infty}^{+\infty}\dfrac{\sin(\omega_c t)}{\pi t}\cos(\omega t) dt - 0\\\text{由积化和差}&amp;=\dfrac{1}{2}[\int_{-\infty}^{+\infty}\dfrac{\sin(\omega_c + \omega)t}{\pi t} dt +\int_{-\infty}^{+\infty} \dfrac{\sin(\omega_c - \omega)t}{\pi t} dt ]\\\text{由已知结论}&amp;\int_{-\infty}^{+\infty} \dfrac{\sin(\omegat)}{\pi t} = \begin{cases} 1 &amp; \text{when } \omega &gt; 0 \\ \\ -1&amp; \text{when } \omega &lt; 0  \end{cases} \text{ 故考虑对 }\omega\text{ 的取值范围讨论} \\&amp;\text{若 }\omega &lt; -\omega_c \text{，则 }\omega + \omega_c &lt;0, \text{ }\omega_c - \omega &gt; 0 \Rightarrow X(j\omega) =\dfrac{1}{2} (-1+1) = 0 \\&amp;\text{若 }-\omega_c &lt; \omega &lt; \omega_c \text{，则两项都=1}\Rightarrow X(j\omega) \dfrac{1}{2} (1 + 1) = 1 \\&amp;\text{若 }\omega &gt; \omega_c \text{ ，则 }X(j\omega) =\dfrac{1}{2} (1-1) = 0 \text{ ，证毕。}\end{align}\]</span></li></ul></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>signal and system</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>『robotics-1』spatial transform</title>
    <link href="/2024/07/07/robotics/spatial-transformations/"/>
    <url>/2024/07/07/robotics/spatial-transformations/</url>
    
    <content type="html"><![CDATA[<h2 id="空间变换与运动">空间变换与运动</h2><h3 id="一自由度">一、自由度</h3><ul><li><p>位形：机器人上每个<strong>点位的全体</strong>的集合，可根据位形确定机器人上所有点的位置；如二维坐标(x, y) 可表示平面上任意点位置</p><p>位形空间：包含所有可能的机器人位形的 n 维空间，一般记作C-space；机器人位形通常用 C-space 中的一个特征点表示</p></li><li><p>自由度定义：表示机器人位形的<strong>最少<u>连续实值</u>坐标数</strong></p></li><li><p>刚体的自由度：系统自由度 = (系统内各点的自由度之和) -(系统<strong>独立约束</strong>数)</p><ul><li><p>三维空间中的刚体：6 个自由度，推导过程如下：</p><ol type="1"><li>任选三维空间中刚体上的三个点A、B、C，分别记作 <span class="math inline">\((x_A, y_A, z_A)\)</span>、<span class="math inline">\((x_B, y_B, z_B)\)</span>、<span class="math inline">\((x_C, y_C, z_C)\)</span></li><li>由刚体性质，A和B的间距恒定值<span class="math inline">\(d_{AB}\)</span>，故B只可能分布在以A为球心、<span class="math inline">\(d_{AB}\)</span>为半径的球面上，即B可用经纬度 <span class="math inline">\((\lambda, \phi)\)</span> 表示</li><li>由刚体性质，A和C、B和C的间距均为定值<span class="math inline">\(d_{AC}\)</span>、<span class="math inline">\(d_{BC}\)</span>，故C只可能分布在球A和球B的交圆上，即C可用圆上转角<span class="math inline">\(\theta\)</span> 表示</li></ol><p>故三维空间内的刚体自由度为 6，可以用 <span class="math inline">\((x_A, y_A, z_A, \lambda, \phi, \theta)\)</span>表示</p></li><li><p>二维平面中的刚体：3个自由度，相当于在三维空间的情形下新增了三个独立约束 <span class="math inline">\(z_A = 0, z_B = 0, z_C = 0\)</span></p></li></ul></li><li><p>机器人的自由度：通过<u>刚体</u>和<u>关节</u>得到机器人的自由度</p><ul><li><p>机器人关节：连接两个构件，可分为以下几个类别：</p><ul><li><p>转动副：关节自由度 =1，允许两个构件绕同一个关节轴旋转，又称<strong>铰链</strong><br><img src="/2024/07/07/robotics/spatial-transformations/转动副.jpg" width="60%"></p><blockquote><p><strong>注意</strong>：转动副 对另一<u>平面刚体</u>的约束 =2，对另一<u>空间刚体</u>的约束 = 5（保留一个旋转自由度）</p></blockquote></li><li><p>移动副：关节自由度 =1，允许关节沿轴线方向平移运动，又称<strong>滑动</strong><br><img src="/2024/07/07/robotics/spatial-transformations/移动副.jpg" width="60%"></p><blockquote><p><strong>注意</strong>：移动副 对另一<u>平面刚体</u>的约束 =2，对另一<u>空间刚体</u>的约束 = 5（保留一个平移自由度）</p></blockquote></li><li><p>螺旋副：关节自由度 =1，允许两个构件绕同一个关节轴旋转、且在旋转的<strong>同时</strong>平移运动<br><img src="/2024/07/07/robotics/spatial-transformations/螺旋副.jpg" width="60%"></p><blockquote><p><strong>注意</strong>：螺旋副 对<u>空间刚体</u>的约束 =5（保留一个旋转自由度，无法讨论对平面刚体的约束，下同）</p></blockquote></li><li><p>圆柱副：关节自由度 =2，允许两个构件沿关节轴做<strong>独立</strong>的平移和旋转<br><img src="/2024/07/07/robotics/spatial-transformations/圆柱副.jpg" width="60%"></p><blockquote><p><strong>注意</strong>：圆柱副 对另一<u>空间刚体</u>的约束 =4（保留一个旋转 + 一个平移自由度）</p></blockquote></li><li><p>虎克铰：关节自由度 =2，由两个<strong>正交排列</strong>的转动副组成，又称<strong>万向节</strong><br><img src="/2024/07/07/robotics/spatial-transformations/虎克铰.jpg" width="60%"></p><blockquote><p><strong>注意</strong>：虎克铰 对另一<u>空间刚体</u>的约束 =4（保留两个旋转自由度）</p></blockquote></li><li><p>球铰：关节自由度 = 3，类似人类的<strong>肩关节</strong><br><img src="/2024/07/07/robotics/spatial-transformations/球铰.jpg" width="60%"></p><blockquote><p><strong>注意</strong>：球铰 对另一<u>空间刚体</u>的约束 =3（保留三个旋转自由度）</p></blockquote></li></ul></li><li><p>Grubler 公式：设机构有 <span class="math inline">\(N\)</span>个构件（含基座），有 <span class="math inline">\(J\)</span> 个关节；第<span class="math inline">\(i\)</span> 个关节的自由度为 <span class="math inline">\(f_i\)</span>、独立约束数为 <span class="math inline">\(c_i\)</span> <br>则该机器人的自由度如下： <span class="math display">\[\begin{align}\text{dof} &amp;= m(N - 1) - \sum_{i=1}^{J}c_i \\&amp;=m(N-1) - \sum_{i=1}^{J}(m-f_i) \\&amp;=m(N-1-J) + \sum_{i=1}^{J} f_i\end{align}\]</span> 其中 <span class="math inline">\(m\)</span>表示刚体自由度，对于空间刚体 <span class="math inline">\(m =6\)</span>、对于平面刚体 <span class="math inline">\(m =3\)</span>；对于所有关节都满足 <span class="math inline">\(f_i + c_i =m\)</span></p><ul><li><p>平面 <span class="math inline">\(k\)</span>杆结构（例）：属于平面机构，<span class="math inline">\(m =3\)</span></p><ul><li><strong>开链</strong>结构：又称<strong>串联</strong>机构，机构中不存在任何闭环<br>设机构有 <span class="math inline">\(k\)</span>个关节，则（含地面）有 <span class="math inline">\(k+1\)</span>个构件，<span class="math inline">\(\text{dof}=3((k+1) - 1 - k) + k*1 =k\)</span> <br><div style="text-align: center;"><img src="/2024/07/07/robotics/spatial-transformations/开链结构.jpg" width="40%"></div></li><li>闭链结构：有<strong>闭环</strong>的结构，由于地面本身也是一个构件，故可以与地面构成闭环<br>设机构有 <span class="math inline">\(k\)</span>个关节，则（含地面）有 <span class="math inline">\(k\)</span>个构件，<span class="math inline">\(\text{dof} = 3(k - 1 - k) + k*1 = k- 3\)</span> <br><div style="text-align: center;"><img src="/2024/07/07/robotics/spatial-transformations/闭链结构.jpg" width="40%"></div></li><li>曲柄滑块结构：属于<strong>闭链</strong>结构；如下图共有 3 个转动副和1 个移动副，与地面形成闭环<br><span class="math inline">\(\text{dof} =3(4 - 1 - 4) + 3 * 1 + 1 * 1 = 1\)</span> <br><div style="text-align: center;"><img src="/2024/07/07/robotics/spatial-transformations/曲柄滑块结构.jpg" width="40%"></div></li></ul></li><li><p>空间结构（例）：如下图 Delta 机器人，<span class="math inline">\(m = 6\)</span>；如下图每条腿有 4 个球铰、3个转动副、5 根杆<br><span class="math inline">\(\text{则 dof} = 6(3*5+2- 1 - (4*3+3*3)) + 3*3 * 1 + 3*4 * 3 = 15\)</span> <br><img src="/2024/07/07/robotics/spatial-transformations/Delta机器人.jpg" width="40%"></p><blockquote><p><strong>注意</strong>：上平台为静平台（自由度 =0），下平台为<strong>动平台</strong>（自由度 = 3），剩余 12 个自由度表示3 个平行四边形分别绕其长轴旋转的自由度</p></blockquote></li></ul></li></ul></li></ul><hr><h3 id="二刚体位形与转动">二、刚体位形与转动</h3><ul><li><p>空间拓扑表示：</p><ul><li>n 维欧氏空间用 <span class="math inline">\(\mathbb{R}^n\)</span>表示，<span class="math inline">\(\text{S}^n\)</span> 表示 n + 1维空间内的 n 维球表<strong>表面</strong>（如 <span class="math inline">\(\text{S}^1\)</span> 表示平面圆、<span class="math inline">\(\text{S}^2\)</span>表示空间内的<strong>球面</strong>）</li><li>拓扑表示的笛卡尔积：如 2R 机械臂的 C-space 可表示为 <span class="math inline">\(\text{S}^1 \times\text{S}^1\)</span>，三维欧氏空间可表示为 <span class="math inline">\(\text{R}^3 \times \text{S}^2 \times\text{S}^1\)</span></li></ul></li><li><p>参考坐标系：单位长度预先固定，可以放在空间中的任何位置</p><ul><li>空间坐标系：定义的相对静止的坐标系，记作 {s}</li><li>物体坐标系：附着在某个运动刚体上的<strong>随动</strong>坐标系，记作{b}</li></ul><blockquote><p><strong>注意</strong>：任何参考<strong>三维</strong>坐标系都满足<strong><u>右手系</u></strong></p></blockquote></li><li><p>旋转操作与角速度：</p><ul><li><p>旋转矩阵：记作 <span class="math inline">\(\textbf{R} =(r_{ij})_{3 \times 3} = (\hat{x}_b, \hat{y}_b,\hat{z}_b)\)</span>，其三个列向量分别对应 {b}的三个<strong>单位坐标轴</strong></p><ul><li>正则条件：<span class="math inline">\(\hat{x}_b\)</span>、<span class="math inline">\(\hat{y}_b\)</span>、<span class="math inline">\(\hat{z}_b\)</span> 均为<strong><u>单位向量</u></strong></li><li>正交条件：<span class="math inline">\(\hat{x}_b \cdot \hat{y}_b =\hat{x}_b \cdot \hat{z}_b = \hat{y}_b \cdot \hat{z}_b =0\)</span>，即三个单位向量<strong><u>两两正交</u></strong></li></ul><blockquote><p><strong>注意</strong>：以上两个条件可以精简为矩阵形式 <span class="math inline">\(\textbf{R}^T \textbf{R} =\textbf{I}\)</span>，且右手系条件下有 $ = 1$</p></blockquote></li><li><p>旋转矩阵的应用：主要包含以下三种</p><ul><li><p>表示姿态：<span class="math inline">\(\textbf{R}\)</span>本身就是原点与O重合的<strong><u>坐标系</u></strong>，<span class="math inline">\(\textbf{R}_{bc}\)</span> 表示 {c} 相对 {b}的位姿态；若基础坐标系默认为 {s} 系：</p><ul><li>第一列表示 <span class="math inline">\(\textbf{R}\)</span> 的<strong>x轴</strong> 在 {s} 系下的坐标</li><li>第二列表示 <span class="math inline">\(\textbf{R}\)</span> 的<strong>y轴</strong> 在 {s} 系下的坐标</li><li>第三列表示 <span class="math inline">\(\textbf{R}\)</span> 的<strong>z轴</strong> 在 {s} 系下的坐标</li></ul><blockquote><p><strong>注意</strong>：由旋转矩阵性质可知，<span class="math inline">\(\textbf{R}_{ab} = \textbf{R}_{ba}^{-1} =\textbf{R}_{ba}^{T}\)</span></p></blockquote></li><li><p>变换参考坐标系：<span class="math inline">\(\textbf{R}_{ac} =\textbf{R}_{ab} \textbf{ R}_{bc}\)</span>，可理解为将 {c} 在 {b}下的姿态转移到 {a} 中 <br>向量的坐标系变换：<span class="math inline">\(p_{a} = \textbf{R}_{ab} \text{}p_b\)</span>，也就是将向量 <span class="math inline">\(p\)</span>的坐标从 {b} 转移到 {a} 中</p><blockquote><p><strong>注意</strong>：以上是"<strong>下角标相消</strong>"的两种等价表述，因为<span class="math inline">\(\textbf{R}\)</span>本质上就是三个列向量坐标</p></blockquote></li><li><p>旋转某一向量或坐标系：将 <span class="math inline">\(\textbf{R}\)</span>表示为<strong><u>旋转操作算子</u></strong>，记作 <span class="math inline">\(\textbf{R} =  \textbf{Rot}(\hat{\omega},\theta)\)</span>，表示绕单位轴 <span class="math inline">\(\omega\)</span> 旋转 <span class="math inline">\(\theta\)</span> 角</p><ul><li><p>相对基本轴的旋转：</p><ul><li>围绕 x轴 旋转：<span class="math display">\[\textbf{R} =\textbf{Rot}(\hat{x}, \theta) = \begin{bmatrix} 1 &amp; 0 &amp; 1 \\ 0&amp; \cos\theta &amp; -\sin \theta \\ 0 &amp; \sin \theta &amp; \cos\theta \end{bmatrix} \]</span></li><li>围绕 y轴 旋转：<span class="math display">\[\textbf{R} =\textbf{Rot}(\hat{y}, \theta) = \begin{bmatrix} \cos \theta &amp; 0&amp; \sin \theta \\ 0 &amp; 1 &amp; 0 \\ -\sin \theta &amp; 0 &amp;\cos \theta \end{bmatrix} \]</span></li><li>围绕 z轴 旋转：<span class="math display">\[\textbf{R} =\textbf{Rot}(\hat{z}, \theta) = \begin{bmatrix} \cos \theta &amp; -\sin\theta &amp; 0 \\  \sin\theta &amp; \cos \theta &amp; 0 \\ 0 &amp; 0&amp; 1 \end{bmatrix} \]</span></li></ul></li><li><p>旋转坐标系：考虑将 {b} 绕单位轴 <span class="math inline">\(\hat{\omega}\)</span> 旋转 <span class="math inline">\(\theta\)</span> 角，即 <span class="math inline">\(\textbf{R} = \textbf{Rot}(\hat{\omega},\theta)\)</span></p><ul><li><span class="math inline">\(\hat{\omega}\)</span> 在 {s}中表达，绕固定坐标系的轴 <span class="math inline">\(\hat{\omega}\)</span> 转动：<span class="math inline">\(\textbf{R}_{sb&#39;} = \textbf{RR}_{sb}\)</span>，即<u>算子左乘</u></li><li><span class="math inline">\(\hat{\omega}\)</span> 在 {b}中表达，绕物体坐标系的轴 <span class="math inline">\(\hat{\omega}\)</span> 转动：<span class="math inline">\(\textbf{R}_{sb&#39;} = \textbf{R}_{sb}\textbf{R}\)</span>，即<u>算子右乘</u></li></ul><blockquote><p><strong>注意</strong>：对于两个坐标系，<strong><span class="math inline">\(\omega\)</span>的值是相等的</strong>（比如都是各自坐标系下的 z轴），但实际很可能不是空间内同一个轴</p></blockquote><p><img src="/2024/07/07/robotics/spatial-transformations/旋转算子.png" width="70%"></p></li><li><p>旋转向量：<span class="math inline">\(v&#39; = \textbf{R}v\)</span>，其中 <span class="math inline">\(\textbf{R}\)</span>是旋转算子（表示绕哪个<u>轴</u>旋转多少<u>角度</u>的 <span class="math inline">\(\textbf{R}\)</span>）</p></li></ul></li></ul><hr></li><li><p>角速度：设一个单位坐标系 <span class="math inline">\((\hat{x},\hat{y}, \hat{z})\)</span> 附着在一个旋转物体上，旋转轴为 <span class="math inline">\(\hat{\omega}\)</span></p><ul><li>旋转角速度：<span class="math inline">\(\omega = \hat{\omega}\dot{\theta}\)</span>，方向沿 <span class="math inline">\(\hat{\omega}\)</span> 方向</li><li>单位轴速度：<span class="math inline">\(\dot{\hat{x}} = \omega\times \hat{x}\)</span>，<span class="math inline">\(\dot{\hat{y}} =\omega \times \hat{y}\)</span>，<span class="math inline">\(\dot{\hat{z}} = \omega \times\hat{z}\)</span>，方向沿旋转切线方向</li><li>角速度矩阵表示：设 <span class="math inline">\(\mathbf{R}(t)\)</span> 是 {b} 相对 {s} 在时刻 t的姿态矩阵，<span class="math inline">\(\omega_s\)</span> 表示 {s}中的角速度，<span class="math inline">\(r_1(t)\)</span> 表示{s} 中的<span class="math inline">\(\hat{x}\)</span>，其余轴同理 <br>则有 <span class="math inline">\(\dot{r}_i = \omega_s \times r_i\)</span>，<span class="math inline">\(i = 1,2,3\)</span>；<span class="math inline">\(\dot{\mathbf{R}} = [\omega_s \times r_1, \omega_s\times r_2, \omega_s \times r_3] =\omega_s \times\mathbf{R}\)</span></li></ul></li></ul></li></ul><hr><h3 id="三刚体的一般运动">三、刚体的一般运动</h3><ul><li><p>齐次变换矩阵：又称<strong>刚体运动群</strong>，是所有 <span class="math inline">\(4 \times 4\)</span> 的实矩阵 <span class="math inline">\(T\)</span> 的集合： <span class="math display">\[T= \begin{bmatrix} R &amp; p \\ 0 &amp; 1 \end{bmatrix} = \begin{bmatrix}r_{11} &amp; r_{12} &amp; r_{13} &amp; p_1 \\ r_{21} &amp; r_{22} &amp;r_{23} &amp; p_2 \\ r_{13} &amp; r_{23} &amp; r_{33} &amp; p_3 \\ 0&amp;  0 &amp;0 &amp; 1 \end{bmatrix}\]</span></p><blockquote><p><strong>注意</strong>：<span class="math inline">\(R\)</span>是旋转矩阵，描述 {b} 相对 {s} 的姿态；<span class="math inline">\(p \in\mathbb{R}^3\)</span> 是 {b}原点 在 {s} 中的坐标</p></blockquote><ul><li><p>齐次变换矩阵的性质：</p><ul><li><span class="math inline">\(T^{-1}\)</span> 也是齐次变换矩阵，<span class="math display">\[T^{-1} = \begin{bmatrix} R^T &amp; -R^Tp \\ 0&amp; 1 \\ \end{bmatrix}\]</span></li><li>两个齐次变换矩阵的乘积也是齐次变换矩阵</li><li>满足乘法结合律 <span class="math inline">\((T_1T_2)T_3 =T_1(T_2T_3)\)</span>，但一般不满足交换律 <span class="math inline">\(T_1T_2 \ne T_2T_1\)</span></li></ul></li><li><p>齐次变换的性质：设 <span class="math inline">\(x, y \in\mathbb{R}^3\)</span>，用 <span class="math inline">\((R, p)\)</span>表示 <span class="math inline">\(T\)</span>，用 <span class="math inline">\(Rx + p\)</span> 表示 <span class="math inline">\(Tx\)</span></p><ul><li>保等距性：<span class="math inline">\(||Tx - Ty|| = ||x -y||\)</span>，其中 <span class="math inline">\(||\cdot||\)</span> 表示<span class="math inline">\(\mathbb{R}^3\)</span> 中的标准范数</li><li>保角性：对 <span class="math inline">\(\forall z \in\mathbb{R}^3\)</span>，都有 <span class="math inline">\(&lt;Tx-Tz,Ty-Tz&gt; = &lt;x-z, y-z&gt;\)</span>，<span class="math inline">\(&lt;\cdot, \cdot&gt;\)</span> 表示 <span class="math inline">\(\mathbb{R}^3\)</span> 中的标准内积</li></ul><blockquote><p><strong>注意</strong>：三角形(x, y, z)和变换后的新三角形(Tx, Ty,Tz)是<strong><u>全等</u></strong>的，即刚体运动</p></blockquote></li></ul></li><li><p>齐次变换矩阵的用途：</p><ul><li><p>表示位形：<span class="math inline">\(T_{ab} \leftarrow (R_{ab},p_{ab})\)</span>，其中 <span class="math inline">\(R_{ab}\)</span> 表示{b} 相对 {a} 的位姿，<span class="math inline">\(p_{ab}\)</span> 表示{b}原点 在 {a} 中的坐标<br></p><blockquote><p><strong>注意</strong>：对于任意两个坐标系 {a} 和 {b}，总有 <span class="math inline">\(T_{ab} = T_{ba}^{-1}\)</span></p></blockquote></li><li><p>改变参考坐标系：类似于旋转运动中的<u>下角标相消</u>原则</p><ul><li><span class="math inline">\(T_{a\mathbf{b}}T_{\mathbf{b}c} =T_{ac}\)</span>，相当于把 {c} 在 {b} 中的位形转移到 {a}</li><li><span class="math inline">\(T_{a\mathbf{b}} v_{\mathbf{b}} =v_{a}\)</span>，其中 <span class="math inline">\(v_b\)</span>指向量<span class="math inline">\(v\)</span>在{b}中的表达，<span class="math inline">\(v_a\)</span> 指向量<span class="math inline">\(v\)</span>在{a}中的表达</li></ul></li><li><p>移动坐标系：</p><ul><li><p>旋转算子：<span class="math display">\[\textbf{Rot}(\hat{\omega},\theta) = \begin{bmatrix} \textbf{R} &amp; 0 \\ 0 &amp; 1\end{bmatrix}\]</span></p></li><li><p>移动算子：<span class="math display">\[\textbf{Trans}(p) =\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; p_x  \\ 0 &amp; 1 &amp; 0 &amp;p_y \\ 0 &amp; 0 &amp; 1 &amp; p_z \\ 0 &amp; 0 &amp; 0 &amp;  1\end{bmatrix}\]</span></p></li><li><p>{b} 先相对 {s} 的 轴 <span class="math inline">\(\hat{\omega}\)</span> 旋转 <span class="math inline">\(\theta\)</span>，再相对 {s} 移动 <span class="math inline">\(p\)</span>：（"先转再移"左乘）</p><p><span class="math display">\[T_{sb&#39;} = TT_{sb} =\textbf{Trans}(p) \textbf{Rot}(\hat{\omega}, \theta)T_{sb} \\ =\begin{bmatrix} RR_{sb} &amp; R p_{sb} + p \\ 0 &amp; 1\end{bmatrix}\]</span></p></li><li><p>{b} 先相对自身移动 <span class="math inline">\(p\)</span>，再相对移动后坐标系的轴 <span class="math inline">\(\hat{\omega}\)</span> 转动：（"先移再转"右乘）</p><p><span class="math display">\[T_{sb&#39;} = T_{sb}T =T_{sb}\textbf{Trans}(p) \textbf{Rot}(\hat{\omega}, \theta) \\ =\begin{bmatrix} R_{sb}R &amp; R_{sb}p + p_{sb} \\ 0 &amp;1  \end{bmatrix}\]</span></p></li></ul></li><li><p>移动向量：<span class="math inline">\(v&#39; = \textbf{R}v +p\)</span>，其中 <span class="math inline">\(\textbf{R}\)</span>为旋转算子（表示绕哪个<u>轴</u>旋转多少<u>角度</u>的 <span class="math inline">\(\textbf{R}\)</span>），<span class="math inline">\(p\)</span> 为平移向量</p></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>robotics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>『signal and system-2』LTI</title>
    <link href="/2024/06/29/signal_and_system/linear-time-invariant-system/"/>
    <url>/2024/06/29/signal_and_system/linear-time-invariant-system/</url>
    
    <content type="html"><![CDATA[<h2 id="线性时不变系统lti">线性时不变系统（LTI）</h2><h3 id="一线性时不变系统的定义">一、线性时不变系统的定义</h3><ul><li>一个系统同时是<u><strong>线性</strong></u>且<u><strong>时不变</strong></u>的，全称是Linear Time-Invariant system</li><li>研究 LTI 的意义：LTI 足够简单，如果已知一个 <span class="math inline">\(x(t) \rightarrowy(t)\)</span>，那么可以知道其它所有 <span class="math inline">\(x(t)\rightarrow y(t)\)</span><ul><li>研究线性系统的意义：现实世界中没有可以<strong>无限制放大</strong>输出信号倍数，<strong>无限制叠加</strong>输出信号的系统</li><li>研究时不变系统的意义：现实世界中没有可以<strong>永远不随时间改变输出</strong>的系统</li></ul></li></ul><hr><h3 id="二离散-lti-卷积">二、离散 LTI 卷积</h3><ul><li><p>单位脉冲响应：记作 <span class="math inline">\(h[n]\)</span>，定义为 <span class="math inline">\(\delta[n] \xrightarrow{LTI}h[n]\)</span>，即<u><strong>单位脉冲序列</strong></u>经过 LTI系统输出得到的信号</p><blockquote><p><strong>注意</strong>：单位脉冲响应 <span class="math inline">\(h[n]\)</span> <strong>唯一标识</strong>了一个LTI；已知 <span class="math inline">\(h[n]\)</span>，能够求出任意信号 x输入该 LTI 输出的信号</p></blockquote></li><li><p>列表法：计算时间复杂度为 <span class="math inline">\(O(N^2)\)</span></p><ul><li><p>已知 <span class="math inline">\(h[n]\)</span> 和输入 <span class="math inline">\(x[n]\)</span>，求解卷积结果 <span class="math inline">\(x[n] * h[n]\)</span>：设 <span class="math inline">\(h[n]\)</span> 中 n 的取值范围是 -2 ~ 0，<span class="math inline">\(x[n]\)</span> 中 n 的取值范围是 -1 ~ 2</p><ol type="1"><li><p>确定 <span class="math inline">\(x[n] * h[n]\)</span>的左右取值边界：</p><ul><li><p>卷积左边界 = <span class="math inline">\(x[n]\)</span> 的左边界 +<span class="math inline">\(h[n]\)</span> 的左边界 = -2 + -1 =-3</p></li><li><p>卷积右边界 = <span class="math inline">\(x[n]\)</span> 的右边界 +<span class="math inline">\(h[n]\)</span> 的右边界 = 0 + 2 = 2</p></li></ul></li></ol><blockquote><p><strong>注意</strong>：<span class="math inline">\(x[n]\)</span>取值长度为 <span class="math inline">\(N_1\)</span>，<span class="math inline">\(h[n]\)</span> 取值长度为 <span class="math inline">\(N_2\)</span>，则卷积结果长度为 <span class="math inline">\(N_1 + N_2 - 1\)</span></p></blockquote><ol start="2" type="1"><li><p>列表法求解卷积结果：将输入信号 <span class="math inline">\(x[n]\)</span> 的各取值依次与每一个 <span class="math inline">\(h[n]\)</span>的取值<strong>相乘</strong>，并依次<u><strong>右移一个单位</strong></u><span class="math display">\[\begin{vmatrix}h[n] &amp; h[-2] &amp; h[-1] &amp; h[0]  \\x[-1] &amp; x[-1] * h[-2] &amp; x[-1] * h[-1] &amp; x[-1] * h[0]  \\x[0] &amp; &amp; x[0] * h[-2] &amp; x[0] * h[-1] &amp; x[0] * h[0]  \\x[1] &amp; &amp; &amp; x[1] * h[-2] &amp; x[1] * h[-1] &amp; x[1] *h[0]  \\x[2] &amp; &amp; &amp; &amp; x[2] * h[-2] &amp; x[2] * h[-1] &amp; x[2]* h[0]  \\\text{列求和} &amp; o(-3) &amp; o(-2) &amp; o(-1) &amp; o(0) &amp; o(1)&amp; o(2) \\\end{vmatrix}\]</span></p></li><li><p>表格中<u>各列求和</u>即是输出信号中<u>从左到右</u>的取值，上表中各列的求和即为-3 ~ 2 的值</p></li></ol><blockquote><p><strong>注意</strong>：对于<strong>无穷范围</strong>的离散信号，同样可以使用列表法（无限延伸的表格），<strong>找规律</strong>求解</p></blockquote></li></ul></li><li><p>离散 LTI 卷积公式​⭐​：<span class="math inline">\(x[n] * h[n] =\sum_{k = -\infty}^{+\infty} x[k]h[n-k]\)</span>，以下是证明过程​ <span class="math display">\[  \begin{align}  &amp;\text{由单位脉冲响应的定义可知 } \delta[n] \xrightarrow{LTI} h[n]\\  &amp;\text{由LTI的时不变性可知 } \delta[n-k] \xrightarrow{LTI} h[n-k]\\  &amp;\text{由LTI的齐次性可知 }x[k]\delta[n-k] \xrightarrow{LTI}x[k]h[n-k] \\  &amp;\text{由LTI的叠加性可知 }\sum_{k = -\infty}^{+\infty}x[k]\delta[n-k] \xrightarrow{LTI} \sum_{k = -\infty}^{+\infty}x[k]h[n-k] \\  &amp;\text{由已知推论 }x[n] = \sum_{k = -\infty}^{+\infty} x[k]\delta[n-k]\text{ ，可知 } x[n] \xrightarrow{LTI}\sum_{k=-\infty}^{+\infty} x[k]h[n-k] \\  &amp;\text{由卷积运算的定义，}x[n]*h[n] = \sum_{k=-\infty}^{ +\infty}x[k]h[n-k]\text{ ，证毕。}  \end{align}  \]</span></p><ol type="1"><li><p>确定 <span class="math inline">\(x[n] * h[n]\)</span>的左右取值边界，该步骤与列表法完全一样</p></li><li><p><u><strong>翻转</strong></u> <span class="math inline">\(h[n]\)</span>，再依次<u><strong>平移 <span class="math inline">\(h[-n]\)</span></strong></u> 与 <span class="math inline">\(x[n]\)</span>逐元<u><strong>相乘</strong></u>再<u><strong>求和</strong></u>（<span class="math inline">\(h[n]\)</span> 翻转前是 <span class="math inline">\(h[-2] \, h[-1] \, h[0]\)</span>）</p><ol type="1"><li><p>将 <span class="math inline">\(x[-1]*h[-2]\)</span>填入卷积结果的<u>第一个位置</u>： <span class="math display">\[\begin{align}&amp;x[-1] \,\,\,x[0] \,\,\, x[1] \,\,\, x[2] \\h[0] \,\,\, h[-1] \,\,\, &amp;h[-2] \\\end{align}\]</span></p></li><li><p>将 <span class="math inline">\(h[-n]\)</span> 右移一个单位，并将<span class="math inline">\(x[-1] * h[-1] + x[0] * h[-2]\)</span>填入卷积结果的<u>第二个位置</u>： <span class="math display">\[\begin{align}&amp;x[-1] \,\,\,x[0] \,\,\, x[1] \,\,\, x[2] \\h[0] \,\,\, &amp;h[-1] \,\,\, h[-2] \\\end{align}\]</span></p></li><li><p>依此类推，直至将 <span class="math inline">\(h[n]\)</span>右移至以下情形，并将 <span class="math inline">\(x[2] * h[0]\)</span>填入卷积结果的<u>最后一个位置</u>： <span class="math display">\[\begin{align}x[-1] \,\,\,x[0] \,\,\, x[1] \,\,\, &amp;x[2] \\&amp;h[0] \,\,\, h[-1] \,\,\, h[-2] \\\end{align}\]</span></p></li></ol></li></ol><blockquote><p><strong>注意</strong>：离散 LTI卷积公式要求"翻转谁"、就"平移谁"，如上例中翻转"翻转 <span class="math inline">\(h[n]\)</span>"、就"平移 <span class="math inline">\(h[-n]\)</span>"</p></blockquote></li></ul><hr><h3 id="三连续-lti-卷积">三、连续 LTI 卷积</h3><ul><li><p>几个重要函数：</p><ul><li>无限窄方波函数：记作 <span class="math inline">\(\delta_{\Delta}(t)\)</span>，表示时间宽度为 0 ~<span class="math inline">\(\Delta\)</span>，高度为 <span class="math inline">\(\dfrac{1}{\Delta}\)</span> 的一小段方波（面积 =1）</li><li>冲激函数：<span class="math inline">\(\delta(t) = \lim_{\Delta\rightarrow 0} \delta_{\Delta}(t)\)</span>，即无限窄方波函数的<strong>极限</strong></li><li>冲激响应：<span class="math inline">\(x(t) \xrightarrow{LTI}h(t)\)</span>，其中 <span class="math inline">\(h(t) = \lim_{\Delta\rightarrow 0} h_{\Delta}(t)\)</span></li></ul></li><li><p>连续 LTI 卷积公式⭐：<span class="math inline">\(x(t) * h(t) =\int_{-\infty}^{+\infty}x(\tau)h(t-\tau)d\tau\)</span>，证明过程如下：<span class="math display">\[\begin{align}&amp;\text{由冲激响应定义可知 } \delta_{\Delta}(t) \xrightarrow{LTI}h_{\Delta}(t) \\&amp;\text{由LTI的时不变性可知 } \delta_{\Delta}(t-k\Delta)\xrightarrow{LTI} h_{\Delta}(t - k\Delta) \\&amp;\text{由LTI的齐次性可知 } x(k\Delta) \delta_{\Delta}(t - k\Delta)\Delta \xrightarrow{LTI} x(k\Delta)h_{\Delta}(t - k\Delta)\Delta \\&amp;\text{由LTI的叠加性可知 } \sum_{k = -\infty}^{+\infty}x(k\Delta)\delta_{\Delta}(t - k\Delta)\Delta \xrightarrow{LTI} \sum_{k =-\infty}^{+\infty}x(k\Delta)h_{\Delta}(t - k\Delta)\Delta \\&amp;\text{由已知推论 } x(t) = \lim_{\Delta \rightarrow 0} x_{\Delta}(t)= \lim_{\Delta \rightarrow 0} \sum_{k =-\infty}^{+\infty}x(k\Delta)\delta_{\Delta}(t - k\Delta)\Delta \text{可知，}x(t) \xrightarrow{LTI} \lim_{\Delta \rightarrow 0} \sum_{k =-\infty}^{+\infty}x(k\Delta)h_{\Delta}(t - k\Delta)\Delta \\&amp;\text{由冲激响应的极限定义可知 } x(t) \xrightarrow{LTI}\lim_{\Delta \rightarrow 0} \sum_{k = -\infty}^{+\infty}x(k\Delta)h(t -k\Delta)\Delta = \int_{-\infty}^{+\infty} x(\tau)h(t-\tau)d\tau \text{，证毕。}\end{align}\]</span></p></li><li><p><span class="math inline">\(\delta(t)\)</span> 函数的 5个性质：</p><ul><li><p><span class="math inline">\(\int_{-\infty}^{+\infty} \delta(t) dt= 1\)</span> = (<span class="math inline">\(\int_{-\infty}^{+\infty}[\lim_{\Delta \rightarrow 0} \delta_{\Delta}(t)]dt = \lim_{\Delta\rightarrow 0} \int_{-\infty}^{+\infty} \delta_{\Delta}(t) dt =\lim_{\Delta \rightarrow 0} 1\)</span>)，即 <span class="math inline">\(\delta(t)\)</span> 在 <span class="math inline">\(\mathbb{R}\)</span> 上的积分为 1</p></li><li><p><span class="math inline">\(\int_{-\infty}^{+\infty} x(t)\delta(t) dt = x(0)\)</span>，证明如下： <span class="math display">\[\begin{align}&amp; \int_{-\infty}^{+\infty} x(t) \delta(t) dt \\=&amp; \int_{-\infty}^{+\infty} x(t) (\lim_{\Delta \rightarrow 0}\delta_{\Delta}(t)) dt \\=&amp; \lim_{\Delta \rightarrow 0} \int_{0}^{\Delta} x(t)\dfrac{1}{\Delta} dt = \lim_{\Delta \rightarrow 0} \dfrac{1}{\Delta}\int_{0}^{\Delta}x(t)dt \text{ （该积分仅在0到}\Delta\text{上有取值）}\\&amp; \text{由积分中值定理，} \lim_{\Delta \rightarrow 0}\dfrac{1}{\Delta} \int_{0}^{\Delta}x(t)dt = \lim_{\Delta \rightarrow 0}\dfrac{1}{\Delta} x(\xi) \Delta = \lim_{\Delta \rightarrow 0} x(\xi) =x(0) \text{ ，证毕。}\end{align}\]</span></p><blockquote><p><strong>注意</strong>：性质2是性质1的特例，令 性质2 中的 x(t)=1即可得到性质1</p></blockquote></li><li><p><span class="math inline">\(x(t) \delta(t) = x(0)\delta(t)\)</span>，证明如下： <span class="math display">\[\begin{align}&amp;\text{Lebesgue 对函数 }f_1(x) \text{和} f_2(x) \text{相等的定义：对}\textbf{任意函数 }y(t)\text{有}\int_{-\infty}^{+\infty}y(t)f_1(t) dt = \int_{-\infty}^{+\infty}y(t)f_2(t) dt \\&amp;\text{上式左侧}\Rightarrow \int_{-\infty}^{+\infty} y(t)[x(t)\delta(t)]dt = \int_{-\infty}^{+\infty}[y(t)x(t)]\delta(t)dt \text{，由性质2可知 } \int_{-\infty}^{+\infty} [y(t)x(t)]\delta(t) dt =y(0)x(0) \\&amp;\text{上式右侧}\Rightarrow \int_{-\infty}^{+\infty}y(t)[x(0)\delta(t) ] dt = \int_{-\infty}^{+\infty} [y(t)x(0)]\delta(t)dt \text{ ，由性质2可知 } \int_{-\infty}^{+\infty} [y(t)x(0)]\delta(t)dt = x(0)y(0) \\&amp;\text{由 }\int_{-\infty}^{+\infty} y(t) [x(t)\delta(t)]dt =\int_{-\infty}^{+\infty} y(t)[x(0)\delta(t) ] dt \text{ ，}x(t)\delta(t) = x(0)\delta(t) \text{ ，证毕。}\end{align}\]</span></p><blockquote><p><strong>注意</strong>：该性质的变式为 <span class="math inline">\(x(t) \delta(t - t_0) = x(t_0)\delta(t-t_0)\)</span></p></blockquote></li><li><p><span class="math inline">\(\delta(at) =\dfrac{1}{|a|}\delta(t)\)</span>（<span class="math inline">\(a \ne0\)</span>），证明如下： <span class="math display">\[\begin{align}&amp;\text{上式右侧} \Rightarrow \int_{-\infty}^{+\infty} \dfrac{1}{|a|}y(t) \delta(t) dt \text{ ，由性质3可知 } \int_{-\infty}^{+\infty}\dfrac{1}{|a|} y(t) \delta(t) dt = \dfrac{1}{|a|}y(0) \\&amp;\text{右侧证明类似，注意讨论a的正负} \\&amp;\text{由 } \int_{-\infty}^{+\infty} y(t) \delta(at)dt =\int_{-\infty}^{+\infty} \dfrac{1}{|a|} y(t) \delta(t) dt \text{，}\delta(at) = \dfrac{1}{|a|}\delta(t) \text{ ，证毕。}\end{align}\]</span></p><blockquote><p><strong>注意</strong>：该性质的变式为 <span class="math inline">\(\delta(at + b) = \dfrac{1}{|a|}\delta(t +\dfrac{b}{a})\)</span></p></blockquote></li><li><p><span class="math inline">\(\delta(f(t)) =\sum_{\forall{t_0}\text{, }f(t_0)=0}\dfrac{1}{|f&#39;(t_0)|}\delta(t-t_0)\)</span>，使用 Lebesgue函数相等定义证明。</p><ul><li>分解 <span class="math inline">\(\delta(\cos(t))\)</span>（例题）：令 <span class="math inline">\(\cos(t_0) = 0\)</span>，解得 <span class="math inline">\(t_0 = k\pi + \dfrac{\pi}{2}\)</span> <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(|\cos&#39;(t_0)| = |-\sin(t_0)| = 1\)</span><br>故 <span class="math inline">\(\delta(\cos(t)) = \sum_{k =-\infty}^{k=+\infty} 1 * \delta(t-k\pi-\dfrac{\pi}{2})\)</span>（<span class="math inline">\(k \in \mathbb{Z}\)</span>）</li></ul><blockquote><p><strong>注意</strong>：该性质是性质 4 的推广，取 性质 5 中的 <span class="math inline">\(f(t) = at\)</span> 即可</p></blockquote></li></ul></li></ul><hr><h3 id="四卷积的性质">四、卷积的性质</h3><ul><li>什么是"卷积"（简单理解）："卷"指对响应函数的翻转操作，"积"指 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(h\)</span> 的乘积操作<ol type="1"><li><strong>翻转</strong>：对响应函数的 对称翻转 操作</li><li>平移：对翻转后的函数进行 平移 操作</li><li><strong>乘积</strong>：将平移后的函数和响应函数进行乘积</li><li>求和：对乘积式进行求和（或积分）</li></ol></li><li>交换律：连续型有 <span class="math inline">\(x(t) * h(t) = h(t) *x(t)\)</span>；离散型有 <span class="math inline">\(x[n] * h[n] = h[n] *x[n]\)</span></li><li>结合律：连续型有 <span class="math inline">\([x(t) * h_1(t)] *h_2[t] = [x(t) * h_2(t)] * h_1(t)\)</span>；离散型同理</li><li>分配律：连续型有 <span class="math inline">\(x(t) * [h_1(t) +h_2(t)] = x(t) * h_1(t) + x(t) * h_2(t)\)</span>；离散型同理</li></ul><hr><h3 id="五lti-系统的性质">五、LTI 系统的性质</h3><ul><li><p>LTI 系统<strong>稳定</strong> <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(\int_{-\infty}^{+\infty} |h(t)| dt &lt;+\infty\)</span>，对于离散型有 <span class="math inline">\(\sum_{k =-\infty}^{+\infty} |h[n]| &lt; +\infty\)</span>，连续型的证明如下：<span class="math display">\[\begin{align}&amp;\text{先证明必要性：设 }x(t) \text{ 是有界的，则有 }|x(t)| \le M \\&amp;\text{则输出 }y(t) \text{ 也是有界的，即 } |y(t)| = |x(t) * h(t)| =|\int_{-\infty}^{+\infty}h(\tau)x(t-\tau)d\tau| \le\int_{-\infty}^{+\infty}|x(t-\tau)||h(\tau)| d\tau \le M\int_{-\infty}^{+\infty} |h(\tau)| d\tau \\&amp;\text{由 }\int_{-\infty}^{+\infty} |h(t)| dt \text{ 有界可知，}|y(t)| \text{ 有界，即LTI是稳定的。} \\ \\&amp;\text{再证明充分性：设LTI稳定，则对于有界的一个信号 }x(t)\text{，有 }|y(t)| = |x(t) * h(t)| \le +\infty \\&amp;\text{不妨设当 }h(-t) \ge 0 \text{ 时 }x(t) = +1 \text{，当 }h(-t)&lt; 0 \text{ 时 }x(t) = -1。\\&amp;\text{则 }y(0) = \int_{-\infty}^{+\infty} x(\tau)h(0-\tau)d\tau =\int_{-\infty}^{+\infty}|h(-\tau)|d\tau &lt; +\infty \text{ ，证毕。}\end{align}\]</span></p></li><li><p>LTI 系统<strong>因果</strong> <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(h(t) = 0\)</span>（<span class="math inline">\(t&lt; 0\)</span>），对于离散型有 <span class="math inline">\(h[n] =0\)</span>（<span class="math inline">\(n &lt;0\)</span>），连续型的证明如下： <span class="math display">\[\begin{align}&amp;t_0\text{ 时刻输出信号 }y(t_0) = x(t_0) * h(t) =\int_{-\infty}^{+\infty}x(\tau)h(t_0 - \tau)d\tau \text{ ，由因果性}y(t_0)\text{ 仅与 }\tau &lt; t_0 \text{ 的 }x(\tau) \text{ 相关。}  \\&amp;y(t_0)\text{ 仅与 }t_0 \text{ 之前的 }x\text{ 的取值有关 }\Leftrightarrow h(t_0 - \tau) \text{ 在 }t_0 &lt; \tau \text{时（未来时）取 }0 \Leftrightarrow t &lt; 0 \text{ 时 } h(t) = 0 \text{，证毕。}\end{align}\]</span></p></li></ul><blockquote><p><strong>注意</strong>：以上两个性质仅对 <strong>LTI</strong>系统成立</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>signal and system</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>『signal and system-1』overview</title>
    <link href="/2024/06/28/signal_and_system/about-signal/"/>
    <url>/2024/06/28/signal_and_system/about-signal/</url>
    
    <content type="html"><![CDATA[<h2 id="信号与系统">信号与系统</h2><h3 id="一信号是什么">一、信号是什么</h3><ul><li>信号是表达信息的符号，包含一维信号（传递声音信息）、二维信号（传递图像信息）等等。</li></ul><hr><h3 id="二信号的分类">二、信号的分类</h3><ul><li><p>连续时间信号：自变量<strong>连续可变</strong>的信号，用 t表示连续时间变量，记作 x(t)</p></li><li><p>离散时间信号：自变量仅取在一组<strong>离散值</strong>上，用 n表示离散时间变量，记作 x[n]</p><blockquote><p><strong>注意</strong>：离散信号用方括号 [ . ] 表示，连续信号用圆括号( . ) 表示</p></blockquote></li><li><p>周期信号：信号随时间变量 t 或 n变化，具有<strong>重复性</strong></p><ul><li>连续周期信号：存在一个正值 T，对于全部连续 t 满足 x(t) = x(t +<strong>T</strong>)，并记最小正周期为<strong>基波周期 <span class="math inline">\(T_0\)</span></strong></li><li>离散周期信号：存在一个正值 T，对于全部离散 n 满足 x[n] = x[n +<strong>N</strong>]，并记最小正周期为<strong>基波周期<span class="math inline">\(N_0\)</span></strong></li></ul></li><li><p>奇信号：信号关于<u>原点</u>对称，满足 x(t) = -x(-t)，或 x[n] =-x[-n]</p></li><li><p>偶信号：信号关于<u>坐标纵轴</u>对称，满足 x(t) = x(-t)，或 x[n] =x[-n]</p><blockquote><p><strong>注意</strong>：任何信号都能<strong>被唯一</strong>地分解为两个信号之和，满足一个是<strong>奇信号</strong>，另一个是<strong>偶信号</strong><br>设 x(t) 是任意连续时间信号，则 <span class="math inline">\(\text{x(t)} = \dfrac{1}{2}\text{[x(t) + x(-t)]} +\dfrac{1}{2}[\text{x(t)} -\text{x(-t)}]\)</span>，前者是偶信号，后者是奇信号</p></blockquote></li></ul><hr><h3 id="三信号的能量和功率">三、信号的能量和功率</h3><ul><li><p>一段<u>有限时间</u>内的信号总能量和平均功率：设时间段为 <span class="math inline">\(n_1 \le n \le n_2\)</span></p><ul><li><p>离散信号的总能量：<span class="math inline">\(E = \sum_{n =n_1}^{n=n_2} |{x[n]}|^2\)</span>，即对信号模长的平方求和</p></li><li><p>离散信号的平均功率：<span class="math inline">\(P = \dfrac{1}{n_2- n_1 + 1}\sum_{n=n_1}^{n=n_2}|x[n]|^2\)</span>，即对能量计算平均值</p><hr></li><li><p>连续信号的总能量：<span class="math inline">\(E =\int_{t_0}^{t_1} |x(t)|^2 dt\)</span>，即对信号模长的平方求积分</p></li><li><p>连续信号的平均功率：<span class="math inline">\(P = \dfrac{1}{t_1- t_0} \int_{t_0}^{t_1} |x(t)|^2dt\)</span>，即对能量计算平均值</p></li></ul><blockquote><p><strong>注意</strong>：有限时间可以推广到无限时间段，令 <span class="math inline">\(n_1 \rightarrow - \infty\)</span>，或 <span class="math inline">\(n_2 \rightarrow \infty\)</span> 即可</p></blockquote></li><li><p>单位阶跃信号：记作 u(t)，小于 0 时取 0，大于 0 时取 1，u(0)可取<strong>任意值</strong> <span class="math display">\[u(t) = \begin{cases}1 &amp; \text{if } t &gt; 0 \\0 &amp; \text{if } t &lt; 0 \\\text{any} &amp; \text{if } t = 0\\\end{cases}\]</span></p></li><li><p>冲激信号：记作 <span class="math inline">\(\delta(t)\)</span>，用于表示一种发生<strong>时间极短</strong>、但物理量<strong>取值极大</strong>的物理现象（雷电、冲击力等）<span class="math display">\[\begin{align}\delta(t) =\begin{cases}+\infty &amp; \text{if } t = 0 \\0 &amp; \text{other} \\\end{cases} \\ \text{   同时满足}\int_{-\infty}^{+\infty} \delta(t) dt = 1\end{align}\]</span></p><blockquote><p><strong>注意</strong>：以上两个函数满足关系：<span class="math inline">\(\delta(t) =\dfrac{du(t)}{dt}\)</span>，即冲激信号是单位阶跃信号的导函数（t = 0时冲到最高）</p></blockquote></li><li><p>抽样函数：记作 Sa(t)，是一个偶函数，t = 0 处取<u><strong>极限值1</strong></u> <span class="math display">\[Sa(t) =\begin{cases}1 &amp; \text{if } t = 0 \\\dfrac{\sin(t)}{t} &amp; \text{other}\end{cases}\]</span></p><figure style="text-align:center"><p><img src="/2024/06/28/signal_and_system/about-signal/sa.jpg" width="75%"></p><figcaption><p>抽样函数图像</p></figcaption></figure><blockquote><p><strong>注意</strong>：<span class="math inline">\(\int_{-\infty}^{+\infty} \dfrac{\sin{(t)}}{t} dt=\int_{-\infty}^{+\infty} \dfrac{\sin(\omega t)}{t} =\pi\)</span>（<span class="math inline">\(\omega &gt; 0\)</span>），<span class="math inline">\(\int_{0}^{+\infty} \dfrac{\sin(t)}{t} dt =\int_{-\infty}^0 \dfrac{\sin(\omega t)}{t} dt =\dfrac{\pi}{2}\)</span>（<span class="math inline">\(\omega &gt;0\)</span>）</p></blockquote></li><li><p>关于以上抽样函数结论的证明：偶函数性质 +<strong>欧拉公式</strong>的应用 <span class="math display">\[\begin{align}&amp;先证明 \int_{0}^{+\infty} \frac{\sin(t)}{t} dt = \frac{\pi}{2}\text{：} \\&amp;\text{设 } I(a) = \int_{0}^{+\infty} \frac{\sin(t)}{t} e^{-at} dt\text{ ，则 } \frac{dI(a)}{da} = -\int_{0}^{+\infty} {\sin(t)} e^{-at}dt \\&amp;\text{由 } \sin(t) = \frac{e^{it} -e^{-it}}{2i}，可将上式转化为\text{：} \\&amp;-\frac{1}{2i} \int_{0}^{+\infty} e^{-(a + i)t} - e^{-(a-i)t} dt =\frac{1}{2i} [\frac{1}{a+i} - \frac{1}{a-i}] = -\frac{1}{a^2 + 1} \\&amp;\text{即 } \frac{dI(a)}{da} = -\frac{1}{a^2 + 1}\text{，查积分表可得 } I(a) = -\arctan(a) + C \\&amp;\text{令 } a \rightarrow +\infty \text{，可得 } I(a) = 0 =-\frac{\pi}{2} + C\text{ ，解得 } C = \frac{\pi}{2} \\&amp;\text{最后令 }a = 0\text{，解得原积分 = } \frac{\pi}{2}，证毕。\end{align}\]</span></p></li><li><p>单位阶跃序列：记作u[n]，可理解为<strong>离散形式</strong>的单位阶跃信号；注意 n = 0 时取1（而非连续形式的任意值） <span class="math display">\[u[n] = \begin{cases}0 &amp; \text{if } n &lt; 0 \\1 &amp; \text{other} \\\end{cases}\]</span></p></li><li><p>单位脉冲序列：记作 <span class="math inline">\(\delta\)</span>[n]，可理解为<strong>离散形式</strong>的冲激信号；注意n = 0 时取 <span class="math inline">\(\delta\)</span>[n] =1（而非连续形式的正无穷） <span class="math display">\[\delta[n] =\begin{cases}1 &amp; \text{if } n = 0 \\0 &amp;  \text{other}\end{cases}\]</span></p></li></ul><hr><h3 id="四自变量变换">四、自变量变换</h3><ul><li><p>对于连续信号 x (t)，求解任意形如 x(at + b) 的连续信号：</p><ol type="1"><li>化成标准型：<span class="math inline">\(x(t) \rightarrow x(a(t +\dfrac{b}{a}))\)</span>，即把变量 t 前的<strong>系数提成 1</strong></li><li>系数为负则翻转：若 a &lt; 0，则需要将 x(t) 的图像先沿<strong>纵轴</strong> 对称翻转</li><li>系数 &gt; 1 压缩，系数 &lt; 1拉伸：将（对称翻转过的）每个信号点横坐标 t 平移到 <span class="math inline">\(\dfrac{t}{|a|}\)</span> 处</li><li>加号左移，减号右移：若 b &gt; 0，图像总体左移 b 个单位；若 b &lt;0，图像总体右移 |b| 个单位</li></ol></li><li><p>有关自变量变换的重要结论：<span class="math inline">\(x[n] =\sum_{k = -\infty}^{+\infty} x[k] \text{ }\delta[n-k]\)</span>，其中<span class="math inline">\(\delta[n-k]\)</span> 表示仅在 n = k处取值为1的信号</p><p>例：根据自变量变换的规律求解 u[n + p] - u[n - q] 的图像（p, q &gt;0）；根据 x(at + b) 的图像反推 x(t) 的图像（令 u = at + b）</p></li></ul><hr><h3 id="五线性系统">五、线性系统</h3><ul><li><p>线性系统的定义：<strong>同时满足以下两个性质</strong>的系统称作"线性系统"</p><ul><li>齐次性：设系统 <span class="math inline">\(x(t) \rightarrowy(t)\)</span>，则对任意 <span class="math inline">\(a \in\mathbb{R}\)</span> ，都有 <span class="math inline">\(ax(t) \rightarroway(t)\)</span></li><li>叠加性：设系统 <span class="math inline">\(x_1(t) \rightarrowy_1(t)\)</span>、<span class="math inline">\(x_2(t) \rightarrowy_2(t)\)</span>，则必有 <span class="math inline">\(x_1(t) + x_2(t)\rightarrow y_1(t) + y_2(t)\)</span></li></ul><blockquote><p><strong>注意</strong>：对于离散信号系统，只需要把 (t) 替换成 [n]即可</p></blockquote></li><li><p>常见的线性系统：证明一个系统是线性系统，需<strong>同时验证</strong>"齐次性"和"叠加性"；证明不是线性系统，只需给出反例</p><ul><li>缩放器：连续情形有 <span class="math inline">\(x(t) \rightarrowax(t)\)</span>；离散情形有 <span class="math inline">\(x[n] \rightarrowax[n]\)</span></li><li>微分器：连续情形有 <span class="math inline">\(x(t) \rightarrow\dfrac{dx(t)}{dt}\)</span>；离散情形有 <span class="math inline">\(x[n]\rightarrow x[n] - x[n-1]\)</span></li><li>积分器：连续情形有 <span class="math inline">\(x(t) \rightarrow\int_{-\infty}^{t} x(\tau) d\tau\)</span>；离散情形有 <span class="math inline">\(x[n] \rightarrow \sum_{k = -\infty}^{n}x[k]\)</span></li></ul><blockquote><p><strong>注意</strong>：系统的<strong>每一项都含信号x</strong>，且每一项的 x 都是<strong>一次幂</strong> <span class="math inline">\(\Rightarrow\)</span> 该系统是线性系统，</p></blockquote></li></ul><hr><h3 id="六时不变系统因果系统无记忆系统等">六、时不变系统、因果系统、无记忆系统等</h3><ul><li><p>时不变系统：设系统 <span class="math inline">\(x(t) \rightarrowy(t)\)</span>，对任意 <span class="math inline">\(t_0 \in\mathbb{R}\)</span>，都有 <span class="math inline">\(x(t-t_0)\rightarrowy(t-t_0)\)</span>，即系统<strong>输出不随时间改变</strong></p><blockquote><p><strong>注意</strong>：t 只存在于信号 x 的括号内，且 t总以<strong>单独形式</strong>存在（不带系数、不是幂次等）<span class="math inline">\(\Rightarrow\)</span> 该系统是时不变系统</p></blockquote></li><li><p>因果系统：设系统 <span class="math inline">\(x(t) \rightarrowy(t)\)</span>，输出 <span class="math inline">\(y(t)\)</span> 始终在输入<span class="math inline">\(x(t)\)</span>之后发生，即系统的输出只与<u>当前</u>和<u>过去</u>的输入有关</p><ul><li>微分器 <span class="math inline">\(y(t) = \dfrac{dx(t)}{dx}\)</span>既可以看作是因果的（左极限），也可以看作非因果的（右极限）</li></ul><blockquote><p><strong>注意</strong>：信号 x 括号内的关于 t 的表达式 <strong>恒<span class="math inline">\(\le\)</span> t</strong> <span class="math inline">\(\Rightarrow\)</span>该系统是因果系统（输出总是落后于输入）</p></blockquote></li><li><p>无记忆系统：设系统 <span class="math inline">\(x(t) \rightarrowy(t)\)</span>，<span class="math inline">\(y(t)\)</span>的值<strong>仅仅只依赖</strong>于 <span class="math inline">\(x(t)\)</span> 的值（而不依赖于 x(t-1) 等）</p><ul><li>微分器 <span class="math inline">\(y(t) = \dfrac{dx(t)}{dx}\)</span>其实是<strong>有记忆</strong>的，因为导数的极限定义是 <span class="math inline">\(\lim_{\Delta t \rightarrow 0} \dfrac{x(t + \Deltat) - x(t)}{\Delta t}\)</span></li></ul><blockquote><p><strong>注意</strong>：信号 x 与 y 括号内的值完全一样 <span class="math inline">\(\Rightarrow\)</span>该系统是无记忆的（仅依赖于输入信号<span class="math inline">\(x(t)\)</span>）</p><p>一个系统是<strong>无记忆</strong>的 <span class="math inline">\(\Rightarrow\)</span>该系统是<strong>因果</strong>的（无记忆 是 因果 的特殊情况）</p></blockquote></li><li><p>可逆系统：设系统 <span class="math inline">\(x(t) \rightarrowy(t)\)</span>，<span class="math inline">\(x(t)\)</span>能<strong>唯一</strong>地写成 <span class="math inline">\(y(t)\)</span>的形式，即可以用输出信号唯一地表示输入信号</p><ul><li><p><span class="math inline">\(x(t) \rightarrow y = x^2(t)\)</span>是不可逆的，因为 <span class="math inline">\(x(t) = \pm\sqrt{y(t)}\)</span>，<span class="math inline">\(x(t)\)</span> 有两种被<span class="math inline">\(y(t)\)</span> 表示的方法</p></li><li><p><span class="math inline">\(x(t) \rightarrow y(t) =\int_{-\infty}^{t} x(\tau) d\tau\)</span> 是可逆的，因为 <span class="math inline">\(x(t) =\dfrac{dy(t)}{dt}\)</span>，表示方法唯一</p><blockquote><p><strong>注意</strong>：积分器（累加器）是可逆的，微分器是不可逆的（积分常数C 可取任意值）</p></blockquote></li></ul></li><li><p>稳定系统：设系统 <span class="math inline">\(x(t) \rightarrowy(t)\)</span>，若 <span class="math inline">\(x(t)\)</span> 有界则 <span class="math inline">\(y(t)\)</span>有界，说明该系统稳定，即<u>输入有界</u>则<u>输出有界</u></p><ul><li><p><span class="math inline">\(y(t) = \dfrac{dx(t)}{dt}\)</span>是不稳定的，比如取 <span class="math inline">\(x(t) =u(t)\)</span>（有界），<span class="math inline">\(y(t)\)</span> 在 t =0 处 <span class="math inline">\(\rightarrow +\infty\)</span>没有界</p></li><li><p><span class="math inline">\(y(t) = \int_{-\infty}^{t} x(\tau)d\tau\)</span> 是不稳定的，比如取 <span class="math inline">\(x(t) =1\)</span>（有界），<span class="math inline">\(y(t) \rightarrow+\infty\)</span> 没有界</p><hr></li><li><p><span class="math inline">\(y[n] = x[n] - x[n - 1]\)</span>是稳定的，设 <span class="math inline">\(|x[n]| \le M\)</span>，则 <span class="math inline">\(|y[n]| \le 2M\)</span>（<span class="math inline">\(M &gt; 0\)</span>），即离散信号作差必有界</p></li><li><p><span class="math inline">\(y[n] = \sum_{k = -\infty}^{n}x[k]\)</span> 是不稳定的，证明与连续情形的积分器相同</p></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>signal and system</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>『computer network-5』application layer</title>
    <link href="/2024/06/01/computer_network/application-layer/"/>
    <url>/2024/06/01/computer_network/application-layer/</url>
    
    <content type="html"><![CDATA[<h2 id="应用层">应用层</h2><h3 id="一套接字编程接口">一、套接字编程接口</h3><ul><li><p>套接字socket：<u>应用进程</u> 和<u>传输层协议</u>间的接口，AP为获得网络通信服务<strong>与OS进行交互</strong>的机制<br><strong>注意</strong>：套接字是最常用的<strong>应用层编程接口</strong>，应用程序通过socket接入网络</p></li><li><p>基于TCP系统的系统调用接口：</p><ol type="1"><li>连接建立阶段：<ol type="1"><li>bind：客户端和服务器分别将<u>端口号</u> +<u>IP地址</u>绑定在socket上</li><li>listen：服务器调用listen将套接字设置为<strong>被动方式</strong>，随时接受客户请求</li><li>accept：服务器调用accept提取客户请求，并为每个新连接请求建立<strong>新的套接字</strong>返回给客户；通信结束后，新的套接字关闭</li><li>connect：客户端调用connect与远程服务器<strong>建立连接</strong>（主动打开）</li></ol></li><li>数据传送阶段：<ul><li>send：客户端使用send发送请求；服务器使用send发送回答</li><li>recv：服务器使用recv接收请求；客户端使用recv接收发送请求后的回答</li></ul></li><li>连接释放阶段：调用close释放连接，撤销套接字</li></ol></li><li><p>基于UDP系统的系统调用接口：<strong>无需建立连接</strong>，没有connect与listen+accept</p><p><img src="/2024/06/01/computer_network/application-layer/UDP_socket.png" width="50%"><img src="/2024/06/01/computer_network/application-layer/TCP_socket.png" width="50%"></p></li><li><p>套接字描述符：AP发出socket系统调用后，OS为其分配<u><strong>网络通信</strong>所需系统资源</u>，并将这些资源用套接字描述符表示并<strong>返回</strong>给AP<br><strong>注意</strong>：几乎所有网络系统调用都使用socketdescriptor作为第一个参数，用于识别完成网络请求所需的各种资源（CPU、带宽等）</p><p><img src="/2024/06/01/computer_network/application-layer/套接字描述符.png" width="80%"></p></li></ul><hr><h3 id="二域名系统-dns">二、域名系统 DNS</h3><ul><li><p>域名系统：Internet使用的<strong>命名系统</strong>，采用<u>层次结构的<strong>命名树</strong></u>作为主机名字（IP地址不易记忆），属于<strong>分布式系统</strong></p><ul><li>域名服务器程序：实现 域名 <span class="math inline">\(\rightarrow\)</span> IP地址的解析，其运行在域名服务器上</li><li>DNS基于<strong>UDP</strong>协议实现：域名解析过程如下：<ol type="1"><li>AP调用<strong>域名解析程序</strong>，其成为DNS的一个客户</li><li>AP将待解析的域名放在<u>DNS请求报文</u>中，以<strong>UDP</strong>用户数据报的形式发给<strong>本地域名服务器</strong></li><li>本地域名服务器查找域名，并把对应的IP地址放在<u>回答报文</u>中返回给AP</li></ol></li></ul></li><li><p>Internet的域名结构：采用<strong>层次树状结构</strong>命名，不区分大小写，且域名长度<span class="math inline">\(\le\)</span> 255字符</p><ul><li><p>顶级域名TLD：国家顶级域名(.cn, .us, ...) + 通用顶级域名(.com,.edu, .gov, org, ...) <img src="/2024/06/01/computer_network/application-layer/域名空间.png" width="70%"></p></li><li><p>域名服务器：主要分为以下4类：</p><ul><li>根域名服务器：存有其所知的所有<u><strong>顶级域名服务器</strong>的域名+ IP地址</u><br><strong>注意</strong>：根域名服务器<u>一般</u>并不直接将待查询域名转换为IP，而是告诉本地域名服务器<strong>下一步</strong>要查哪个顶级域名服务器</li><li>顶级域名服务器：管理在该顶级域名服务器注册的所有<strong>二级域名</strong></li><li>权限域名服务器：负责<strong>一个区</strong>的域名服务器</li><li>本地域名服务器：又称默认域名服务器</li></ul><p><strong>注意</strong>：域名服务器定期把数据<u>复制到多个域名服务器</u>保存，其中一个为<strong>主域名服务器</strong>、其余为<strong>辅助域名服务器</strong></p></li><li><p>域名查询：分为递归查询 + 迭代查询</p><ul><li>主机 向 本地域名服务器 查询采用<strong>递归查询</strong>：<ul><li>本地域名不知道待查询域名的IP，就向其它服务器发送请求报文，最终返回待查询IP地址（<u>无需主机自己查询</u>）</li></ul></li><li>本地域名服务器 向 根域名服务器查询采用<strong>迭代查询</strong>：每次迭代需要让<u>本地域名服务器自己去查询</u><ul><li>若<strong>根域名服务器</strong>知道IP地址，直接给出IP地址</li><li>若其不知道IP地址，告诉本地域名服务器后续向哪个域名服务器查询：<ul><li>若<strong>顶级域名服务器</strong>知道IP地址，直接给出IP地址</li><li>若其不知道IP地址，告诉本地域名服务器后续向哪个域名服务器查询：<ul><li><strong>权限域名服务器</strong>给出待查询域名对应的IP地址；本地域名服务器将该IP返回给主机</li></ul></li></ul></li></ul></li></ul><p><strong>注意</strong>：为了提高查询效率，通常使用<strong>高速缓存</strong>存储域名映射；以下8步查询共需要8个UDP用户数据报</p><p><img src="/2024/06/01/computer_network/application-layer/域名查询.png" width="70%"></p></li></ul></li></ul><hr><h3 id="三文件传输协议-ftp">三、文件传输协议 FTP</h3><ul><li><p>FTP的客户/服务器方式：服务器进程由以下2部分组成：</p><ul><li><p>主进程：负责<strong>接收</strong>新的请求，工作步骤如下：</p><ol type="1"><li>打开<strong>熟知端口</strong>(21)，使客户进程能够连接得上</li><li><strong>等待</strong>客户进程发出连接请求</li><li>启动<u>从属进程</u><strong>处理</strong>客户进程发来的请求</li><li>回到<strong>等待状态</strong>，继续接受其它客户进程发来的请求</li></ol></li><li><p>若干从属进程：负责<strong>处理</strong>单个请求，其运行过程中可能会<u>创建其它子进程</u>，请求处理完毕后<u>立即终止</u></p><ul><li>控制连接：整个会话期间一直保持打开，客户端发送的传送请求通过<strong>控制连接</strong>发送给 服务器的控制进程<strong>注意</strong>：控制进程不用于传送文件，仅用于发送控制信息</li><li>数据连接：收到客户发来的文件传输请求后，服务器控制进程<strong>创建数据连接</strong>，负责<u>实际完成文件传送</u>；传送完毕后关闭连接</li></ul><p><img src="/2024/06/01/computer_network/application-layer/ftp.png" width="70%"></p></li></ul></li></ul><hr><h3 id="四万维网-www">四、万维网 WWW</h3><ul><li><p>万维网概述：一个分布式的<strong>超媒体</strong>系统，是<strong>超文本</strong>系统的扩充</p><ul><li>URL：<strong>标识</strong>分布在Internet上的万维网文档</li><li>HTTP：实现万维网上各种超链的<strong>链接</strong></li><li>HTML：存储并表示万维网文档的<strong>方式</strong></li></ul><p><strong>注意</strong>："超文本"指包含指向其它文档的链接的文本；"超媒体"还可包含图形、图像、声音等信息</p></li><li><p>统一资源定位符 URL：对 Internet 上 <u>资源位置</u> 和<u>访问方法</u> 的一种简洁表示</p><ul><li><p>URL一般形式：&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</p><ul><li>协议：指出使用何种<strong>方式</strong>获取万维网文档，如http或ftp</li><li>主机名：万维网文档所存放<strong>主机的域名</strong>（通常以www开头），也可用点分十进制的IP地址代替</li><li>端口：指出端口号，如省略则为<u>协议默认端口号</u>；若不使用默认端口号，则必须写明</li><li>路径：包含若干斜线的较长字符串</li></ul><p><strong>注意</strong>：URL不区分大小写</p></li></ul><hr></li><li><p>超文本传送协议HTTP：面向事务的应用层协议，基于<strong>TCP</strong>协议</p><ul><li><p>HTTP工作原理：</p><ol type="1"><li>Web服务器进程在<strong>熟知端口号80</strong>上监听</li><li>客户需要请求某个页面时，与服务器<u><strong>建立</strong>TCP连接</u>，并传送文件；传送完毕后<u><strong>释放</strong>TCP连接</u></li></ol></li><li><p>HTTP/1.0：每请求一个文档都需要建立一次TCP连接，<strong>非持续连接</strong>，加重服务器负担<img src="/2024/06/01/computer_network/application-layer/HTTP1.0.png" width="60%"></p></li><li><p>HTTP/1.1：使用<strong>持续连接</strong>，发送响应后<u>在一段时间内保持连接</u>，包括非流水线方式+ 流水线方式</p><ul><li>非流水线方式：收到前一个响应<strong>后</strong>才能发送新的请求，每访问一次对象花费一个RTT时间</li><li>流水线方式：收到前一个响应<strong>前</strong>就能发送新的请求，访问所有多项均只需花费一个RTT时间</li></ul></li><li><p>HTTP报文类型：主要包括以下2类：</p><ul><li>请求报文：客户 <span class="math inline">\(\rightarrow\)</span>服务器 请求报文</li><li>响应报文：服务器 <span class="math inline">\(\rightarrow\)</span>客户 回答报文</li></ul><p><strong>注意</strong>：HTTP的两类报文都是<strong>面向文本</strong>的，报文中的字段都是<strong>ASCII码串</strong>，故<u>每个字段长度不固定</u></p></li><li><p>HTTP报文结构：两种报文均由三部分组成：</p><ul><li><p>开始行：<u>区分报文<strong>类型</strong></u>；请求报文中叫做请求行，响应报文中叫做状态行</p><ul><li><p>请求行：&lt;方法&gt; + &lt;URL&gt; +&lt;HTTP版本&gt;；"方法"也是命令，包括OPTION、GET、POST等</p><p><img src="/2024/06/01/computer_network/application-layer/HTTP请求报文格式.png" width="30%"><img src="/2024/06/01/computer_network/application-layer/HTTP请求报文示例.png" width="50%"></p></li><li><p>状态行：&lt;HTTP版本&gt; + &lt;状态码&gt; +&lt;简单短语&gt;；"状态码"都是三位数字，分为以下5类：</p><ul><li>1xx：通知信息，如收到请求 or 正在处理</li><li>2xx：成功，如接收 or 知晓</li><li>3xx：重定向，如要完成请求必须采取进一步行动</li><li>4xx：<u>客户</u>差错，如请求中有错误的语法 or 不能完成</li><li>5xx：<u>服务器</u>差错，如服务器无法完成请求</li></ul><p><img src="/2024/06/01/computer_network/application-layer/HTTP应答报文格式.png" width="30%"><img src="/2024/06/01/computer_network/application-layer/HTTP应答报文示例.png" width="60%"></p></li></ul></li><li><p>首部行：用来说明浏览器 or 服务器 or报文主体的<strong>信息</strong>；每行都有首部字段名 + 对应值</p></li><li><p>实体主体：请求报文中<u>一般不使用</u>该字段；响应报文中也<u>可能没有</u>这个字段</p></li></ul></li></ul><hr></li><li><p>超文本标记语言HTML：制作万维网页面的<strong>标准语言</strong>（不是应用层协议）；HTML文档是文本格式</p><ul><li>标签 tag：HTML用于排版的<strong>命令</strong></li><li>浏览器从服务器读取HTML文档（后缀必须是<u>.html</u>），根据显示器分辨率显示页面</li></ul><hr></li><li><p>安全的HTTP协议（HTTPS）：建立在<strong>SSL</strong>基础上</p><ul><li>熟知端口号：HTTPS为443，而HTTP为80</li><li>安全套接层 SSL：Secure SocketLayer，为TCP协议提供<u>信息加密</u>和<u>完整性</u></li></ul></li></ul><hr><h3 id="五电子邮件">五、电子邮件</h3><ul><li><p>电子邮件系统中的实体：分为以下2类：</p><ul><li>用户代理UA：电子邮件客户端软件，是<u>用户</u>与<u>电子邮件系统</u>的接口，支持撰写、显示、处理、通信</li><li>邮件服务器：用于<u>发送</u>和<u>接收</u>邮件，并向发信人报告传送结果；可以作为客户or 服务器</li></ul><p><img src="/2024/06/01/computer_network/application-layer/电子邮件系统.png"></p></li><li><p>简单邮件传送协议SMTP：用于<strong>发送邮件</strong>的协议；发件方是客户、接收方是服务器</p><ul><li>SMTP通信三阶段：<ol type="1"><li>连接建立：连接在 <u>SMTP客户</u> 和 <u>SMTP服务器</u>之间建立（无中间邮件服务器）</li><li>邮件传送</li><li>连接释放：邮件发送完毕后，SMTP<strong>释放</strong>TCP连接</li></ol></li><li>SMTP局限性：不能传输可执行文件 or 其它二进制对象（图片、音乐等）</li></ul></li><li><p>读取邮件的协议：POP3 和 IMAP</p></li><li><p>电子邮件信息格式：电子邮件分为信封 + 内容；邮件内容分为首部 +主体</p><ul><li>首部字段：其格式包含以下6个字段<ul><li>To：填入若干个<strong>收件人</strong>的e-mail地址</li><li>Subject：邮件<strong>主题</strong>，反映邮件主要内容</li><li>Cc：抄送，表示给某人发送一个<strong>邮件副本</strong></li><li>From：<strong>发件人</strong>的e-mail地址</li><li>Date：发信日期</li><li>Reply-to：对方回信的地址</li></ul></li><li>主体：由用户自由撰写</li></ul></li><li><p>通用互联网邮件扩充MIME：增加邮件主体结构，定义了传送<strong>非ASCII码</strong>的编码规则，改善了SMTP的问题</p><ul><li>MIME思路：<ul><li>继续沿用目前的电子邮件信息格式</li><li>对二进制数据进行<strong>编码</strong>，将其转换为7位的ASCII码</li></ul></li><li>新增的5种头部字段：<ul><li>MIME-Version：MIME<strong>版本号</strong>，一般为1.0</li><li>Content-Type：报文体中的<u><strong>数据类型</strong>和<strong>子类型</strong></u></li><li>Content-Transfer-Encoding：传输时的<strong>编码格式</strong></li><li>Content-ID：邮件唯一的<strong>标识符</strong></li><li>Content-Description：供人阅读的内容<strong>描述字符串</strong>，说明主体是否为图像、音频or 视频</li></ul></li><li>传输编码规则：<ul><li>base64：原二进制数据中每6bit被映射为8bit(ASCII字符)</li><li>quoted-printable：原二进制数据的8bit(1Byte)换算为2个16进制数，并在每个Byte前加"="</li></ul></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>computer network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>『computer network-4』transport layer</title>
    <link href="/2024/04/09/computer_network/transport-layer/"/>
    <url>/2024/04/09/computer_network/transport-layer/</url>
    
    <content type="html"><![CDATA[<h2 id="传输层">传输层</h2><h3 id="一传输层协议概述">一、传输层协议概述</h3><ul><li><p>传输层（应用层）功能：为<u>上面的应用层</u>提供（端到端）通信服务</p><ul><li>实现可靠传输：差错控制 + 顺序控制 + 拥塞控制</li></ul><p><strong>注意</strong>：网络层实现<strong>主机之间</strong>的逻辑通信；传输层实现<strong>应用进程之间</strong>的逻辑通信（<strong>端到端通信</strong>）</p></li><li><p>传输层主要协议：传输控制协议(TCP) + 用户数据报协议(UDP)</p><ul><li>TCP协议：<u><strong>可靠</strong></u>传输协议，典型协议包括HTTP、FTP<ul><li>提供<strong>面向连接</strong>的服务（传输数据前建立连接 +传输结束后释放连接）</li><li>需进行确认、流量控制、计时器、连接管理，<u>处理开销较大</u></li></ul></li><li>UDP协议：<u><strong>不可靠</strong></u>传输协议，典型协议包括DNS、RIP<ul><li>传输时<strong>无需建立连接</strong></li><li>比TCP效率更高，但可能出现数据错误、丢包、顺序错误等问题</li></ul></li></ul></li><li><p>传输层端口：用于为多个应用进程AP提供服务</p><ul><li><p>端口复用：应用层<u><strong>多个</strong>应用进程</u>通过传输层发送数据（向下）</p></li><li><p>端口分用：传输层收到的数据必须<u><strong>交付给指明</strong>的应用进程</u>（向上）</p><hr></li><li><p>端口号：TCP/IP协议使用16位整数作为端口号，用于表示 源端口号 +目的端口号</p><ul><li>熟知端口号（系统端口号）：0 ~ 1023，如 HTTP 服务使用80、FTP服务使用21</li><li>登记端口号：1024 ~49151，提供给<strong>没有熟知端口号的AP</strong>使用；须在IANA<strong>登记</strong>（以防重复）</li><li>客户端口号（短暂端口号）：49152 ~ 65535，供客户进程临时使用</li></ul></li></ul></li></ul><hr><h3 id="二用户数据报协议-udp">二、用户数据报协议 UDP</h3><ul><li><p>UDP概述：<strong>不可靠</strong>传输协议，只在IP数据报服务基础上增加了<u>端口和差错检测</u>，包含以下特点：</p><ul><li>无连接：发送数据前无需建立连接</li><li>尽最大努力交付：不保证可靠交付，同时<u>不使用拥塞控制</u>（很适合多媒体通信）</li><li>支持一对一、一对多、多对一、多对多的交互通信</li><li>首部开销小，仅有8Byte</li></ul></li><li><p>UDP首部格式：共8Byte，包含以下5个字段</p><ul><li>源端口：标注 源端口号（2Byte）</li><li>目的端口：标注 目的端口号（2Byte）<br><strong>注意</strong>：若接收方的<u>目的端口</u>上没有AP接收数据，<u>则会向源主机返回ICMP的"<strong>目的不可达</strong>"报文</u></li><li>长度：UDP数据报长度（2Byte）</li><li>校验和：UDP数据报的校验和（2Byte）</li><li>伪首部：不实际传输，仅在计算校验和时使用（12Byte）</li></ul><p><img src="/2024/04/09/computer_network/transport-layer/UDP数据报.png" width="80%"></p><p><strong>注意</strong>：网络传输一般使用BigEndian，源端口号发送在前</p></li><li><p>计算校验和：计算整个UDP数据报的<strong>二进制反码和</strong>，计算过程类似<u>网络层IP首部校验和</u></p><ul><li>计算校验和前需要添加12Byte的<strong>伪首部</strong></li><li>若UDP数据报长度为奇数字节，先通过<u>零填充</u>将其转化为<strong>偶数字节</strong>再计算</li></ul></li></ul><hr><h3 id="三传输控制协议-tcp">三、传输控制协议 TCP</h3><ul><li><p>TCP概述：<strong>可靠</strong>传输协议，主要包括以下特点：</p><ul><li><p>面向连接：传输前必须建立连接，数据传输完毕后要释放连接</p></li><li><p>点对点连接：每条TCP连接仅能有<strong>两个端点</strong></p></li><li><p>可靠交付服务：无差错、不丢失、不重复、按需到达</p></li><li><p>全双工通信：在一个连接上，通信双方<u>可<strong>同时</strong>向对方传输数据</u></p></li><li><p>面向字节流：AP以<strong>数据块</strong>为单位与TCP交互，而TCP将数据块视为<strong>无结构的<u>字节流</u></strong><br><strong>注意</strong>：TCP可把过长的数据块<strong>划分短一些</strong>再发送，也可<strong>等积累足够多的字节</strong>后再发送</p><hr></li><li><p>TCP对AP一次把多长的报文发送到<u>TCP缓存</u>中是不关心的</p></li><li><p>TCP根据<u>对方给出的<strong>窗口值</strong></u> +<u>当前网路<strong>拥塞程度</strong></u>决定一个报文段应该包含多少字节UDP发送的报文段长度是<u>由AP给出的</u></p></li></ul></li><li><p>TCP的连接：TCP把<strong>连接</strong>看作<u>最基本的抽象</u>；TCP连接是<strong>虚连接</strong>而非真正的物理连接</p><ul><li>套接字：TCP连接的端点，socket ::= (IP地址, 端口号)</li><li>TCP连接<strong>唯一地</strong>由两个端点确定，TCP连接 ::= {(IP1:port1), (IP2: port2)}</li></ul></li></ul><hr><h3 id="四tcp报文段首部">四、TCP报文段首部</h3><ul><li><p>TCP报文的首部格式</p><ul><li>源端口 + 目的端口：各占2Byte</li><li>序号字段：指明本报文段数据<strong>首字节的序号</strong>，占4Byte；TCP连接的数据流中的<u>每个字节都按顺序编号</u></li><li>确认号字段：<u>期望</u>收到对方<u>下一个报文段</u>数据的<strong>首字节序号</strong>，占4Byte</li><li>数据偏移：数据部分相较起始位置的<strong>偏移</strong>（即首部长度），单位为4Byte，占4bit</li><li>保留字段：无意义，占6bit</li><li>紧急URG：值取1表示有<u>紧急数据</u>，应<strong>尽快传送</strong>（紧急数据放在数据的最前面），占1bit</li><li>确认ACK：值取1时<u><strong>确认号字段</strong>有效</u>，占1bit</li><li>推送PSH：值取1时<u>接收方将<strong>尽快</strong>向AP交付</u>此报文段，不等到整个缓存填满，占1bit</li><li>复位FST：值取1时表明TCP连接出现<strong>严重差错</strong>，须先释放连接再<u>重新建立连接</u>，占1bit</li><li>同步SYN：值取1时表明这是一个 <u>连接请求</u> or <u>连接接受</u>报文，占1bit</li><li>终止FIN：值取1时表明要求<u><strong>释放</strong>TCP连接</u>，占1bit</li><li>窗口大小：用以向对方设置<u>发送窗口</u>的依据，单位为字节，占2Byte</li><li>检验和：伪首部 + 首部 + 数据部分的<strong>校验和</strong>，占2Byte</li><li>紧急指针：指出报文中<strong>紧急数据字节数</strong>，占2Byte</li><li>选项：一种选项被称为<strong>最大报文段长度</strong>，告知对方报文段<u>数据部分最大长度</u>；可变长，最长占40Byte</li><li>填充字段：为了让整个首部长度是<u>4Byte的整数倍</u></li></ul><p><img src="/2024/04/09/computer_network/transport-layer/TCP首部.png" width="75%"></p></li></ul><hr><h3 id="五tcp的可靠传输">五、TCP的可靠传输</h3><ul><li><p>以字节为单位的滑动窗口：</p><ul><li><p>发送窗口：包含 <u>已发送但未收到确认</u> +<u>允许发送但尚未发送</u> 的字节</p><ul><li><p>window_size：由接收方发送过来，实现拥塞控制</p></li><li><p>ack_num：由接收方发送过来，控制窗口后沿；表示此序号之前的字节已被正确接收</p><hr></li><li><p>发送窗口前移：收到接收方的ack_num后，将窗口下沿挪至ack_num处</p></li><li><p>若发送窗口已满，暂停发送</p></li></ul><p><strong>注意</strong>：发送窗口的<u>前沿不建议回退收缩</u>（因为收缩部分的数据可能已经被发送出去了）</p></li><li><p>接收窗口：包含 <u>允许接受</u> 的字节</p><ul><li>接收窗口前移：收到<u><strong>连续</strong>下沿字节</u>后，窗口挪至首个尚未接收的字节处</li><li>对于未按序收到的字节，先缓存，仅返回窗口下沿对应的ack_num；最后按序交付上层的AP</li></ul><p><strong>注意</strong>：由于传送窗口值有一定的滞后，故发送窗口和接收窗口<u>不总是一样大</u></p><p><img src="/2024/04/09/computer_network/transport-layer/两个窗口.png" width="80%"></p><hr></li><li><p>缓存：发送方 和 接收方 均设有缓存，如下图：</p><p><img src="/2024/04/09/computer_network/transport-layer/学习/计算机网络\计算机网络笔记\5. 传输层\TCP缓存.png"></p></li></ul><hr></li><li><p>超时重传时间的选择：发送方在规定时间内未收到确认，就要重传超时的报文段，直至收到应答</p><ul><li><p>加权平均往返时间<span class="math inline">\(\text{RTT}_S\)</span>：平滑的往返时间，计算方式如下：</p><ul><li><strong>首次</strong>测量到一个RTT样本时，<span class="math inline">\(\text{RTT}_S\)</span> = RTT</li><li>之后每测得一个新的RTT样本，更新<span class="math inline">\(\text{RTT}_S\)</span>：<span class="math inline">\(\text{RTT}_S \gets (1 - \alpha) \times\text{RTT}_S + \alpha \times \text{RTT}\)</span>；其中 <span class="math inline">\(0 \le \alpha \lt 1\)</span>，越小更新越慢</li></ul></li><li><p>超时重传时间RTO：RTO = <span class="math inline">\(\text{RTT}_S +4 \times \text{RTT}_D\)</span>，其中 <span class="math inline">\(\text{RTT}_D\)</span>表示<u>RTT的偏差的加权平均值</u>，计算方式如下：</p><ul><li>首次测得一个RTT样本时：<span class="math inline">\(\text{RTT}_D\gets \dfrac{\text{RTT}}{2}\)</span></li><li>之后每侧的一个新的RTT样本，更新<span class="math inline">\(\text{RTT}_D\)</span>：<span class="math inline">\(\text{RTT}_D \gets (1-\beta) \times \text{RTT}_D +\beta \times |\text{RTT}_S - \text{RTT}|\)</span>；其中 <span class="math inline">\(0 \le \beta \le 1\)</span></li></ul><p><strong>注意</strong>：RTO 应略大于 <span class="math inline">\(\text{RTT}_S\)</span>（从公式中也可看出）</p></li></ul></li></ul><hr><h3 id="六tcp的流量控制">六、TCP的流量控制</h3><ul><li><p>流量控制的目的：让<u>发送方</u>的发送速率不要太快，使接收方来得及接收</p><ul><li>TCP建立时，接收方将自己接收窗口的大小告知对方（window_size）</li><li>发送方根据接收方发来的window_size<strong>调整发送窗口大小</strong>，发送窗口<span class="math inline">\(\le\)</span> 接收窗口rwnd</li></ul></li><li><p>持续计时器：防止接收方发送rwnd=0报文后，接收方发送的<u>窗口报文丢失</u>导致<strong>死锁</strong></p><ul><li>TCP为每个连接设置一个持续计时器；只要一方收到对方的<strong>零窗口通知</strong>、就启动持续计时器</li><li>若持续计时器设置的时间到，发送方就发送一个零窗口探测报文段（1Byte），对方返回当前窗口值</li><li>若窗口仍是0，重新设置持续计数器；若窗口不是0（接收缓存腾出了空间），继续发送数据</li></ul><hr></li><li><p>传输效率：控制TCP报文段的<strong>发送时机</strong></p><ul><li>缓存数据达到一定量就发送：若缓存中的数据<u><strong>累计</strong>达到MSS字节</u>，就组装成一个TCP报文发送出去</li><li>应用进程控制：由<u>发送方<strong>AP</strong></u>指明要求发送报文段（push）</li><li>定时发送：发送方<u><strong>计时器</strong>期限到了</u>，就把当前缓存中已有数据装成报文段（<span class="math inline">\(\le\)</span> MSS）发送出去</li></ul></li></ul><hr><h3 id="七tcp的拥塞控制">七、TCP的拥塞控制</h3><ul><li><p>拥塞的产生原因：网络中对某资源的<strong>需求</strong>超过了该资源所能<strong>提供</strong>的部分</p><ul><li>网络资源：链路带宽、路由节点缓存、处理能力 等</li></ul><p><strong>注意</strong>：网络拥塞是由多种原因导致的，通过<u>简单增加某种资源数量</u>并不能消除拥塞</p></li><li><p>网络拥塞的表现：吞吐率下降、报文传输时延增大、丢包率增加，响应时间变长（主机未收到ack就说明拥塞了）<br><strong>注意</strong>：<strong>TCP重传机制</strong>是<u>拥塞恶性循环</u>的起因（网络中被注入了更多报文）</p><hr></li><li><p>慢启动：每收到一个ack，cwnd就加1 <span class="math inline">\(\Rightarrow\)</span>每经过一个传输轮次（RTT），<u><strong>cwnd就加倍</strong></u>（逐步增大cwnd）</p><ul><li>拥塞窗口cwnd：由<strong>发送方</strong>维持，根据网络的拥塞程度<strong>动态变化</strong>（无拥塞就增大、有拥塞就减小）</li><li>慢启动门限ssthresh：防止cwnd增长过快导致拥塞<ul><li>cwnd &lt; ssthresh：使用<u>慢启动</u>算法</li><li>cwnd &gt; ssthresh：改用<u>拥塞避免算法</u></li><li>cwnd = ssthresh：<u>两种算法</u>都可以使用</li></ul></li></ul></li><li><p>拥塞避免算法：每经过一个传输轮次（RTT），就把<u><strong>cwnd加1</strong></u>（而非翻倍）</p><ul><li>拥塞处理：<ol type="1"><li>只要发送方判断网络出现拥塞（未按时收到ack），就令 ssthresh <span class="math inline">\(\gets\)</span> cwnd / 2</li><li>令 cwnd <span class="math inline">\(\gets\)</span>1，并重新执行<u>慢启动算法</u></li></ol></li></ul><p><img src="/2024/04/09/computer_network/transport-layer/曲线图1.png"></p><hr></li><li><p>快重传：尽快对超时报文做处理</p><ul><li>拥塞处理：<ol type="1"><li>接收方每收到一个<strong>失序</strong>的报文段，就只对<u>最近按序接收的报文段</u>回复<strong>重复确认</strong></li><li>若发送方<u>连续接收到3个重复确认</u>，就<strong>立即重传</strong>对方尚未收到的报文段</li></ol></li></ul><p><img src="/2024/04/09/computer_network/transport-layer/快重传.png" width="60%"></p></li><li><p>快恢复：跳过慢启动算法，直接执行拥塞避免算法</p><ul><li>拥塞处理：<ol type="1"><li>发送端<u>连续收到3个重复确认</u>时，令 ssthresh <span class="math inline">\(\gets\)</span> cwnd / 2</li><li>令 cwnd <span class="math inline">\(\gets\)</span>ssthresh，直接执行<strong>拥塞避免算法</strong></li></ol></li></ul><p><strong>注意</strong>：连续收到3个重复确认不代表发生拥塞（仅可能代表<strong>拥塞征兆</strong>）</p><p><img src="/2024/04/09/computer_network/transport-layer/曲线图2.png"></p><hr></li><li><p>发送窗口的上限值 = min[rwnd, cwnd]，由该式可知：</p><ul><li>当 rwnd &lt; cwnd时：接收方的<strong>接受能力</strong>限制发送窗口最大值</li><li>当 rwnd &gt; cwnd时：<strong>网络拥塞</strong>限制发送窗口的最大值</li></ul></li></ul><hr><h3 id="八tcp的连接管理">八、TCP的连接管理</h3><ul><li><p>TCP传输连接：</p><ul><li>连接三阶段：连接建立 + 数据传送 + 连接释放</li><li>客户 / 服务器方式：TCP连接的方式<ul><li>客户：<strong>主动</strong>发起连接建立的AP</li><li>服务器：<strong>被动</strong>等待连接建立的AP</li></ul></li></ul></li><li><p>三次握手：TCP建立连接的方式</p><ul><li>采用3次而非2次握手的原因：2次握手可能导致“已在网络中失效的请求报文”突然又传送到服务器端，建立冗余连接占用资源</li><li>TCP SYN Flooding 攻击：攻击者发送大量SYN报文，但<u>不对返回的SYNACK报文做回应</u>，导致挂有大量TCP半连接资源<ul><li>攻击效果：服务器<u>内部资源满</u>，无法相应正常用户的TCP连接请求</li><li>SYN_Cookies：服务器返回SYN_ACK时，根据自身特有信息<strong>计算Cookies</strong>作为seq返回，并在收到应答前不为其分配资源</li></ul></li></ul><p><img src="/2024/04/09/computer_network/transport-layer/三次握手.png" width="80%"></p></li><li><p>连接释放：该过程可由任意一方发起，设A主动关闭连接（FIN）</p><ul><li>MSL：报文最大存活时间，建议2mins</li></ul><p><img src="/2024/04/09/computer_network/transport-layer/连接释放.png" width="90%">‘</p><p><strong>注意</strong>：A发送完最后一个ACK后，再经过2MSL就可以让本连接产生的所有报文段都<strong>从网络中消失</strong>；新连接中不会残留旧连接的报文段</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>computer network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>『computer network-3』network layer</title>
    <link href="/2024/04/04/computer_network/network-layer/"/>
    <url>/2024/04/04/computer_network/network-layer/</url>
    
    <content type="html"><![CDATA[<h2 id="网络层">网络层</h2><h3 id="一网络层提供的两种服务">一、网络层提供的两种服务</h3><ul><li><p>面向连接的服务：虚电路；以<u>电信公司</u>为代表的一派支持，电话没有差错处理能力，故传输网络必须可靠</p><ul><li>通信双方开始数据<u>传输前</u>，先由<strong>网络建立连接</strong>，由网络保证数据传输可靠性</li><li>虚电路通信时，首部无需填写完整的目的主机地址，只需要填写虚电路编号（减少分组开销）</li></ul><p><strong>注意</strong>：虚电路只是一种<strong>逻辑连接</strong>，分组沿逻辑连接传送，<u>并不是真正建立了一条物理连接</u></p></li><li><p>无连接的服务：数据报；以<u>Internet</u>为代表的一派支持，电脑比电话有更强的差错处理能力</p><ul><li>网络在发送数据时<strong>不需要先建立连接</strong>，每个分组在网络中独立传送</li><li>网络层要设计得尽可能<strong>简单</strong>，向上层提供简单灵活、无连接的、<strong>尽最大努力交付</strong>的数据报服务（不可靠交付）</li></ul><p><strong>注意</strong>：网络层<u>不保证服务质量</u>，分组可能出错、丢失、重复或失序；由上层运输层负责可靠通信</p></li></ul><p><img src="/2024/04/04/computer_network/network-layer/对比表格.png"></p><hr><h3 id="二网际协议ip">二、网际协议IP</h3><ul><li><p>网际协议（InternetProtocol）：TCP/IP体系中最重要的两个协议之一</p><ul><li><p>各层网络的中间设备：将网络<strong>互相连接</strong>的设备</p><ul><li><p>物理层：转发器</p></li><li><p>数据链路层：网桥 or 交换机</p><p><strong>注意</strong>：物理层 和 数据链路层的设备知识把网络扩大了，不能称之为网络互连</p></li><li><p>网络层：路由器，真正的网络互连</p></li><li><p>网络层以上：网关（比较复杂、使用较少）</p></li></ul></li><li><p>虚拟互连网络：即逻辑互联网络，屏蔽了各网络的具体异构细节，在网络层上看好像是一个统一的网络</p><ul><li>直接交付：查找转发表，若目的主机<u>在</u>本网络上，就<strong>不需要经过路由器</strong>而是直接交付</li><li>间接交付：查找转发表，若目的主机<u>不在</u>本网络上，就需要<strong>转发给其它路由器</strong>进行间接交付</li></ul></li></ul></li><li><p>分类的IP地址：分配给主机或路由器的标识符，目前使用的<strong>IPv4</strong>为<u>32位IP地址</u>；IP地址由<strong>ICANN</strong>机构分配</p><ul><li><p>IP地址的表示方法：32bit，采用<strong>点分十进制记法</strong>，将IP地址用<strong>4段十进制</strong>数字表示，并在段间插入一个<strong>小数点</strong></p></li><li><p>IP地址的分类：分为A、B、C、D、E五类，IP地址 ::= {&lt;网络号&gt;,&lt;主机号&gt;}</p><p><img src="/2024/04/04/computer_network/network-layer/IP地址.png" width="80%"></p></li><li><p>各地址的范围：看点分十进制的<strong>最高字节</strong></p><ul><li>A类地址：最高字节 <span class="math inline">\(\le\)</span> 127</li><li>B类地址：128 <span class="math inline">\(\le\)</span> 最高字节 <span class="math inline">\(\le\)</span> 191</li><li>C类地址：192 <span class="math inline">\(\le\)</span> 最高字节 <span class="math inline">\(\le\)</span> 223</li><li>D类地址：224 <span class="math inline">\(\le\)</span> 最高字节 <span class="math inline">\(\le\)</span> 239</li><li>E类地址：240 <span class="math inline">\(\le\)</span> 最高字节 <span class="math inline">\(\le\)</span> 255</li></ul></li></ul></li><li><p>特殊IP地址：这些IP地址不会被指派，仅用于特定情况</p><p><img src="/2024/04/04/computer_network/network-layer/特殊地址.png" width="80%"></p><ul><li>{0, 0}：本网络上的本主机；能作为源地址，不能作为目的地址</li><li>{0, X}：本网络上主机号为 X的主机；能作为源地址，不能作为目的地址</li><li>{全1,全1}：本网络上进行广播的地址（路由器不转发）；不能作为源地址，能作为目的地址</li><li>{Y, 全1}：对网络号为 Y的网络上的所有主机进行广播；不能作为源地址，能作为目的地址</li><li>{127,非全0且非全1}：用于本机软件回环测试；能作为源地址，能作为目的地址</li></ul></li><li><p>IP地址的特点：</p><ul><li>分等级的地址结构：<ul><li>网络前缀是第一级地址（由管理机构分配），主机号是第二级地址（由单位自行分配，<strong>便于管理</strong>）</li><li>转发时仅考虑网络前缀，无需考虑目的主机号 <span class="math inline">\(\Rightarrow\)</span>减少转发表所占<strong>存储空间</strong>，缩短查找转发表的<strong>时间</strong></li></ul></li><li>多归属主机：由于路由器至少连接到两个网络上，故一个路由器至少有两个不同的IP地址</li><li>用转发器（物理层）或交换机（链路层）连接的网络仍属于一个网络；拥有<u>不同网络前缀的<strong>局域网</strong></u>必须使用<strong>路由器</strong>进行互联</li><li>同一个局域网上的主机 or路由器使用的网络前缀（网络号）必须相同；<u>局域网地址的<strong>主机号部分为全0</strong></u></li><li>匿名网络：点对点链路（"/31"，即只有两个IP地址）构成的网络不分配IP地址（节省IP地址资源）</li></ul><hr></li><li><p>IP地址与硬件地址(MAC地址)：</p><ul><li>IP地址：网络层 及以上各层使用的地址，是一种<strong>逻辑地址</strong>；设置在<strong>IP数据报首部</strong></li><li>物理地址：<u>数据链路层</u> 以及<u>物理层</u>使用的地址；设置在<strong>MAC帧首部</strong></li></ul><p><img src="/2024/04/04/computer_network/network-layer/IP地址与MAC地址.png"></p></li><li><p>ARP与RARP协议：分别实现<strong>同一局域网内</strong> IP地址 <span class="math inline">\(\rightarrow\)</span> MAC地址 <strong>与</strong>MAC地址 <span class="math inline">\(\rightarrow\)</span> IP地址的<strong>转换</strong></p><ul><li><p>ARP高速缓存：存放<u><strong>本局域网</strong></u>内各主机或路由器的<strong>IP地址到MAC地址的<u>转换项</u></strong></p></li><li><p>ARP(发送)请求分组：发送方IP地址 + 发送方MAC地址 +接收方IP地址</p></li><li><p>ARP(接收)响应分组：接收方IP地址 +<u><strong>接收方MAC地址</strong></u></p><p><strong>注意</strong>：ARP发送请求是局域网内<strong>广播</strong>发送，ARP响应请求是局域网内<strong>单播</strong>发送(只返回给发送方)</p><hr></li><li><p>主机A想给<u>本局域网</u>上的主机B发送IP包：</p><ol type="1"><li>在主机A的ARP cache中查找主机B的IP地址项</li><li>若存在主机B的IP地址项，将<strong>对应的硬件地址</strong>写入MAC帧，通过局域网发送</li><li>若不存在，在局域网内广播ARP请求；当主机B收到ARP请求时，向主机A返回ARP应答（告知B的物理地址）</li></ol><p><strong>注意</strong>：ARP解决<strong>同一局域网内</strong>IP地址和硬件地址的映射问题；若目的主机<u>不在本局域网内，IP包需经路由器转发</u></p></li><li><p>运行ARP协议：主要分为以下四种情况：</p><ul><li><span class="math inline">\(\text{H}_1\)</span>发送数据至<strong>同一网络</strong>的<span class="math inline">\(\text{H}_2\)</span>：<span class="math inline">\(\text{H}_1\)</span>广播(<span class="math inline">\(\text{N}_1\)</span>)ARP请求分组，获得<span class="math inline">\(\text{H}_2\)</span>的MAC地址</li><li><span class="math inline">\(\text{H}_1\)</span>发送数据至<strong>不同网络</strong>的<span class="math inline">\(\text{H}_3\)</span>：<span class="math inline">\(\text{H}_1\)</span>广播(<span class="math inline">\(\text{N}_1\)</span>)ARP请求分组，获得连接两个网络的<span class="math inline">\(\text{R}_1\)</span>的MAC地址（剩余工作由<span class="math inline">\(\text{R}_1\)</span>完成）</li><li><span class="math inline">\(\text{R}_1\)</span>发送数据至<strong>邻接网络</strong>的<span class="math inline">\(\text{H}_3\)</span>：<span class="math inline">\(\text{R}_1\)</span>广播(<span class="math inline">\(\text{N}_2\)</span>)ARP请求分组，获得<span class="math inline">\(\text{H}_2\)</span>的MAC地址</li><li><span class="math inline">\(\text{R}_1\)</span>发送数据至<strong>非邻接网络</strong>的<span class="math inline">\(\text{H}_4\)</span>：<span class="math inline">\(\text{R}_1\)</span>广播(<span class="math inline">\(\text{N}_2\)</span>)ARP请求分组，获得连接<span class="math inline">\(\text{N}_2\)</span>的<span class="math inline">\(\text{R}_2\)</span>的MAC地址（剩余工作由<span class="math inline">\(\text{R}_2\)</span>完成）</li></ul><p><img src="/2024/04/04/computer_network/network-layer/ARP.png"></p><p><strong>注意</strong>：ARPcache中的每个映射项目都有<strong>生存时间</strong>，超过生存时间的项目会被删除</p></li></ul></li><li><p>IP数据报的格式：首部 + 数据</p><p><img src="/2024/04/04/computer_network/network-layer/IP数据报首部.png" width="80%"></p><ul><li><p>首部固定部分：</p><ul><li><p>版本：占4bit，目前IP协议版本是IPv4；通信双方使用协议IP版本必须一致</p></li><li><p>首部长度：占4bit，单位为一个word(32bit) <span class="math inline">\(\Rightarrow\)</span> 首部长度最长可达60Byte（15<span class="math inline">\(\times\)</span> 32 / 8 Byte）</p></li><li><p>区分服务：占1byte，表示服务类型，一般被忽略</p></li><li><p>总长度：占2byte，表示首部 + 数据部分总长度，单位为一个Byte <span class="math inline">\(\Rightarrow\)</span>总长度最大可达65535Byte</p></li><li><p>标识：占2btye；当数据报长度 &gt;MTU时要分片传输，各数据报片具有<strong>相同的标识</strong>，便于各<strong>分片重装</strong>为原来的数据报</p></li><li><p>标志：占3bit，其最低位为MF、中间一位为DF，最高位无意义MF=1表示该分片后面"还有分片"，MF=0表示是最后一个分片DF=1表示“不能分片”，DF=0表示允许分片7</p></li><li><p>片偏移：占13bit，表示该分片相对于<u>原分组中数据字段起点</u>的<strong>偏移</strong>，单位为8Byte</p></li><li><p>生存时间：占8bit，表示跳数限制；每次转发时就将TTL减一，<strong>减小至0就丢弃</strong>（防止无法交付的数据报浪费网络资源）</p></li><li><p>协议：占8bit，表示该数据报携带的数据使用何种协议，如ICMP、IP、TCP、UDP、IGMP等</p></li><li><p>首部校验和：占16bit，<u>只检验数据报<strong>首部</strong></u>，不包括数据部分；最终结果（取反后）为<u><strong>全0</strong>则可以保留</u></p><ul><li><p>反码求和：将n个长度为16bit的字按行排列，写出每列"1"的个数</p><ol type="1"><li>拆分数字：将各列数字拆分成 <strong>1</strong> + (若干2的幂次之和) or<strong>0</strong> + (若干2的幂次之和)</li></ol></li></ul><ol start="2" type="1"><li>进位：将拆分得到的若干2的幂次<u><strong>按2进制权重</strong>向前<strong>累加</strong></u>到对应的列上，原列只保留1or 0</li><li>循环迭代：若最高位拆分得到的数仍 &gt;1，<strong>继续拆分</strong>之，并将拆分得到的数<strong>回添到末位</strong>上；<u>直至各列位置均= 0 or 1</u></li></ol><p><strong>注意</strong>：也可用16进制计算，各列求和后<strong>拆分</strong>得到<u>16的倍数+ &lt;16的数</u>，<strong>进位 + 循环迭代</strong>直至各列位置均 &lt; 16(0~9A~F)</p><p><img src="/2024/04/04/computer_network/network-layer/IP校验和.png" width="70%"></p></li><li><p>源地址、目的地址：各占32bit，分别表示<strong>发送</strong>IP数据报的主机IP地址和 <strong>接收</strong>IP数据报的主机IP地址</p></li></ul></li><li><p>首部可变部分：选项字段，<strong>长度可变</strong>，用来支持排错、测量以及安全等措施；<u>实际很少被使用</u></p></li></ul></li></ul><hr><h3 id="三划分子网和构造超网">三、划分子网和构造超网</h3><ul><li><p>划分子网的目的：<u>分类IP地址</u>无法适应Internet快速发展的需要（主机数量庞大+ 访问子网需求）</p></li><li><p>三级IP地址 与 子网掩码：</p><ul><li>三级IP地址：net-id + <strong>subnet-id</strong> + host-id</li><li>子网掩码：net-id 和 subnet-id 部分全1，host-id 部分全0</li></ul><p><img src="/2024/04/04/computer_network/network-layer/子网掩码.png"></p><ul><li>子网地址 = 主机IP地址 <strong>&amp;</strong> 子网掩码</li></ul></li><li><p>使用掩码的分组转发过程：路由表项 = 目的网络地址 +目的网络子网掩码 + 下一跳</p><ol type="1"><li>路由器提取分组首部的目的IP地址<strong>D</strong></li><li>用<u>与路由器<strong>直接相连</strong>的各网络的<strong>子网掩码</strong></u>和<u><strong>D</strong></u>逐位相“与”，若<u>与D匹配</u>则<strong>直接交付</strong>，否则间接交付（即转入下一步）匹配 <span class="math inline">\(\Leftrightarrow\)</span> (目的地址)&amp; (子网掩码) = (主机地址) &amp; (子网掩码)</li><li>若路由表中存在目的地址为D的<strong>特定主机路由</strong>，则将分组传送给对应的<strong>下一跳</strong>路由（否则转入下一步）</li><li>将<u>路由表中的<strong>各子网掩码</strong></u>和<u><strong>D</strong></u>逐位相“与”，若其结果<u>与该行目的地址匹配</u>，则传送给对应的<strong>下一跳</strong>路由（否则转入下一步）匹配 <span class="math inline">\(\Leftrightarrow\)</span> (目的地址)&amp; (子网掩码) = (目的网络地址)</li><li>若路由表中存在<strong>默认路由</strong>，则传送给路由表中指明的默认路由器，否则报告转发分组<strong>出错</strong></li></ol><p><strong>注意</strong>：子网内部通过<u>数据链路层MAC帧</u>实现<u>直接交付</u>，涉及<strong>ARP</strong>缓存的查询</p><hr></li><li><p>无分类编址 CIDR：用于缓解IP地址枯竭的问题</p><ul><li><p>网络前缀：代替分类地址中的网络号 + 子网号，IP地址 ={&lt;<strong>网络前缀</strong>&gt;, &lt;主机号&gt;}</p><ul><li>CIDR记法：<u>IP地址</u>后添"/n"，n表示IP地址<strong>高n位</strong>是网络前缀</li></ul></li><li><p>CIDR地址块：由<u>网络前缀相同</u>的连续IP地址组成</p><ul><li>最小地址 = &lt;网络前缀&gt; + 全0</li><li>最大地址 = &lt;网络前缀&gt; + 全1</li></ul><p><strong>注意</strong>：CIDR是无分类的，如果IP地址未指明前缀长度（"/n"），就不知道网络地址是什么</p></li><li><p>地址掩码：用于计算网络地址，高n位为全1，剩余低位为全0；网络地址 =IP地址 &amp;&amp; 地址掩码</p></li><li><p>路由聚合 与 构成超网：</p><ul><li>超网：一个CIDR地址块可包含多个分类地址网络，如255.255.254.0/23（512个主机）可容纳两个C类网络（256个主机）</li><li>路由聚合：一个表项 <span class="math inline">\(\rightarrow\)</span>很多个传统分类地址（可减少路由表中<strong>表项</strong>的个数），减少了查找转发表所需要的时间</li></ul></li><li><p>最长前缀匹配：选择<u>匹配成功</u>的表项中具有<strong>最长网络前缀</strong>的路由</p><ol type="1"><li>让<u>目的地址D</u>依次与<u>路由表中各掩码</u>进行“按位与”操作：(掩码)&amp; (数据报目的地址) = (表项网路地址)</li><li>若 (某项掩码) &amp; (目的地址D) = (该项网络地址)，说明匹配成功</li><li>从<u>匹配成功</u>的若干表项中选出<strong>网络前缀最长</strong>的表项，转发至对应出口</li></ol><p><strong>注意</strong>：网络前缀越长，说明CIDR地址块越小，路由也就越具体</p></li></ul></li></ul><hr><h3 id="四网际控制报文协议-icmp">四、网际控制报文协议 ICMP</h3><ul><li><p>ICMP的作用：报告错误 + 测试</p></li><li><p>ICMP报文格式：ICMP位于IP层，封装在IP包内传输</p><p><img src="/2024/04/04/computer_network/network-layer/ICMP.png" width="80%"></p><p>​<strong>注意</strong>：首部的检验和<strong>检验首部</strong>，ICMP报文中的检验和<strong>检验数据报</strong></p></li><li><p>ICMP报文协议：差错报告报文 +询问报文，主要包括以下9种类型（“询问”包括request+reply）</p><ul><li>差错报告报文：向<u>源主机</u>发送<ul><li>终点不可达：路由器 or主机<strong>无法传输报文时</strong>向源主机发送</li><li>源点抑制：路由器 or主机<strong>由于拥塞丢弃报文时</strong>，向源主机发送此报文，使其<u>放慢发送速度</u></li><li>超时：当报文字段<strong>TTL=0时</strong>，路由器丢弃该报文，并向源主机发送此报文</li><li>参数问题：路由器 or主机收到的报文中<strong>头部有非法字段时</strong>，丢弃数据包，并向源主机发送此报文</li><li>重定向：路由器向源主机发送此报文<strong>告知路由改变</strong>，主机下次发送数据报给另外的路由器</li></ul></li><li>询问报文：向<u>目的主机</u>发送<ul><li>回声探测：测试网络连通性</li><li>请求时间：可用于时间同步</li></ul></li><li>应用实例：Ping(回声探测，主机回应) + Traceroute(超时检测,一系列报文的TTL=1, 2, 3, ...)</li></ul></li></ul><hr><h3 id="五路由算法及协议">五、路由算法及协议</h3><ul><li><p>路由器根据路由信息转发分组；路由信息由路由协议生成；路由算法是路由协议的核心</p></li><li><p>理想路由算法的特性：</p><ul><li>正确 + 完整：可根据路由正确寻址</li><li>计算上简单、不能增加过多开销</li><li>具有自适应性：根据通信量 + 网络拓扑 变化调整路由</li><li>具有稳定性：通信量和拓扑稳定时，能快速收敛</li><li>公平性：对所有用户公平</li><li>最佳路由：能找出最好的路由（时延）</li></ul></li><li><p>静态路由 与 <strong>动态路由</strong>：</p><ul><li>静态路由：非自适应 + 简单开销小（无法及时适应网络变化）+适用于小规模网络（人工设置路由）</li><li>动态路由：自适应 + 复杂开销大（较好地适应网络状态变化）+适用于大规模网络（算法协议计算）</li></ul></li><li><p>自治系统AS：一组路由器，AS内部使用 <u>路由选择协议</u> +<u>共同的度量</u> 确定AS内的路由</p><ul><li>内部网关协议IGP：AS内部使用的路由选择协议，如RIP和OSPF</li><li>外部网关协议EGP：若源站和目的站<u>处在不同的自治系统中</u>，自治系统边界使用EGP将路由选择信息传递到另一个AS中</li></ul><hr></li><li><p>RIP报文：距离向量路由协议</p><ul><li><p>RIP特点：</p><ul><li>简单、适用于小规模网络</li><li>距离定义为路由器跳数：最长为15、<u>16表示不可达</u></li><li>仅与<strong>相邻路由器</strong>交换信息（即路由表），每30s交换一次</li></ul></li><li><p>RIP格式：属于用户层协议，封装在UDP用户数据报中</p><p><img src="/2024/04/04/computer_network/network-layer/RIP报文.png" width="80%"></p></li><li><p>RIP优势与缺陷：</p><ul><li>优势：实现简单，开销较小</li><li>缺陷：”坏消息传得慢“<ul><li>网络出现故障时，要经过很长的时间才能传送到所有路由器</li><li>支持的网络规模有限($$15)</li><li>每次交换完整的路由表，这导致随着网络规模扩大，开销随之增加</li></ul></li></ul></li></ul></li><li><p>距离向量路由：动态路由算法；各路由器维护一张路由表，存放<strong>目的网络 - 最短距离 - 下一跳</strong> 的表项</p><ol type="1"><li>路由器R收到相邻路由器X的RIP报文，<u>把报文<strong>下一跳地址</strong>改为X</u>，<u>把报文中<strong>所有距离d加1</strong></u>得到d'，<u>报文目的地址仍为N</u></li><li>对改后RIP报文中的每个项目：<ul><li>若R的路由表中<u>不存在目的网络N</u>，直接将该项目加入路由表即可（N不可达<span class="math inline">\(\Rightarrow\)</span> N可能可达）</li><li>若R的路由表中<u>存在目的网络N</u>：<ul><li>若其下一跳地址仍是X，必须用新的项目更新该项目（保证路由信息是最新的）</li><li>若其下一跳地址不是X，<strong>且d'小于原先距离</strong>，用最新的项目覆盖该项目（<strong>松弛操作</strong>）；否则不更新</li></ul></li></ul></li><li>若3min内未收到相邻路由器的更新路由表（标明邻居不可用），则把此相邻路由器更新为16</li></ol><hr></li><li><p>链路状态路由：</p><ul><li>链路状态：本路由器与哪些路由器<strong>相邻</strong>，以及该链路的“<strong>度量</strong>”</li><li>链路状态数据库：每个路由器各自建立，均包含<u><strong>全网络</strong>的拓扑结构图</u>，各db保持一致（链路状态数据库的<strong>同步</strong>）<br><strong>注意</strong>：RIP协议并不知道全网的拓扑结构，只知道全网络dist+ 下一跳地址</li><li>路由表构建：基于<u>全网拓扑图</u>，使用<strong>dijkstra算法</strong>计算本路由器到其它节点的最佳路径，构建路由表</li></ul></li><li><p>链路状态路由算法：以下均为<u>双向操作</u></p><ol type="1"><li>每个节点向邻居发送问候分组（间隔10s一次），了解邻居节点的网络地址、是否可达</li><li>设置到它每个邻居的成本<strong>度量</strong>metric</li><li>构造<strong>DD分组</strong>，向邻站提供<u>自己数据库中</u>已有的链路状态<strong>摘要信息</strong></li><li>（根据摘要信息）邻站向本站发送<strong>LSR分组</strong>，请求本站没有的or 可更新的信息</li><li>本站收到邻站的LSR分组后，发送<strong>LSU分组</strong>对链路进行更新；更新完毕后，邻站返回<strong>LSA分组</strong>确认</li></ol><p><strong>注意</strong>：只要有一个路由器链路状态发生改变，就要使用<strong>洪泛法</strong>更新全网链路状态，且收到更新分组后要<strong>返回确认</strong></p></li><li><p>OSPF协议：属于链路状态路由协议，直接通过IP数据报传送（不使用UDP）</p><ul><li><p>OSPF特点：</p><ul><li>收敛速度快：当链路状态发生变化时，通过<strong>洪泛</strong>方式告知本AS中的其它节点<br><strong>注意</strong>：“洪泛”是指向除了输入链路外的所有其他链路发送数据，之后每个相邻路由器接着向所有相邻路由器发送数据("BFS")</li><li>适用于<u>较大规模</u>的网络：仅在<u>链路状态发生<strong>变化</strong>时</u>发送洪泛信息，不会产生很大的通信量</li></ul></li><li><p>OSPF类型：Hello确定<strong>可达性</strong>，其余类型用于达到<strong>数据库的同步</strong></p><ul><li>问候(Hello)分组：用来发现和维持邻站可达性</li><li>数据库描述(DD)分组：向邻站给出<u>自己的链路状态数据库</u>中<strong>所有链路状态项目</strong>的<u><strong>摘要</strong></u></li><li>链路状态请求(LSR)分组：向对方请求某些链路状态项目的<u><strong>详细信息</strong></u></li><li>链路状态更新(LSU)分组：用<strong>洪泛法</strong>对全网络更新链路状态</li><li>链路状态确认(LSA)分组：对链路更新分组(LSU)的确认</li></ul><p><img src="/2024/04/04/computer_network/network-layer/OSPF分组.png" width="80%"></p></li><li><p>划分区域：OSPF将一个AS进一步划分为若干个区域，便于管理大规模网络</p><ul><li><p>优势：将<u>洪泛范围限制在一个区域</u>而不是整个自治系统，<strong>减少整个网络上的通信量</strong></p></li><li><p>层次结构的区域划分：每个区域拥有一个32位的<strong>区域标识符</strong>（用点分十进制表示）；主干区域用于连通其它下层区域</p><p><img src="/2024/04/04/computer_network/network-layer/AS区域划分.png" width="80%"></p></li></ul><p><strong>注意</strong>：一个区域内的路由器只知道本区域内的完整网络拓扑，不知道其它区域的网络拓扑</p></li></ul><hr></li><li><p>外部网关路由协议BGP：<u>不同AS路由器之间</u>交换路由信息的协议</p><ul><li><p>BGP发言人：每个AS至少要选择一个路由器作为BGPspeaker，与其它AS的BGP speaker交路由换信息</p><ul><li>连接方式 与选择条件：通过一个<strong>共享网络</strong>连接、一般选自<strong>AS边界路由器</strong>（也可以不是）</li><li>通信条件：路由信息交换由<strong>TCP协议</strong>进行，在TCP连接上<u>交换BGP报文</u>建立BGP会话</li></ul><p><strong>注意</strong>：BGP发言人除了运行BGP协议外，还要运行<u>AS内部网关路由协议</u>（RIPor OSPF）</p></li><li><p>信息交换 与 路由生成</p><ul><li>信息交换：交换<strong>网络可达性信息</strong>，即要到<u>达某个网络所经过的<strong>一系列AS</strong></u>（路径向量）</li><li>路由生成：BGP发言人交换了<strong>网络可达性信息</strong>后，根据策略找到到达各AS的较好的路由</li></ul></li><li><p>BGP-4报文：包括以下4种</p><ul><li>OPEN报文：与相邻的另一个BGP发言人<strong>建立联系</strong></li><li>UPDATE报文：发送某一<strong>路由信息</strong> +列出要<strong>撤销</strong>的多条路由，路由信息变化时发送</li><li>KEEPALIVE报文：确认打开报文(OPEN) +<strong>周期性</strong>证实邻站关系</li><li>NOTIFICATION报文：传送检验到的<strong>差错</strong></li></ul></li><li><p>BGP协议的特点：</p><ul><li><u>交换路由信息的节点</u>数量级 约等于<u>AS</u>个数，大大少于所有AS中的网络数</li><li>各AS中的<u>BGP发言人数量很少</u>，使AS之间的路由选择不至于过于复杂</li><li>BGP支持<strong>CIDR</strong>，故BGP路由表中包括目的网络前缀 +下一跳路由器</li><li>BGP<u>刚开始运行</u>时，邻站交换<strong>完整的BGP路由表</strong>；之后只在发生变化时更新，有利于<strong>节省网络带宽</strong>+ <strong>减少处理开销</strong></li></ul></li></ul></li></ul><hr><ul><li><p>路由器：具有多个输入/输出端口的<u>专用计算机</u>，任务是<strong>转发分组</strong></p><ul><li><p>路由器组成：路由选择（控制层面，根据路由选择协议<strong>构建路由表</strong>）+分组转发（数据层面，交换结构 + 一组输入/输出端口）</p></li><li><p>分组转发：</p><ul><li>报文转发速率影响因素：输入/输出端口性能 + 交换机构的性能</li><li>衡量路由器性能的指标：packet per second，简写为pps</li></ul></li><li><p>输入和输出端口处理：</p><p><img src="/2024/04/04/computer_network/network-layer/输入输出端口.png" width="80%"></p><p><strong>注意</strong>：在端口队列中排队会产生时延；分组处理速率 &lt;分组进队速率 会导致丢包（无队列存储空间）</p></li></ul><hr></li><li><p>网络的控制平面与数据平面</p><ul><li>控制平面：<strong>生成</strong>路由表 +转发表；数据平面：进行分组的快速<strong>转发</strong></li><li>软件定义网络SDN：<ul><li>控制层面：<ul><li>SDN控制器：<strong>维护</strong>准确的网络状态信息 +为运行在控制平面的网络控制应用程序<strong>提供</strong>这些状态信息</li><li>网络控制应用程序：根据SDN控制器提供的方法，<strong>监视</strong>、<strong>编程</strong>、<strong>控制</strong>下方的网络设备</li></ul></li><li>数据层面：根据转发表进行数据<strong>转发</strong></li><li>特点：<ul><li><u>控制平面</u>与<u>数据平面</u><strong>分离</strong>：控制器负责<strong>计算</strong>转发表，路由器仅实现<strong>转发</strong></li><li>网络控制远离数据层面的网络交换机：由<strong>软件</strong>实现控制层面，包含SDN控制器 + 若干网络控制应用程序</li><li>可编程的网络：利用<u>控制层面</u>的网络控制应用程序，使网络成为<strong>可编程的</strong></li></ul></li><li>优势：可以灵活快速地控制路由 /转发策略；适用于路由策略变化频繁的网络</li></ul></li></ul></li></ul><hr><h3 id="六ip组播">六、IP组播</h3><ul><li>组播（多播）：用于实现<u>一点</u>对<u>多点</u>的数据传输<ul><li>优势：可大大<strong>减少网络流量</strong>，应用于<u>网络视频服务</u></li><li>组播数据报：使用D类IP地址(1110...)，每个D类地址标志一个<strong>多播组</strong>，其IP首部协议字段是2，表示使用IGMP协议<br><strong>注意</strong>：多播地址<u>只能用于目的地址</u>，不能用于源地址；多播数据报不产生ICMP差错报文</li><li>组播类别：包含以下2种<ul><li>在局域网中的硬件组播：将<strong>MAC地址</strong>中特定地址段作为组播地址，并与IP组播地址形成对应关系</li><li>在Internet中的组播：<ul><li>需要<strong>组播路由器</strong></li><li><u>主机</u>通过<strong>IGMP协议</strong>与<u>组播路由器</u>通信，加入or 退出某个组播组</li><li><u>组播路由器之间</u>通过<strong>组播路由协议</strong>实现组播数据报的传输</li></ul></li></ul></li></ul></li></ul><hr><h3 id="七nat-与-vpn">七、NAT 与 VPN</h3><ul><li><p>网络地址转换 NAT：</p><ul><li>专用地址：只能用于<strong>机构内部</strong>的保留地址，Internet中的路由器<u>不转发目的地址为<strong>专用地址</strong>的包</u><strong>注意</strong>：专用地址可减少IP地址空间的占用，提高安全性</li><li>网络地址转换：当<u>内部网络使用<strong>专用地址</strong></u>时，<u>与Internet通信</u>需要经过NAT路由器，实现<u>外网数据包</u>向<u>内网地址</u>的转换</li></ul><hr></li><li><p>虚拟专用网 VPN：涉及隧道、加密、身份认证等技术</p><ul><li><p>多个企业 or 机构的<strong>内部网络间互连</strong>实现方法：</p><ul><li>租用专用网络，形成<strong>专用网</strong>，成本高昂</li><li>基于公用网路，形成<strong>虚拟专用网</strong>VPN</li></ul></li><li><p><u>基于<strong>Internet</strong></u>建立VPN的两种情形：</p><ul><li><strong>内部网络间</strong>通过Internet互连</li><li><strong>远程用户</strong>访问某内部网络（remote access VPN）</li></ul></li><li><p>典型的VPN实现技术：IPSec(工作在网络层) orSSL(Web浏览器内置支持)</p></li><li><p>VPN架构：使用<strong>隧道技术</strong>，效果好像在<u>本部门的专用网</u>上传输</p><p><img src="/2024/04/04/computer_network/network-layer/VPN.png" width="80%"></p></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>computer network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>『machine learning-7』neural network</title>
    <link href="/2024/03/30/machine_learning/neural-network/"/>
    <url>/2024/03/30/machine_learning/neural-network/</url>
    
    <content type="html"><![CDATA[<h2 id="神经网络">神经网络</h2><h3 id="一感知器">一、感知器</h3><ul><li><p>感知器的定义：以一个<strong>实值向量</strong>为输入，计算输入中<strong>各分量的线性组合</strong>，最后通过<strong>激活函数</strong>计算输出</p><p>感知器的输出计算公式： <span class="math display">\[o(x_1, ..., x_n) =\begin{cases}1 &amp; \omega_0 + \omega_1 x_1 + ... + \omega_n x_n \gt 0 \\-1 &amp; otherwise\end{cases}\]</span> 上式中激活函数取符号函数<span class="math inline">\(sgn(x)\)</span></p><p><strong>注意</strong>：一般会设置一个<strong>固定的输入<span class="math inline">\(x_0 = 1\)</span></strong>，则上面的不等式可写成<span class="math inline">\(\sum_{i=0}^n \omega_i x_i \gt 0\)</span></p><hr></li><li><p>感知器的表征能力：可解决<strong>线性可分问题</strong></p><ul><li><p>线性可分：设样例是n维实例空间中的点</p><p>若存在<u>一个超平面决策面</u>正好可以<strong>将正反样例划分开</strong>，说明被划分的集合称为线性可分集合</p><p>超平面方程即为 <span class="math inline">\(\vec{\omega} \cdot \vec{x}= 0\)</span></p></li><li><p>m-of-n问题：设1为布尔真、0为布尔假；要使得感知器输出为真，则感知器的<u>n个输入中至少需有m个输入为真</u></p><p>设置所有的 <span class="math inline">\(\omega_i\)</span> = 0.5（<span class="math inline">\(i \ge\)</span> 1），再设置适当的阈值（<span class="math inline">\(\omega_0\)</span>）即可；如“或门”的<span class="math inline">\(\omega_0 \gt -0.5\)</span></p><p><strong>注意</strong>：“与或非”都是常见的线性可分运算，“异或”不是（不能用单一的感知器计算）</p></li></ul><hr></li><li><p>感知器的训练法则：从随机的一组权值开始，将所有训练样例提交给感知器</p><p>只要出现误分类就修改权值，直至感知器<strong>正确分类所有样例</strong>，设输入样例<span class="math inline">\((x_i, t)\)</span>对应的权值为<span class="math inline">\(\omega_i\)</span>： <span class="math display">\[\begin{align}\omega_i &amp;\leftarrow \omega_i + \Delta \omega_i \\其中权重增量 \Delta \omega_i &amp;= \eta (t - o)x_i\end{align}\]</span> 其中o表示感知器的当前输出，<span class="math inline">\(\eta\in (0, 1)\)</span>表示<strong>学习速率</strong></p><p>由训练法则可知，若<u>当前输出</u>与<u>样例属性值</u>相等，对应权值就不会调整</p><hr></li><li><p>梯度下降和delta法则：</p><ul><li><p>感知器训练法则：仅能对线性可分的样本做分类</p></li><li><p>delta法则：通过<strong>梯度下降</strong>求出非线性可分计算的最佳近似（<u>学习率* 输入值 * 输出误差</u>）</p></li><li><p>梯度下降：搜索使<strong>误差最小化</strong>的权值向量，设线性单元输出<span class="math inline">\(o(\vec{x}) = \vec{\omega} \cdot\vec{x}\)</span></p><ul><li><p>训练误差：<span class="math inline">\(E(\vec{\omega}) =\frac{1}{2} \sum_{d \in D} (t_d - o_d)^2\)</span></p><p>其中D是样本集，<span class="math inline">\(t_d\)</span>是样本属性值，<span class="math inline">\(o_d\)</span>是当前线性单元的输出</p></li><li><p>梯度：函数E上升<strong>最陡峭</strong>的方向，<span class="math inline">\(\nabla E = (\frac{\partial E}{\partial \omega_0},...,\frac{\partial E}{\partial \omega_n})\)</span>，故设调整方向 <span class="math inline">\(\Delta \vec{\omega} = -\eta \nablaE(\vec{\omega})\)</span></p></li><li><p>梯度下降算法：初始化<span class="math inline">\(\Delta \omega_i =0\)</span>，对训练样本中的所有样本<span class="math inline">\((\vec{x},t)\)</span>，<u>累计</u>计算所有的<strong>权值增量</strong>： <span class="math display">\[\Delta \omega_i \leftarrow \Delta \omega_i + \eta (t - o) x_i\]</span> 最后<strong>调整各权值分量</strong>： <span class="math display">\[\omega_i \leftarrow \omega_i + \Delta \omega_i\]</span> <strong>注意</strong>：学习速率<span class="math inline">\(\eta\)</span>必须<strong>足够小</strong>，以防止步幅过大跨过最小误差对应的权值向量</p></li></ul></li><li><p>随机梯度下降：解决<u>收敛速度过慢</u>或<u>陷入局部极小</u>的问题</p><ul><li>标准梯度下降：在权值更新之前<strong>先汇总</strong>所有样例的误差<span class="math display">\[\Delta \omega_i = \eta \sum_{d \in D} (t_d - o_d)x_{di}\]</span> <u>随机梯度下降</u>：根据每个样例<span class="math inline">\((\vec{x},t)\)</span><strong>直接更新</strong>各权值 <span class="math display">\[\Delta \omega_i = \eta (t - o) x_i\]</span></li></ul></li></ul><p><strong>注意</strong>：感知器训练法则是根据<strong>阈值输出</strong>调整权值，而delta法则是直接根据<strong>线性单元输出</strong>调整权值</p></li></ul><hr><h3 id="二多层网络和反向传播算法">二、多层网络和反向传播算法 ⭐</h3><ul><li><p>多层网络：具有<strong>隐藏层</strong>，能够表示<u>高度非线性</u>的决策面（如曲面）</p></li><li><p>可微阈值单元：适用于梯度下降算法<strong>非线性</strong>的<strong>可微</strong>函数</p><p>sigmoid函数：常见的平滑可微的阈值函数 <span class="math display">\[sigmoid(x) = \frac{1}{1 + e^{-x}}\]</span></p></li><li><p>sigmoid函数的特殊性质：记sigmoid为<span class="math inline">\(\sigma\)</span>，有<span class="math inline">\(\sigma&#39; = \sigma(1-\sigma)\)</span></p><hr></li><li><p>反向传播算法（BP算法）：通过<strong>梯度下降</strong>最小化<u>网络输出值</u>和<u>目标值之间</u>的误差平方</p><p>设<span class="math inline">\(x_{ji}\)</span>为神经元j的第i个<strong>输入</strong>，<span class="math inline">\(\omega_{ji}\)</span>表示对应的<strong>权重</strong>，<span class="math inline">\(net_j\)</span>表示神经元j<strong>输入的线性加权</strong>，<span class="math inline">\(o_j\)</span>表示神经元j的<strong>阈值输出</strong></p><p>downstream(j)表示以神经元j的输出为直接输入的<strong>下一层神经元</strong>的集合</p><p><img src="/2024/03/30/machine_learning/neural-network/BP算法.png" width="80%" height="80%">对于训练样本集中的每个样例<span class="math inline">\((\vec{x_i},t)\)</span>，将其输入网络，使误差沿网络反向传播：</p><ol type="1"><li><p>对于网络中的每个<strong>输出神经元k</strong>，计算其误差项<span class="math inline">\(\delta_k = o_k(1-o_k)(t_k - o_k)\)</span> （<span class="math inline">\(\sigma&#39; \Delta out）\)</span></p></li><li><p>对于网络中的每个<strong>隐层神经元h</strong>，计算其误差项<span class="math inline">\(\delta_h = o_h(1-o_h) \sum_{k \in downstream(h)}\delta_k \omega_{kh}\)</span>（<u><strong>向前递推</strong></u>）</p><p>第m层神经元的误差项是由<strong>所有第m+1层神经元</strong>的误差项推导出来的</p></li><li><p><strong>更新</strong>各网络权值<span class="math inline">\(\omega_{ji} \leftarrow \omega_{ji} + \Delta\omega_{ji}\)</span>，其中<span class="math inline">\(\Delta \omega_{ji}= \eta \delta_{j} x_{ji}\)</span></p></li></ol><p>反向传播算法的终止条件：固定的迭代次数（一轮<u>迭代</u>指<u>读取一遍训练集</u>），或误差降至某个阈值以下</p></li></ul><p>​<strong>注意</strong>：上面的BP算法适用于任何“无环”网络学习，downstream也不要求各层网络中的神经元整齐排列在一行内</p><ul><li><p>BP算法的推导思路：设样本d的误差平方<span class="math inline">\(E_d(\vec{\omega}) = \frac{1}{2} \sum_{k \inoutputs} (t_k - o_k)^2\)</span></p><p>由梯度下降算法，对每个训练样例d，需要求解 <span class="math inline">\(\Delta \omega_{ji} = -\eta \frac{\partialE_d}{\partial \omega_{ji}}\)</span>，即调整梯度的增量</p><p>神经元j的输入权值<span class="math inline">\(\omega_{ji}\)</span><u>仅通过加权和<span class="math inline">\(net_j\)</span></u>影响<strong>后方的网络</strong>，由链式法则：<span class="math display">\[\begin{align}\frac{\partial E_d}{\partial \omega_{ji}} &amp;= \frac{\partialE_d}{\partial net_j} \frac{\partial net_j}{\partial \omega_{ji}} \\&amp;= \frac{\partial E_d}{\partial net_j} x_{ji} = -\delta_j x_{ji}\end{align}\]</span> 若神经元j是<strong>输出神经元</strong>：神经元j的加权和<span class="math inline">\(net_j\)</span><u>仅通过输出<span class="math inline">\(o_j\)</span></u>影响<strong>后方的网络</strong><span class="math display">\[\begin{align}\frac{\partial E_d}{\partial net_j} &amp;= \frac{\partial E_d}{\partialo_j} \frac{\partial o_j}{\partial net_j} \\&amp;= \frac{\partial}{\partial o_j}[\frac{1}{2} (t_j - o_j)^2]\frac{\partial \sigma(net_j)}{\partial net_j} \\&amp;= -(t_j - o_j)o_j(1-o_j)\end{align}\]</span> 若神经元j是<strong>隐层神经元</strong>：神经元j的加权和<span class="math inline">\(net_j\)</span><u>通过其<strong>所有</strong>下游神经元</u>影响<strong>后方的网络</strong><span class="math display">\[\begin{align}\frac{\partial E_d}{\partial net_j} &amp;= \sum_{k \in downstream(j)}\frac{\partial E_d}{\partial net_k} \frac{\partial net_k}{\partialnet_j} \\&amp;= \sum_{k \in downstream(j)} -\delta_k (\frac{\partialnet_k}{\partial o_j} \frac{\partial o_j}{\partial net_j}) \\&amp;= \sum_{k \in downstream(j)} -\delta_k \omega_{kj} o_j(1-o_j) \\&amp;= -\delta_j\end{align}\]</span></p><hr></li><li><p>收敛性与局部极小值</p><ul><li><p>基于迭代的反向传播算法可能导致误差E收敛到某个<strong>局部极小值</strong></p></li><li><p>如何缓解局部极小值问题：“启发式规则”</p><ul><li><p>为梯度增量增设一个<strong>冲量项</strong>：<span class="math inline">\(\Delta \omega_{ji}(n) = \eta \delta_jx_{ji} +\alpha \Delta \omega_{ji}(n - 1)\)</span></p><p>其中增加的第二项就是冲量项，冲量常数 <span class="math inline">\(0\le \alpha \lt 1\)</span>；n表示第n轮迭代</p><p>冲量项有可能助力网络跳出局部极小值</p></li><li><p>以<strong>多组不同初始权重</strong>训练神经网络，取其中误差E最小的参数训练结果作为最终参数（相当于从<u>多个初始点</u>开始搜索）</p></li><li><p>使用“模拟退火”技术：模拟退火的每一步迭代都以<strong>一定概率</strong>接受比当前解更差的结果，从而有概率跳出局部极小值</p></li></ul></li></ul><hr></li><li><p>前馈网络的表征能力：</p><ul><li><p>布尔函数：任何布尔函数都可由<strong>两层网络</strong>准确表示</p><p>对<u>每种可能的输入向量</u>，创建不同的隐藏神经元，设置其权值使得<strong>仅当对应的向量输入才能激活它</strong></p><p>再将输出单元设置为一个<strong>仅可由期待的输入向量</strong>激活的<strong>或门</strong></p></li><li><p>连续函数：每个有界的连续函数可由<strong>两层网络</strong>以<u>任意小的误差</u>逼近；隐藏层使用sigmoid函数，输出层使用（非阈值）线性单元</p></li><li><p>任意函数：任意函数可被<strong>三层网络</strong>以<u>任意精度</u>逼近；两个隐藏层使用sigmoid函数，输出层使用（非阈值）线性单元</p></li></ul></li></ul><hr><h3 id="三关于神经网络的拓展讨论">三、关于神经网络的拓展讨论</h3><ul><li><p>误差函数的选取：除了误差平方和函数E，还有其它目标函数可供选择</p><ul><li><p>为权值增加一个<strong>惩罚项</strong>：通过<u>权重的平方和</u>考察网络的<strong>复杂程度</strong>，减小<strong>过拟合</strong>的风险，<span class="math inline">\(\gamma \in (0, 1)\)</span> <span class="math display">\[E(\vec{\omega}) = \frac{1}{2} \sum_{d \in D} \sum_{k \in outputs}(t_{kd} - o_{kd})^2 + \gamma \sum_{i, j} \omega_{ji}^2\]</span></p></li><li><p>对误差增加一项<strong>目标函数的斜率或导数</strong>：考察<u>训练导数</u>和<u>网络的实际导数</u>间的差异<span class="math display">\[E(\vec{\omega}) = \frac{1}{2} \sum_{d \in D} \sum_{k \in outputs}[(t_{kd} - o_{kd})^2 + \mu \sum_{j \in inputs}(\frac{\partialt_{kd}}{\partial x_d^j} - \frac{\partial o_{kd}}{\partial x_d^j})^2]\]</span> 其中<span class="math inline">\(x_d^j\)</span>表示训练实例d的第j个输入单元的值</p></li><li><p>设置目标值为<strong>交叉熵</strong>：将<strong>离散的分类输出</strong>转化为<strong>连续的概率输出</strong>，交叉熵定义：<span class="math display">\[-\sum_{d \in D} t_d\log o_d + (1 - t_d)\log(1 - o_d)\]</span> 其中<span class="math inline">\(o_d\)</span>表示对样例d输出的<strong>概率估计</strong>，<span class="math inline">\(t_d\)</span>表示训练样例的<strong>目标值</strong></p></li></ul><hr></li><li><p>其它常见神经网络：</p><ul><li><p>RBF网络：单隐层前馈神经网络</p><p>其激活函数：径向基函数，表示样本到数据中心的欧氏距离 <span class="math display">\[\rho(x, c_i) = e^{-\beta_i |{|{x - c_i}}|| ^2}\]</span> 输出层是隐层神经元输出的线性组合：其中q表示q个输出神经元 <span class="math display">\[\Phi(x) = \sum_{i=1}^q \omega_i \rho(x, c_i)\]</span></p><hr></li><li><p>ART网络：自适应谐振理论网络，<strong>竞争型学习</strong>的代表</p><ul><li><p>网络组成：比较层、识别层、<strong>识别阈值</strong>、重置模块</p><ul><li><p>比较层：<strong>接收</strong>输入样本，并将其<strong>传递</strong>给识别层神经元</p></li><li><p>识别层：该层的各神经元都拥有其对应模式的<strong>代表向量</strong>，与输入向量距离最近的神经元<strong>获胜</strong>，并抑制其它神经元的激活</p><ul><li>输入向量和获胜单元间距<strong>大于识别阈值</strong>：该输入样本被<strong>归为</strong>代表向量所属类，并<strong>更新连接权</strong>，使得下次接收到<u>类似向量</u>后会计算出<strong>更大的相似度</strong></li><li>输入向量和获胜单元间距<strong>不大于识别阈值</strong>：重置模块在识别层设置<strong>新的神经元</strong>，<u>其代表向量即为当前输入向量</u></li></ul><p><strong>注意</strong>：如果识别阈值较高，就会划分出<strong>更多更精细</strong>的代表向量</p></li></ul></li><li><p>“可塑性”和“稳定性”：</p><ul><li><p>“可塑性”指神经网络要拥有<u>学习新知识</u>的能力</p></li><li><p>“稳定性”指神经网络在学习新知识的<u>同时要保持对旧知识的记忆</u></p></li></ul></li></ul><hr></li><li><p>SOM网络：自组织映射网络，竞争型学习的代表</p><ul><li><p>特点：可将高维输入映射到低维（如二维）空间</p><p>同时保证高维空间中<u>相似的样本点</u>映射到输出层中的<u>邻近神经元</u></p></li><li><p>输出层神经元：每个神经元都有一个<strong>权向量</strong>，<u>与输入向量间距最近</u>的神经元称为<strong>最佳匹配单元</strong></p><p>最佳单元邻近的权向量会被调整，使其<strong>周围权向量与输入向量的间距缩小</strong></p></li></ul><hr></li><li><p>级联相关网络：结构自适应网络的重要代表</p><ul><li><p>特点：在训练过程中寻找最符合数据特点的<strong>网络结构</strong></p></li><li><p>级联：网络层次连接的层次结构，在训练的过程中可能会有<strong>新的隐层神经元加入</strong></p></li><li><p>相关：<strong>最大化</strong><u>新神经元的输出</u>与<u>网络误差</u>间的相关性</p><p><strong>注意</strong>：新神经元的<u>输入端权值是固定的</u>，其输出端权重是训练可变的对象</p></li></ul><hr></li><li><p>Elman网络：递归神经网络的代表</p><ul><li><p>递归神经网络：包含<strong>有向环</strong>结构，神经元的输出可反馈作为输入信号，可处理<strong>时序相关</strong>的变化</p><figure style="text-align:center;"><p><img src="/2024/03/30/machine_learning/neural-network/Elman网络.png" width="30%"></p><figcaption><p>Elman递归网络结构</p></figcaption></figure></li></ul><hr></li><li><p>Boltzmann机：基于能量的模型</p><ul><li><p>结构：由布尔型神经元组成（抑制“0”或激活“1”）；包含“显层”和“隐层”神经元，两层神经元间形成<u>全连接</u></p></li><li><p>状态向量<span class="math inline">\(\vec{s}\)</span>：<span class="math inline">\(\vec{s} \in \{0, 1\}^n\)</span>表示n个神经元的状态</p></li><li><p>Boltzmann机能量：设<span class="math inline">\(\omega_{ij}\)</span>表示神经元i和j之间权连接，<span class="math inline">\(\theta_i\)</span>表示神经元i的阈值，n神经元能量：<span class="math display">\[E(\vec{s}) = -\sum_{i=1}^{n-1} \sum_{j=i+1}^n \omega_{ij} s_i s_j -\sum_{i=1}^n \theta_i s_i\]</span> 即<u>总能量 = 边权能量 + 节点能量</u></p><p>状态向量<span class="math inline">\(\vec{s}\)</span><strong>出现的概率</strong>仅有其能量和所有可能的状态向量的能量决定：<span class="math display">\[P(\vec{s}) = \frac{e^{-E(\vec{s})}}{\sum_{\vec{t}}e^{-E(\vec{t})}}\]</span></p></li><li><p>训练过程：将每个<u>样本</u>视为一个<u>状态向量</u>，<strong>最大化其出现的概率</strong></p></li><li><p>CD算法：设网络中有d个<u>显层</u>神经元和q个<u>隐层</u>神经元</p><p>令<span class="math inline">\(\vec{v}\)</span>和<span class="math inline">\(\vec{h}\)</span>分别表示显层与隐层的<strong>状态向量</strong>，现根据样本<span class="math inline">\(\vec{v}\)</span>计算隐层概率分布： <span class="math display">\[P(\vec{h}|\vec{v}) = \Pi_{i=1}^q P(h_i | \vec{v})\]</span> 再根据上述概率分布<strong>采样</strong>得到隐层向量<span class="math inline">\(\vec{h}\)</span>，并<strong>计算</strong>显层概率分布：<span class="math display">\[P(\vec{v}|\vec{h}) = \Pi_{i=1}^d P(v_i | \vec{h})\]</span> 由上述概率分布<strong>采样</strong>得到<span class="math inline">\(\vec{v}&#39;\)</span>，类似地由<span class="math inline">\(\vec{v}&#39;\)</span><strong>计算</strong>获得<span class="math inline">\(\vec{h}&#39;\)</span>，最后<strong>更新连接权重</strong>：<span class="math display">\[\Delta \omega = \eta (\vec{v} \vec{h}^T - \vec{v}&#39; \vec{h}&#39;^T)\]</span></p></li></ul></li></ul></li></ul><hr><ul><li><p>深度学习：一般指<strong>很深层</strong>的神经网络</p><ul><li><p>无监督逐层训练：“预训练 + 微调”：</p><ul><li>预训练：每次训练<strong>一层</strong>隐节点：<ol type="1"><li>将上一层隐节点的输出作为输入</li><li>将本层隐节点的输出作为下一层隐节点的输入</li></ol></li><li>微调：预训练全部完成后，对整个网络进行微调（如BP算法）</li></ul><p>这种训练方式实际上是从各层<strong>局部最优</strong>出发寻找<strong>全局最优</strong></p><hr></li><li><p>“权共享”策略：让一组神经元共享<u>相同的连接权</u>，在<strong>卷积神经网络</strong>中应用较多</p><ul><li><p>卷积层：包含多个<strong>特征映射</strong>，即神经元组成的平面</p></li><li><p>特征映射：其中的<u>每个神经元</u>负责从<strong>输入的部分区域</strong>内通过卷积滤波器<strong>提取特征</strong></p></li><li><p>采样层：其中的<u>每个神经元</u>负责从<strong>特征映射层的部分区域</strong>计算输出，起到<strong>精简数据量</strong>的作用</p><p>通过复合卷积层 +采样层，最终实现了将<u>高维信息</u>映射到<u>低维数据</u>的xiao'guo</p></li></ul><p><strong>注意</strong>：层数越多，特征越全局</p></li><li><p>池化：对不同位置的特征值进行聚合统计（max or min orrandom），达到降维 + 防止过拟合的效果</p></li><li><p>梯度消失：随着隐藏层数量的增加，不同层之间的梯度开始消失，下面是常见的解决方案：</p><ul><li>线性整流激活函数：ReLU(x) = max(0, x)</li><li>归一化：对激活后的输出进行归一化</li><li>残差网络：在输入和输出之间添加跳跃连结，允许梯度直接流过</li></ul></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>machine learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>『linux-1』view from shell</title>
    <link href="/2024/03/28/linux/view-from-shell/"/>
    <url>/2024/03/28/linux/view-from-shell/</url>
    
    <content type="html"><![CDATA[<h2 id="从-shell-眼中看世界">从 shell 眼中看世界</h2><h3 id="后续补充...">后续补充...</h3>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>『machine learning-6』SVM</title>
    <link href="/2024/03/28/machine_learning/SVM/"/>
    <url>/2024/03/28/machine_learning/SVM/</url>
    
    <content type="html"><![CDATA[<h2 id="支持向量机">支持向量机</h2><h3 id="一支持向量">一、支持向量</h3><ul><li><p>超平面：设训练样本集<span class="math inline">\(D = \{(x_1, y_1),..., (x_m, y_m\}\)</span>，其中<span class="math inline">\(y_i \in \{-1,+1\}\)</span></p><p>超平面可将二分类样本集D划分为两部分，实现<strong>正确分类</strong></p></li><li><p>支持向量与二分类：设超平面为<span class="math inline">\(\omega^Tx + b = 0\)</span>，其中<span class="math inline">\(\omega = (\omega_1;\omega_2; ...; \omega_d)\)</span> 为超平面<strong>法向量</strong></p><p>设对于训练样本<span class="math inline">\((x_i, y_i) \inD\)</span>，通过以下方式实现分类： <span class="math display">\[\begin{cases}\omega^T x_i + b \ge +1 &amp; y_i = +1 \\\omega^T x_i + b \le -1 &amp; y_i = -1\end{cases}\]</span>则称<u>距离超平面<strong>最近</strong></u>的，<u>满足上式约束</u>的训练样本为<strong>支持向量</strong></p><p>两异类支持向量<u>到超平面的距离之和<span class="math inline">\(\gamma\)</span></u>称为<strong>间隔</strong>：<span class="math display">\[\gamma = \frac{2}{|{|{\omega}||}}\]</span></p></li><li><p>支持向量机的<strong>基本型</strong>：求解两类样本“<strong>正中间</strong>”的划分超平面，即求解<strong>间隔最大</strong>的超平面<span class="math display">\[\begin{align}&amp; \underset{\omega, b}{\min} \quad \frac{1}{2} |{|{\omega}||}^2 \\\\&amp; \text{s.t.} \quad y_i(\omega^T x_i + b) \ge 1, \quad i=1,2,..,m\end{align}\]</span></p></li></ul><hr><h3 id="二对偶问题">二、对偶问题</h3><ul><li><p>拉格朗日函数：设超平面 <span class="math inline">\(f(x) =\omega^T x + b\)</span>，SVM基本型的拉格朗日函数可以写成： <span class="math display">\[L(\omega, b,  \alpha) = \frac{1}{2} |{|{\omega}||}^2 + \sum_{i=1}^m\alpha_i(1 - y_i(\omega^Tx_i + b))\]</span> 其中每个约束的拉格朗日乘子<span class="math inline">\(\alpha_i\ge 0\)</span>，<u>令L对<span class="math inline">\(\omega\)</span>和b的偏导为0</u>： <span class="math display">\[\begin{align}\omega &amp;= \sum_{i=1}^m \alpha_i y_i x_i \\0 &amp;= \sum_{i=1}^m \alpha_i y_i\end{align}\]</span> 将上式代入拉格朗日函数得到<strong>对偶函数</strong>： <span class="math display">\[  \underset{\omega, b}{inf} L(\omega, b, \alpha) = \sum_{i=1}^m \alpha_i- \frac{1}{2} \sum_{i=1}^m \sum_{j=1}^m \alpha_i \alpha_j y_i y_j x_i^Tx_j \\ \\  \]</span></p><p>SVM基本型的<strong>对偶问题</strong>（即求解SVM基本型的<strong>最优下界</strong>）：<span class="math display">\[  \begin{align}  &amp; \underset{\alpha}{max} \quad \underset{\omega, b}{\text{inf}}\quad L(\omega, b, \alpha) \\  &amp; s.t. \quad \sum_{i=1}^m \alpha_i y_i = 0 \\  &amp; \quad \quad \quad \alpha_i \ge 0  \end{align}  \]</span> <strong>注意</strong>：由约束条件，总有$inf L(, b, ) L(, b,) ^2 $</p><p>求解对偶问题得到<span class="math inline">\(\alpha\)</span>，再根据<span class="math inline">\(\alpha\)</span>解出<span class="math inline">\(\omega\)</span>与b，最终获得划分超平面 <span class="math inline">\(f(x) = \sum_{i=1}^m \alpha_i y_i x_i^Tx +b\)</span></p></li></ul><hr><h3 id="三核函数">三、核函数</h3><ul><li><p>核函数的用途：将样本空间<strong>映射到高维</strong>，以解决原始数据<strong>线性不可分</strong>的问题</p></li><li><p>核函数定义：<span class="math inline">\(k(x_i, x_j) =&lt;\phi(x_i), \phi(x_j)&gt; = \phi(x_i)^T \phi(x_j)\)</span></p><p>其中<span class="math inline">\(\phi(x)\)</span>表示将向量<span class="math inline">\(x\)</span>映射到更高的特征空间，在<u>特征空间</u>中划分超平面的形式变成<span class="math inline">\(f(x) = \omega^T \phi(x) + b\)</span></p><p>最终求解可得到 <span class="math inline">\(f(x) = \sum_{i=1}^m\alpha_i y_i k(x_i, x_j) + b\)</span>，其中<span class="math inline">\(\alpha_i \ge 0\)</span>是SVM基本型对应的拉格朗日乘子</p></li><li><p>核函数定理：设<span class="math inline">\(X\)</span>为输入空间，<span class="math inline">\(k(\cdot,\cdot)\)</span>是<span class="math inline">\(X \timesX\)</span>上的<strong>对称函数</strong></p><p>则<span class="math inline">\(k\)</span>是核函数 <span class="math inline">\(\leftrightarrow\)</span> 对任意输入数据<span class="math inline">\(D = \{x_1, ..., x_m\}\)</span>，核矩阵<span class="math inline">\((k(x_i, x_j))_{m \timesm}\)</span>是<strong>半正定</strong>的</p></li><li><p>常用核函数：直接计算高维向量的内积较为复杂，故可使用核函数<strong>直接应用于原始样本</strong></p><ol type="1"><li>线性核：<span class="math inline">\(k(x_i, x_j) =x_i^Tx_j\)</span></li><li>多项式核：<span class="math inline">\(k(x_i, x_j) =(x_i^Tx_j)^d\)</span>，其中d为多项式<u>次数</u></li><li>高斯核：<span class="math inline">\(k(x_i, x_j) = e^{-\frac{|{|{x_i- x_j}||}^2}{2\sigma^2}}\)</span>，其中<span class="math inline">\(\sigma \gt 0\)</span>为高斯核<u>带宽</u></li><li>拉普拉斯核：<span class="math inline">\(k(x_i, x_j) =e^{-|{|NaN||^2}{\sigma}}\)</span>，其中<span class="math inline">\(\sigma \gt 0\)</span></li><li>Sigmoid核：<span class="math inline">\(k(x_i, x_j) = tanh(\betax_i^Tx_j + \theta)\)</span>，其中<span class="math inline">\(\beta &gt;0\)</span>，<span class="math inline">\(\theta \lt 0\)</span></li></ol><p><strong>注意</strong>：核函数隐式定义了特征空间，应<strong>选取合适的核函数</strong>将样本空间映射到合适的特征空间</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>machine learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>『machine learning-5』decision tree</title>
    <link href="/2024/03/27/machine_learning/decision-tree/"/>
    <url>/2024/03/27/machine_learning/decision-tree/</url>
    
    <content type="html"><![CDATA[<h2 id="决策树">决策树</h2><h3 id="一决策树流程">一、决策树流程</h3><ul><li><p>决策树结构：一个根节点、若干个内部节点、若干个叶节点</p><ul><li>根节点：包含<strong>样本全集</strong></li><li>内部节点：一个内部节点对应于一个<strong>属性测试</strong>，其包含的样本集根据属性测试的结果被<u>划分</u>到子节点中</li><li>叶子节点：一个叶子节点对应于一个<strong>决策结果</strong></li></ul></li><li><p>决策树学习算法：“分治思想”，每个样例有其对应的属性值（即类别）</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">输入：训练集 D = &#123;(x1, y1), ..., (xm, ym)&#125;;<br> 属性集 A = &#123;a1, a2, ..., ad&#125;;<br>-------------------------------------------<br>TreeGenerate(D, A) &#123;<br>生成新节点node;<br>if (D中样本/* 全部属于同一类别C */) &#123;<br>/* 已经分好类了 */<br>将node标记为C类叶子节点;<br>return;<br>&#125;<br>if (D中样本/* 在A上属性值彼此相等 */ || size(A) == 0) &#123;<br>/* 当前决策属性已无法划分数据集 */<br>将node标记为叶子节点，其类别标记为 /* D中样本数最多的类 */;<br>return;<br>&#125; <br><br>从A中选出最优决策属性A*;<br>for each value in A* &#123;<br>生成node的一个分支，令D_value表示为/* 在A*中属性取值为value的样本子集 */;<br>if (size(D_value) == 0) &#123;<br>/* 说明D_value对应的属性值不具备划分能力，只能继承父节点的优势类别 */<br>将新生成的分支节点标记为叶子节点，其类别标记为 /* D中样本数最多的类 */;<br>return;<br>&#125; else &#123;<br>/* 还可以继续根据属性值value 划分样本 */<br>return TreeGenerate(D_value, A-&#123;A*&#125;)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="二划分选择">二、划分选择</h3><ul><li><p>决策树学习算法中的关键在于选择<strong>最优划分属性</strong>，以提高分支节点所包含的样本类别<strong>纯度</strong></p></li><li><p>信息熵：度量样本集合<strong>纯度</strong>的常用指标，设样本集合D中<strong>第k类</strong>(<span class="math inline">\(1 \le k \lem\)</span>)样本所占<strong>比例</strong>为<span class="math inline">\(p_k\)</span>，则D的信息熵： <span class="math display">\[Ent(D) = -\sum_{k=1}^ m p_klog_{2}p_k\]</span> 信息熵Ent(D)的值越小，则D的纯度越高（对于二分类m=2）</p></li><li><p>信息增益：描述某属性的划分纯度，设离散属性a有V个可能的取值<span class="math inline">\(\{a^1, a^2, ..., a^V\}\)</span></p><p><br>属性a可以将样本D划分为V个分支节点：第v个子节点包含了D在属性a上<strong>取值为<span class="math inline">\(a^v\)</span></strong>的样本集合<span class="math inline">\(D_v\)</span>，信息增益有如下式子计算： <span class="math display">\[Gain(D, a) = Ent(D) - \sum_{v=1}^V\frac{|{D^v}|}{|{D}|}Ent(D^v)\]</span>上式中第一项是划分前的熵，第二项是<strong>划分后</strong>的熵期望（各子集熵的加权和）</p></li><li><p>划分流程：算出当前节点样本集的<strong>信息熵</strong>，再算出当前节点样本集在<u>各属性下</u>的<strong>信息增益</strong></p></li><li><p>增益率：上面的<u>信息增益准则</u>可能对<strong>取值数目较多</strong>（V较大）的属性有所偏好，需要对信息增益准则做调整，引入<strong>增益率</strong>的概念：<span class="math display">\[Gain\_ratio(D, a) = \frac{Gain(D, a)}{IV(a)} \\IV(a) = -\sum_{v=1}^V\frac{|{D^v}|}{|{D}|}log_2{\frac{|{D^v}|}{|{D}|}}\]</span>其中IV(a)代表属性a的<strong>固有值</strong>：属性a的取值数目越多（V越大），则IV(a)通常越大（分的越散），能够<strong>对信息增益Gain(D,a)做出平衡调整</strong></p></li><li><p>基尼指数：反映了从数据集D中随机抽取两个样本，其<strong>类别不一致</strong>的概率<br><strong>基尼指数越小</strong>，数据集D中类别不一致的可能性越低，<strong>纯度也越高</strong>。设样本集合D的类别数为m：<span class="math display">\[\begin{align}Gini(D) &amp;= \sum_{k=1}^m \sum_{k&#39; \ne k} p_kp_k&#39; \\&amp;= 1 - \sum_{k=1}^mp_k^2\end{align}\]</span><strong>注意</strong>：对于任意一种选取的标准指数index，都要求解使index取最大（最小）的属性a，以确定<strong>最优划分属性</strong></p></li></ul><hr><h3 id="三剪枝处理">三、剪枝处理</h3><ul><li><p>剪枝处理的目的：通过<u>主动去掉一些分支</u>，以<strong>降低过拟合的风险</strong></p></li><li><p>剪枝策略：分为“预剪枝”和“后剪枝”</p><ul><li><p>预剪枝：在决策树的<strong>生成过程</strong>中对每个结点<strong>划分前后</strong>的泛化性能进行估计，只有<strong>泛化性能提升</strong>才划分</p><ul><li><p>验证方式：预留一部分数据用作验证集（<strong>留出法</strong>）</p></li><li><p>划分前：根据决策树学习算法，将当前节点的类别标记为<u>其优势类别</u>，再求出<strong>划分前准确度</strong></p></li><li><p>划分后：选择某个属性<u>划分出若干子节点</u>，并如上确定各子节点的类别，再求出<strong>划分后精确度</strong></p><p><strong>注意</strong>：划分后的精确度需要使用<strong>假设进行划分后的所有子节点</strong>对验证集进行预测<br>预剪枝基于“贪心”策略，显著降低了训练和测试时间的开销，但提高了<u>欠拟合</u>风险</p></li></ul><hr></li><li><p>后剪枝：<strong>先从训练集生成完整的决策树</strong>，再依次尝试将各中间节点替换为叶节点（剪去其所有子节点）</p><ul><li><p>验证方式：同“预剪枝”使用<strong>留出法</strong></p></li><li><p>对每一个<u>中间节点</u>：先将其<u>直接替换为叶子节点</u>，再标记为优势类别，最后比较<strong>替换前后在验证集上的精确度</strong>（反复修剪直至<u>泛化能力降低为止</u>）</p><p><strong>注意</strong>：后剪枝策略通常比预剪枝策略保留了更多的分支，<u>欠拟合风险较小</u>，但训练时间开销要大得多（基于完整的决策树）</p></li></ul></li><li><p>奥卡姆剃刀原理：<strong>简单</strong>的模型泛化能力更好（“如无必要，勿增实体”）</p></li></ul></li></ul><hr><h3 id="四连续与缺失值">四、连续与缺失值</h3><ul><li><p>连续属性：属性值的分布是<strong>连续</strong>（而非离散）的</p></li><li><p><u>连续属性</u>向<u>离散属性</u>转化：<strong>二分法</strong>，设样本集D和连续属性集a，a在D上出现了n种不同取值<span class="math inline">\(\{a^1, a^2, ..., a^n\}\)</span></p><p><br>则候选的划分点集合<span class="math inline">\(T_a = \{\frac{a^i +a^{i+1}}{2} | 1 \le i \len-1\}\)</span>，其中n-1个二分取值分别可将数据集D划分为<strong>两个子集</strong></p><p><strong>注意</strong>：连续属性的待选划分点即为<span class="math inline">\(T_a\)</span>，而不是原先离散的a</p><hr></li><li><p>缺失值处理：在属性值缺失的条件下<u>选择划分属性</u>；在划分属性上值缺失该如何<u>划分样本</u></p><ul><li><p>选择划分属性：设数据集D和属性a，令<span class="math inline">\(\overset{\sim}{D}\)</span>表示D中在属性a上<strong>没有缺失值</strong>的样本子集</p><p><br>即<span class="math inline">\(\overset{\sim}{D}\)</span>中的样本在属性a上都有取值</p><ul><li><p>设属性a有V个可取值<span class="math inline">\(\{a^1, a^2, ...,a^V \}\)</span>，</p><p><br>设<span class="math inline">\(\overset{\sim}{D^v}\)</span>表示<span class="math inline">\(\overset{\sim}{D}\)</span>中在属性a上<strong>取值为<span class="math inline">\(a^v\)</span></strong>的样本子集；<span class="math inline">\(\overset{\sim}{D_k}\)</span>表示<span class="math inline">\(\overset{\sim}{D}\)</span>中<strong>属于第k类</strong>的样本子集</p></li><li><p>定义权重：为每个样本x赋予一个<strong>权重<span class="math inline">\(\omega_x\)</span></strong>，并定义： <span class="math display">\[\begin{align}&amp;\rho = \frac{\sum_{x\in \overset{\sim}{D}} \omega_x}{\sum_{x\in D}\omega_x} \quad 即在属性a上无缺失值的样本比重 \\&amp;\overset{\sim}{p_k} = \frac{\sum_{x \in\overset{\sim}{D_k}}\omega_x}{\sum_{x \in \overset{\sim}{D}}{\omega_x}}\quad 即在属性a上无缺失值的样本中第k类所占比重 \\&amp;\overset{\sim}{r_v} = \frac{\sum_{x \in\overset{\sim}{D^v}}\omega_x}{\sum_{x \in \overset{\sim}{D}}\omega_x}\quad 即在属性a上无缺失值的样本中属性取值为a^v所占比重\end{align}\]</span></p></li><li><p>公式<strong>推广</strong>：利用推广公式决定划分属性a</p><p>广义信息熵如下：其中m表示样本集<span class="math inline">\(\overset{\sim}{D}\)</span>中的类别总数 <span class="math display">\[Ent(\overset{\sim}{D}) = -\sum_{k=1}^{m}\overset{\sim}{p_k}log_{2}{\overset{\sim}{p_k}}\]</span> 广义信息增益如下： <span class="math display">\[\begin{align}Gain(D, a) &amp;= \rho \times Gain(\overset{\sim}{D}, a) \\&amp;= \rho \times (Ent(\overset{\sim}{D}) -\sum_{v=1}^V\overset{\sim}{r_v}Ent(\overset{\sim}{D_v}))\end{align}\]</span><strong>注意</strong>：推广公式中的<u>三个调整值</u>都是<strong>无缺失情况</strong>公式的<strong>一般例</strong>（取<span class="math inline">\(\overset{\sim}{D} \ne D\)</span>）</p></li></ul></li></ul><hr></li><li><p>划分样本：设划分属性已经确定为a，解决对样本x的<u><strong>分类问题</strong></u></p><ul><li><p>若样本x在划分属性a上的取值已知，则直接将该样本划入到对应的子节点，其样本权值保持为<span class="math inline">\(\omega_x\)</span></p></li><li><p>若样本x在划分属性a上取值<strong>未知</strong>，则将该样本<strong>同时划入所有子节点</strong></p><p><br>其中对于每个属性值为<span class="math inline">\(a^v\)</span>的子节点，x的样本权值由<span class="math inline">\(\omega_x\)</span>调整为<span class="math inline">\(\overset{\sim}{r_v} *\omega_x\)</span>（样本权重在子节点中依比例收缩）</p></li></ul></li></ul><hr><h3 id="五多变量决策树">五、多变量决策树</h3><ul><li><p>属性空间：每个<strong>属性</strong>对应了空间中的一条<strong>坐标轴</strong></p><p>样本拥有<strong>d个属性</strong>，表明样本是位于<strong>d维空间</strong>的一个坐标点</p><p>对样本分类 <span class="math inline">\(\Leftrightarrow\)</span>寻找样本点集之间的<strong>边界</strong></p></li><li><p><u>单变量</u>决策树：每个中间节点都只基于<u><strong>单个最优属性</strong></u>做出决策</p></li><li><p><u>多变量</u>决策树：每个中间节点可基于<u><strong>多个属性的组合</strong></u>做出决策，如<u>线性分类器</u><span class="math inline">\(\sum_{i=1}^d \omega_ia_i \let\)</span>，其中<span class="math inline">\(\omega_i\)</span>表示属性<span class="math inline">\(a_i\)</span>的<strong>权重</strong></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>machine learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>『computer network-2』data link layer</title>
    <link href="/2024/03/20/computer_network/data-link-layer/"/>
    <url>/2024/03/20/computer_network/data-link-layer/</url>
    
    <content type="html"><![CDATA[<h2 id="数据链路层">数据链路层</h2><h3 id="一数据链路层设计要点">一、数据链路层设计要点</h3><ul><li><p>数据链路层概述</p><ul><li><p>数据链路层在物理层（传输比特流）的基础上实现了<strong>帧</strong>的传输，该层的<strong>协议数据单元PDU</strong>是帧</p></li><li><p>链路：一条<strong>点到点</strong>的物理线路，且中间没有任何其它的交换节点；数据链路：链路+ 协议的硬件和软件</p></li><li><p>信道类型：</p><ul><li>点对点信道：使用<strong>一对一</strong>的点对点通信方式</li><li>广播信道：使用<strong>一对多</strong>的广播通信方式，广播信道上连接多个主机，必须采用专门的<u>共享信道协议</u>协调数据发送</li></ul><hr></li><li><p>封装成帧：保证接收方正确识别<u>帧的边界</u></p><ul><li>字符计数法：在帧头部字段指明<strong>本帧的字节数</strong>，接收方通过该字段得知该接收多少字节</li><li>字符填充的首尾定界法：定义专门的<strong>字符</strong>（SOH,EOT）作为帧的开始/结束标志，并使用<u>字符填充</u>将标志字符与数据<strong>区分开</strong></li><li>比特填充的首尾定界法：定义专门的<strong>比特序列</strong>作为帧的开始/结束标志，并使用<u>比特填充</u>将标志序列与数据<strong>区分开</strong><br><strong>注意</strong>：如果不使用填充方式做<u><strong>转义</strong></u>，数据中的<u>控制字符</u>可能会干扰甚至打断帧在数据链路上的传输</li><li>物理编码违例法：使用<strong>无效的物理编码</strong>作为帧的开始/结束标志，供接收方识别</li></ul></li><li><p>透明传输：借助字符or字节填充，帧中无论出现什么样的比特组合，都能<strong>按照原样无差错</strong>地通过这个数据链路层</p><ul><li>若数据中出现控制字符SOH和EOT，就在其前面插入一个转义字符ESC；接收端删除ESC</li><li>若数据中出现转义字符ESC，就在其前面再插入一个转义字符ESC；接收端删除前面的ESC</li></ul></li></ul></li></ul><hr><h3 id="二错误检测和纠正">二、错误检测和纠正</h3><ul><li><p>误码率（BER）：误码率 = <span class="math inline">\(\dfrac{\text{出错的比特数}}{\text{传送的总比特数}}\)</span>，衡量链路的可靠性</p></li><li><p>循环冗余校验（CRC）：检验比特差错（而非传输差错），通常采用<u>硬件电路</u>生成CRC校验和</p><ol type="1"><li>设生成多项式P有<u>n+1</u>位，发送数据帧M有k位，先在M后补n个0</li><li>令M<strong>除以</strong>生成多项式P（向下采用模二运算、即<strong>异或</strong>），得到<u><strong>n位</strong></u>的余数R（帧检验序列FCS）</li><li>将余数R连接在M的末尾，得到<u>最终发送</u>的帧M'</li><li>接收方接收到M'后除以P，得到余数R'，可断言发送数据无差错 <span class="math inline">\(\Leftrightarrow\)</span> R'=0</li></ol><p><strong>注意</strong>：CRC只能判断发送帧内部是否<strong><u>存在</u>差错</strong>（即检错编码），无法判断具体是哪些比特位出现了差错</p><p><img src="/2024/03/20/computer_network/data-link-layer/CRC.png" width="80%"></p></li><li><p>纠错编码：通过增加冗余信息得知错误的<strong><u>具体</u>位置</strong>，而检错编码只能判断是否存在错误</p><p><strong>注意</strong>：检错码和纠错码可以保证帧的无差错接收（<strong>无比特差错</strong>），<u>但不意味着可靠传输</u>，还可能发生帧丢失、帧重复、帧失序</p></li></ul><hr><h3 id="三基本数据链路协议">三、基本数据链路协议</h3><ul><li><p>无限制的单工协议</p><ul><li><p>假设前提：</p><ul><li>单向传输</li><li>理想信道</li><li>发送方总有数据发送</li><li>接收方总能<strong>及时处理</strong>所收到的数据</li></ul><p><img src="/2024/03/20/computer_network/data-link-layer/无限制单工协议.png"></p></li></ul></li><li><p>单工停-等协议：增加<u>流量控制</u>，防止接收方处理帧速度不及发送方从而导致的<strong>帧丢失</strong></p><ul><li>接收方每<u>收到</u>一帧，都向发送方返回一个<strong>应答帧</strong></li><li>发送方每<u>发送</u>一帧，都先等待来自接收方的<strong>应答帧</strong>，才继续发送</li></ul><p><img src="/2024/03/20/computer_network/data-link-layer/单工停-等协议.png"></p></li><li><p>有噪声信道的单工协议（ARQ协议）：在<u>有噪声信道</u>中防止帧的传输出错</p><ul><li><p>校验和：使接收方能够检测帧<strong>是否出错</strong></p></li><li><p>确认帧：使发送方知道帧已被<strong>正确接收</strong></p></li><li><p>超时重发：发送方在规定时间内未收到确认帧，则<strong>重发帧</strong></p></li><li><p>帧序号：保证接收方不会收到重复帧（若重复接收则丢弃当前重复帧）</p><p><img src="/2024/03/20/computer_network/data-link-layer/有噪声信道的单工协议.png"></p></li></ul></li></ul><hr><h3 id="四滑动窗口协议">四、滑动窗口协议</h3><ul><li><p>ARQ协议的信道利用率 = <span class="math inline">\(\dfrac{\text{T}_D}{\text{T}_D + \text{RTT} +\text{T}_A}\)</span>，分母代表 数据帧发送 <span class="math inline">\(\rightarrow\)</span> 数据帧传播 <span class="math inline">\(\rightarrow\)</span> 应答帧发送 <span class="math inline">\(\rightarrow\)</span> 应答帧传播的<strong>总时间</strong><br><strong>注意</strong>：ARQ协议的<u>等待时间很长</u>，大部分时间都花在RTT上，故其信道利用率较低</p></li><li><p>后退N帧协议：超时只能批量重传</p><ul><li><p>发送方：发送窗口长度 <span class="math inline">\(\in  [1, 2^n -1]\)</span>（n为帧编码位数），表示<strong>允许发送</strong>的帧（包括已经发送的帧）</p></li><li><p>接收方：接收窗口长度 =1，表示<strong>允许接收</strong>的帧（窗口外的帧一律丢弃，直至遇到连续合法的帧）</p><p><img src="/2024/03/20/computer_network/data-link-layer/GBN.png" width="60%"></p><hr></li><li><p>发送过程：</p><ul><li><strong>累积</strong>确认：发送方收到了来自接收方的ACKk，表示<u>k以及k之前的帧</u>已经被<strong>成功接收</strong>，窗口下界挪至第一个未被确认的帧</li><li>超时重传：发送N个数据帧后，若发现N个帧的<strong>前一帧</strong>对应的计时器<strong>超时</strong>后仍未收到其确认信息，<u><strong>重传</strong>出错帧与其后的N个帧</u></li></ul></li><li><p>接收过程：必须保证按序接收，即仅成功接收从头开始的最长连续帧</p><ul><li>如果<strong>正确且按序</strong>收到k号帧，那么接收方为k号帧发送ACKk，单窗口后移一帧</li><li>否则，直接丢弃发送帧，并仅为<strong>最近成功接收的帧</strong>发送ACK；发送方的等待ACK的计时器<strong>超时</strong>后，会<strong>重发</strong>错误帧</li></ul><p><img src="/2024/03/20/computer_network/data-link-layer/GBN发送.png" width="60%"></p></li></ul><hr></li><li><p>选择重传协议：超时可以仅重传异常帧；发送方和接收方的<strong>窗口大小相同</strong></p><ul><li><p>发送方 or 接收方：窗口长度 = <span class="math inline">\(2^{\text{n-1}}\)</span>，其中n为标记帧号所需要的比特位数</p><p><img src="/2024/03/20/computer_network/data-link-layer/SR.png" width="60%"></p><hr></li><li><p>发送过程：</p><ul><li>逐个确认：收到窗口内某个帧的ACK后，就将该帧标记为“已接收”；若该帧是<u>窗口下界</u>，则将窗口右移到<strong>第一个未被确认的帧</strong></li><li>超时重传：每个帧有对应的定时器，一个超时事件发生后<strong>只重传对应的那个帧</strong></li></ul></li><li><p>接收过程：</p><ul><li>来者不拒：收到窗口内的某个帧后，将其<u><strong>缓存</strong></u>并返回对应的<strong>ACK</strong>；若<u>收到连续<strong>下界</strong>帧</u>，就右移窗口下界至<strong>首个未收到的帧</strong></li><li>及时查错：若接收方发现有帧传输<strong>错误</strong>，会及时回复对应的<strong>NAK</strong>，直至错误帧重发前都只回复<u>最近一个正确接收帧</u>的ACK<strong>注意</strong>：NAK可以让错误重传<strong>更及时</strong>，不必让发送方等到ACK超时后才重传（帧丢失只能依靠超时检测重传对应帧）</li></ul></li></ul><p><img src="/2024/03/20/computer_network/data-link-layer/SR发送.png" width="70%"></p></li></ul><p>​<strong>注意</strong>：两种窗口协议都要保证接收方按照<u>帧序号顺序</u>上交网络层</p><hr><h3 id="五点对点协议ppp">五、点对点协议PPP</h3><ul><li><p>PPP协议的组成：PPP协议是一种广泛应用于<strong>点到点链路</strong>的数据传输的<u>数据链路层协议</u></p><ul><li>将<strong>IP数据报</strong>封装成串行链路的方法：IP数据报是PPP帧中的<strong>信息部分</strong>，其长度受最大传送单元<strong>MTU</strong>的限制</li><li>一个链路控制协议（LCP）：用以<u>建立</u>、<u>配置</u>、<u>测试</u>数据链路连接的协议</li><li>一<strong>套</strong>网络控制协议（NCP）：其中每个协议支持不同的网络层协议，如IP、OSI的网络层</li></ul></li><li><p>PPP协议的特点：</p><ul><li><p>设计简单，<strong>无纠错功能、无序号、无流量控制</strong></p></li><li><p>封装成帧（首尾F字段） + 透明传输</p></li><li><p>在同一条物理链路上同时支持多种网络协议（如IP or IPx）</p></li><li><p>支持多种链路（串行or并行、同步or异步、低速or高速、电or光、交换or非交换）</p></li></ul></li><li><p>PPP协议的帧格式：所有PPP帧的长度都是整数字节</p><ul><li><p>标志字段F：首部第一个字段 +尾部最后一个字段，规定为0x7E，用作起始 +结束的<strong>定界符</strong></p></li><li><p>地址字段A：首部第二个字段，规定为0xFF，无实际作用</p></li><li><p>控制字段C：首部第三个字段，规定为0x03，无实际作用</p></li><li><p>协议字段：首部第四个字段，<u>占两个字节</u>，协议字段决定了<strong>信息字段</strong>的数据类型</p><ul><li>0x0021：信息字段是<strong>IP数据报</strong></li><li>0xC021：信息字段是PPP的链路控制协议<strong>LCP</strong>的数据</li><li>0x8021：信息字段是<strong>网络层的控制数据</strong></li><li>0xC023：信息字段是<strong>鉴别数据</strong></li></ul><p><strong>注意</strong>：信息字段（载荷）的长度是<strong>可变</strong>的，<u>不超过1500字节</u></p></li><li><p>帧检验序列：尾部的第一个字段，占两个字节，使用CRC的FCS</p></li></ul><p><img src="/2024/03/20/computer_network/data-link-layer/PPP帧格式.png"></p></li><li><p>字节填充：应用在<strong>异步填充</strong>（逐个字符发送）中，使用字符0x7D对信息字段进行<strong>转义</strong></p><ul><li>信息字段中的0x7E (标志字段) <span class="math inline">\(\Rightarrow\)</span> (0x7D, 0x5E)</li><li>信息字段中的0x7D (转义字符) <span class="math inline">\(\Rightarrow\)</span> (0x7D, 0x5D)</li><li>信息字段中的ASCII控制符 (<span class="math inline">\(\le\)</span>0x20)：如 0x03 <span class="math inline">\(\Rightarrow\)</span> (0x7D,0x23)，注意插入0x7D后要改变原字节</li></ul><p><strong>注意</strong>：接收端只需要进行与发送端<strong>字节填充相反的变换</strong>，就可以正确恢复发送前的信息</p></li><li><p>零比特填充：应用在<strong>同步填充</strong>（一连串比特连续发送）中，即暂时破坏原先的<strong>标志字段0x7E</strong></p><ul><li>发送端：只要发现信息字段中有<u>5个连续1</u>，就立即填入一个0（01111110<span class="math inline">\(\Rightarrow\)</span>011111<strong>0</strong>10）</li><li>接收端：对帧中的比特流进行扫描，每当发现<u>5个连续1</u>时，就把这5个连续1后的一个0<strong>删除</strong></li></ul><hr></li><li><p>PPP协议的工作状态：</p><ol type="1"><li><p>链路静止：PPP链路的起始or终止状态，PC和ISP之间还不存在物理层连接</p></li><li><p>链路建立：双方建立了物理层连接后，进入"链路建立"状态，目的是<u>建立链路层的LCP连接</u></p><ul><li>配置请求帧：一种PPP帧，其协议字段为<strong>0xC021</strong>，其信息字段为特定的<strong>配置请求</strong>；另一端可返回如下相应<ul><li>配置确认帧：所有选项都接受</li><li>配置否认帧：所有选项都理解，但都不接受</li><li>配置拒绝帧：选项中有的无法识别或不能接收，需要协商</li></ul></li><li>配置选项：包括链路最大帧长、鉴别协议的规约、不使用地址和控制字段</li></ul><p>协商结束后，双方建立LCP链路，进入"鉴别"状态</p></li><li><p>鉴别：双方建立了LCP链路后，进入”鉴别状态“；PPP支持以下两种<strong>身份认证协议</strong>：</p><ul><li>口令鉴别协议(PAP)：发起通信的一方需要发送<u>身份标识符和口令</u>，允许用户重试多次</li><li>口令握手鉴别协议(CHAP)：比PAP更复杂，安全性更好</li></ul><p>鉴别失败，则转入”链路终止“状态；鉴别成功，则转入”网络层协议“状态</p></li><li><p>网络层协议：PPP链路两端的NCP根据<u>网络层的不同协议</u>互相交换<strong>特定的NCP分组</strong>若上层运行的是IP协议，则为PPP链路的两端<strong>配置IP协议模块</strong>时就要使用NCP中的IPCP协议，其分组被封装成<strong>PPP帧</strong>（0x8021）</p></li><li><p>链路打开：网络层配置好后，链路两个PPP端点可以彼此向对方发送分组，或<u>回送请求LCP</u> or <u>回送回答LCP</u>以<strong>检查链路状态</strong></p></li><li><p>链路终止：数据传输结束后，一方发送<u>终止请求LCP</u>，收到<u>终止确认LCP</u>后转入“链路终止”状态；链路故障时也会转入“链路终止”</p></li></ol><p><img src="/2024/03/20/computer_network/data-link-layer/PPP.png" width="70%"></p></li></ul><hr><h3 id="六使用广播信道的数据链路层">六、使用广播信道的数据链路层</h3><ul><li><p>局域网的数据链路层：</p><ul><li>局域网的特点：网络被一个单位所拥有，且地理范围和站点数目均有限</li><li>局域网使用的信道类型：<strong>广播信道</strong>，其拓扑结构包括<u>环形网</u>、<u>星形网</u>、<u>总线网</u></li></ul></li><li><p>划分信道方式：让多用户合理方便地<strong>共享</strong>通信媒体资源</p><ul><li>静态划分信道：频分复用 + 时分复用 + 波分复用 + 码分复用<ul><li>特点：代价较高，不适合局域网使用</li></ul></li><li>动态介质访问控制：即多点接入，信道并非固定分配给用户（随机访问使用较多）<ul><li>随机访问：所有用户可随时发送消息，可能导致在共享媒体上发生碰撞；CSMA/CD(以太网)or CSMA/CA(无线网)</li><li>受控访问：用户发送消息必须服从一定控制；多点线路<strong>探询</strong></li></ul></li></ul><hr></li><li><p>局域网技术标准：</p><ul><li><p>LLC与MAC：IEEE802标准将局域网数据链路层分为<strong>逻辑链路控制子层</strong> +<strong>介质访问控制子层</strong></p><ul><li><p>逻辑链路控制子层(LLC)：存放与<u>传输媒体无关</u>的内容，屏蔽局域网底层差异；传输媒体和MAC层均对LLC透明</p></li><li><p>介质访问控制子层(MAC)：存放与接入到<u>传输媒体有关</u>的内容，不同局域网采用不同的MAC方法</p></li></ul></li></ul><p><img src="/2024/03/20/computer_network/data-link-layer/技术标准.png"></p><ul><li><p>IEEE 802.3：CSMA/CD介质访问控制 + 物理层技术规范，包括：</p><ul><li>IEEE 802.3u：快速以太网</li><li>IEEE 802.3z：千兆以太网</li></ul></li><li><p>IEEE 802.11：无线局域网介质访问控制与物理层技术规范</p></li></ul></li></ul><hr><ul><li><p>载波监听多点接入/碰撞检测（CSMA/CD）协议：只能进行<u>半双工通信</u>（双向交替通信）</p><ul><li><p>多点接入：<strong>总线型</strong>网络，许多计算机以多点接入的方式连接在一根总线上</p></li><li><p>载波监听：节点在 <u>发送数据前</u> + <u>发送数据时</u>检测总线上是否有其它节点正在发送数据；若其它站正在发送数据就<strong>暂时不发送</strong></p></li><li><p>碰撞检测：节点<u>边发送数据边检测</u>信道上是否发生了碰撞；若其它站也在发送就立即<strong>中断</strong>本站发送<br><strong>注意</strong>：若至少有两个站同时在发送数据，总线电压会因为互相叠加而增大变化幅度</p></li><li><p>碰撞强化：发送方<strong>检测到信号碰撞后</strong>，<u>立即停止发送</u>，并发送32or48bit 的<u>干扰信号</u>，让所有用户都知道发生了碰撞</p></li><li><p>碰撞避退：采用<strong>截断二进制指数退避算法</strong>，生成最小退避时间的站最先获得发送权</p><ul><li>倍数r = 0, 1, ..., <span class="math inline">\(2^k - 1\)</span>中<u><strong>随机</strong>选取一个数</u>，其中 k = min(当前重传次数,10)</li><li>退避时间T = 2<span class="math inline">\(\tau\)</span> <span class="math inline">\(\times\)</span><strong>r</strong>，检测到碰撞后，经过退避时间T后才重发，<u>避免再次碰撞</u></li></ul><p>重传次数 <strong>&gt;16</strong>后，丢弃该帧，并向上层报告（表明同时打算发送数据的站太多）</p><p><img src="/2024/03/20/computer_network/data-link-layer/碰撞.png"></p></li><li><p>争用期：即碰撞窗口，时长 = <span class="math inline">\(2\tau\)</span></p><ul><li>若<u>过了争用期</u>仍未检测到碰撞，就肯定没发生碰撞</li><li>争用期内检测到冲突时，<strong>立即停止发送</strong></li></ul></li><li><p>最小帧长：<span class="math inline">\(2\tau\)</span> <span class="math inline">\(\times\)</span> 数据传输率，以太网数据传输率取10Mbit/s</p><ul><li>小于最小帧长的帧是<strong>因冲突而截断</strong>的<u>无效帧</u></li><li>如果发送帧内容小于最小帧长，要加入<u>填充字节</u></li></ul><p><strong>注意</strong>：以太网的最小帧长 = 64B = 512b，规定争用期 =51.2us，发送最小帧长的时间 = 争用期</p><hr></li><li><p>极限信道利用率 = <span class="math inline">\(\dfrac{\text{T}_0}{\text{T}_0 + \tau} =\dfrac{1}{1 + a}\)</span>，其中 <span class="math inline">\(\tau\)</span> 为单项传播时间，<span class="math inline">\(\text{T}_0\)</span> 为发送时间，<span class="math inline">\(a = \dfrac{\tau}{\text{T}_0}\)</span>；a <span class="math inline">\(\rightarrow\)</span> 0说明一旦碰撞就能检测出来</p></li><li><p>CSMA/CD协议的特点：</p><ul><li>优点：<ul><li>网络负载较<strong>轻</strong>时效率高</li><li>硬软件实现简单、灵活</li></ul></li><li>缺点：<ul><li>网络负载较<strong>重</strong>时，<u>碰撞发生概率增大</u>，网络效率较低</li><li>由于存在<u>多次冲突</u>的可能，数据从发送方到接收方的时间缺少保证，<strong>实时性较差</strong></li></ul></li></ul></li></ul></li></ul><hr><h3 id="七以太网">七、以太网</h3><ul><li><p>以太网物理层：使用便宜灵活的非屏蔽<strong>双绞线</strong>，使用<strong>集线器</strong>连接各个节点，物理上呈<u>星形结构</u></p><ul><li>10Base-T技术：10Mbit/s + 基带传输 +双绞线，用于星形局域网，使用方便但通信距离稍短（两站间距 <span class="math inline">\(\le\)</span> 200m）</li><li>集线器：采用星形拓扑结构组成的局域网，在<u>星形的中心</u>设置的高可靠的收发设备<ul><li>使用集线器的以太网在<u>逻辑上</u>仍是一个<strong>总线网</strong>，各站均使用CSMA/CD协议（同一时刻最多允许一个站发送数据）</li><li>集线器很像一个多端口的<u>转发器</u>，一个端口使用两对双绞线与一台计算机的适配器连接</li><li>集线器工作在<strong>物理层</strong>，每个端口仅简单转发比特，而<u>不进行碰撞检测</u></li></ul></li><li>曼彻斯特编码：用<strong>电平跳变</strong>表示 0 or1，即每个码元都有电平跳变</li></ul></li><li><p>以太网MAC层：采用CSMA/CD介质访问控制协议</p><ul><li><p>MAC地址：表示某个站的"标识符"；占48bit，高24bit表示厂商标识符、低24bit由厂商自行分配</p><ul><li><p>全球每个网络接口具有<strong>唯一</strong>的MAC地址</p></li><li><p>MAC地址固化在网卡的ROM中</p></li></ul><p><strong>注意</strong>：若一个主机或路由器安装有多个适配器，这台设备就拥有多个"地址"</p></li><li><p>适配器（adapter）：进行 串行数据(主机外) <span class="math inline">\(\Leftrightarrow\)</span> 并行数据(主机内)的转化</p><ul><li><p>发送数据：以太网总线上的所有节点都能收到帧</p></li><li><p>过滤数据：根据MAC帧中的<strong>MAC地址</strong>判断是否是发往本站的帧：</p><ul><li>单播：收到帧的MAC地址 = 本站MAC地址（一对一）</li><li>广播：发送给本局域网上<u>所有站点</u>的帧（一对全体）</li><li>多播：发送给本局域网上<u>一部分站点</u>的帧（一对多）</li></ul><p><img src="/2024/03/20/computer_network/data-link-layer/适配器.png" width="80%"></p><p><strong>注意</strong>：若适配器受到有差错的帧，就把该帧直接丢弃无需通知CPU；若受到正确帧，就用<strong>中断</strong>通知CPU</p></li></ul></li><li><p>MAC帧的帧格式：5个字段</p><ul><li>目的地址 + 源地址：各6字节的MAC地址</li><li>类型：2字节，标明上层协议的类型</li><li>数据：网络层数据报，46 ~1500字节（可变长，46=64-len(首部)-len(尾部FCS), 1500同理）</li><li>FCS：4字节，帧校验序列，采用<strong>CRC</strong>校验</li></ul><p><img src="/2024/03/20/computer_network/data-link-layer/MAC帧.png" width="80%"></p><p><strong>注意</strong>："前同步码"的作用在于接收MAC帧时能够迅速<u>调整时钟频率</u>，与发送端实现<strong>比特同步</strong>；SONET/SDH无需同步码</p></li></ul></li><li><p>高速以太网：<strong>传统以太网</strong>的数据率只有10Mbit/s</p><ul><li><p>快速以太网：IEEE802.3u标准、传输速率100Mb/s，在半双工模式下必须使用CSMA/CD协议（全双工反而不用）</p></li><li><p>千兆以太网：IEEE802.3z标准、传输速率1Gb/s，在半双工模式下必须使用CSMA/CD协议（全双工反而不用）</p><ul><li>载波延伸：由 <span class="math inline">\(a =\dfrac{\tau}{\text{T}_0}\)</span> 可知，要想让 a 减小，可以增大 <span class="math inline">\(\text{T}_0\)</span>，即增大争用期至512B（原64B），但额外填充开销较大</li><li>分组突发：第一个帧采用"载波延伸"方法填充，后面的短帧一个接一个地发送（保证短帧之间的最小间隔）</li></ul><p><strong>注意</strong>：全双工模式下，吉比特以太网不需要使用以上两种方法降低参数a 的值</p></li><li><p>万兆以太网：IEEE802.3ae标准、传输速率10Gb/s，只工作在全双工模式下（无需CSMA/CD协议）</p></li></ul></li></ul><hr><h3 id="八局域网互连">八、局域网互连</h3><ul><li><p>在物理层扩展局域网：使用<strong>集线器</strong>实现局域网在物理层的（多级结构）互连</p><ul><li><p>优点：可以<strong>方便</strong>地实现网络的扩展、且<strong>成本较低</strong></p></li><li><p>缺点："碰撞域"指的是在同一时刻域内至多仅有一个站可发送数据</p><ul><li>碰撞域扩大至原先各子域的并集、<u>碰撞发生概率增大</u>、可能影响网络性能</li><li>若不同局域网使用不同的以太网技术，就不能使用集线器将各局域网连接</li></ul><p><strong>注意</strong>：扩展后的局域网数据率 = <span class="math inline">\(\min\)</span>(各站集线器的转发数据率)</p></li></ul></li><li><p>在数据链路层扩展局域网：使用<strong>网桥</strong>实现局域网在数据链路层的互连（比物理层扩展更常用）</p><ul><li><p>网桥：工作在数据链路层，对收到的帧进行<strong>转发</strong>和<strong>过滤</strong>，后被以太网交换机淘汰</p><ul><li><p>转发：根据MAC帧的目的地址，查找<strong>网桥地址表</strong>，确定将该帧转发至哪个接口（而不是转发到<u>所有接口</u>）</p></li><li><p>过滤：不转发，直接<strong>丢弃</strong>MAC帧</p></li><li><p>优势：</p><ul><li><p><strong>过滤</strong>通信量、增大吞吐量</p></li><li><p>扩大了<u>物理范围</u></p></li><li><p>提高了<u>可靠性</u></p></li><li><p>可互连不同物理层、不同MAC子层和不同速率的互联网（优于物理层的集线器）</p></li></ul></li><li><p>局限性：</p><ul><li>存储转发<u>增加了时延</u>，一次只能分析并转发一个帧</li><li>在MAC子层中并<u>没有流量控制</u>功能</li><li>网桥只适合于 <u>用户不多</u> 且 <u>通信量不太大</u> 的局域网</li></ul></li></ul><hr></li><li><p>以太网交换机：<strong>多端口网桥</strong>，一个网络端口可连接<u>主机</u>or <u>其它交换机</u>，N个端口<span class="math inline">\(\Leftrightarrow\)</span> N个碰撞域</p><ul><li><p>以太网交换机的特点：</p><ul><li>采用<strong>全双工</strong>方式，多主机可同时通信（不受CSMA/CD约束）；相互通信的主机<strong>独占传输媒体</strong>，无碰撞地传输数据</li><li>拥有存储器，能在输出端口繁忙时把发来的帧进行<strong>缓存</strong></li><li>即插即用，内部交换表通过<strong>自学习算法</strong>逐步建立</li></ul><p><strong>注意</strong>：交换机使用<strong>两对线</strong>，支持同时发送和接收帧，故不受CSMA/CD的限制，传输距离也够长</p></li><li><p>与集线器的区别：</p><ul><li>交换机工作在数据链路层，集线器工作在物理层；交换机的每个接口为一个碰撞域（网段），可大幅提高网络性能</li><li>交换机的每个接口<strong>独享</strong>带宽（各主机独占传输媒体），集线器的所有接口<strong>共用</strong>传输介质的带宽</li><li>交换机的一个端口对应一个冲突域；集线器连接的各网络构成一个冲突域（一次仅允许一个站发送）</li></ul></li><li><p>自学习过程：交换表记录了 MAC地址 <span class="math inline">\(\rightarrow\)</span> 端口号的<strong>映射</strong>；设A向B途经交换机发送一帧</p><ol type="1"><li>填表：若无表项(A, A的端口号)，填写该表项（自学习过程）</li><li>转发：若无表项(B,B的端口号)，向除了“A端口”的<u>所有端口</u>广播；否则只向B端口转发即可&lt;<br><strong>注意</strong>：如果MAC目的地址与接收方地址不匹配，会被接收方<strong>过滤</strong></li><li>刷新：每个写入项目预设有生存时间（改变端口连的主机 or主机更换adapter），超过生存时间该项就自动被删除</li><li>直通：将收到的帧<strong>直接转发</strong>，无需先存储后转发（提高转发速度）</li></ol></li><li><p>透明网桥生成树算法：多个局域网互连可能形成<u>环路</u>（存在交换机互连），应避免帧的<strong>无休止绕环转发</strong></p><ul><li>生成树协议STP：不改变实际的网络拓扑，而是<u>切断某些链路</u>，形成<strong>无环路树状结构</strong></li><li>广播风暴：某些站点<u>频繁发送广播帧</u>，导致网络拥塞</li></ul></li></ul><p><strong>注意</strong>：通过交换机（网桥）互连的一组主机构成<u><strong>广播域</strong></u>；交换机（网桥）的一个端口构成一个<u><strong>冲突域</strong></u></p><hr></li><li><p>虚拟局域网(VLAN)：在现有局域网的基础上，通过将网络站点<u>分组</u>，构成若干<strong>逻辑上独立</strong>的虚拟局域网</p><ul><li><p>VLAN的优势：提高安全性 +控制广播风暴（大量广播帧在网络中无限制兜圈子，消耗整个带宽资源）</p></li><li><p>VLAN划分规则：按 交换机端口、MAC地址、协议等进行<strong>逻辑分组</strong>；每个VLAN内部构成一个<u><strong>广播域</strong></u>（无法跨VLAN广播）</p></li><li><p>802.1Q帧：在以太网帧中<u>类型字段前</u>新插入一个4字节的<strong>VLAN标签</strong></p><p><img src="/2024/03/20/computer_network/data-link-layer/802.1Q帧.png"></p></li><li><p><strong>同</strong>交换机下同VLAN内的转发：普通以太网中的帧转发（#1根据帧首部目的MAC得知其属于VLAN-10），<u>无需使用VLAN标签</u></p></li><li><p><strong>跨</strong>交换机下同VLAN内的转发：#1<strong>插入</strong>VLAN标签（指导#2转发给VLAN-10），#2<strong>删除</strong>VLAN标签（形成标准以太帧）</p><p><img src="/2024/03/20/computer_network/data-link-layer/VLAN.png"></p></li></ul></li></ul></li></ul><p>​<strong>注意</strong>：<u>同一VLAN</u>下的主机可以接入<strong>不同的交换机</strong>，不同VLAN（即不同网络）下的主机转发帧需要借助网络层的<strong>路由器</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>computer network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>『computer network-1』physical layer</title>
    <link href="/2024/03/14/computer_network/physical-layer/"/>
    <url>/2024/03/14/computer_network/physical-layer/</url>
    
    <content type="html"><![CDATA[<h2 id="物理层">物理层</h2><h3 id="一物理层的基本概念">一、物理层的基本概念</h3><ul><li>物理层的主要任务：在传输介质上传输比特流</li><li>物理层的四个特性：<ul><li>机械特性：<strong>接口</strong>所用的<u>接线器的形状or尺寸</u>，<u>引线数目和排列</u>，<u>固定和锁定装置</u>等</li><li>电气特性：在接口电缆的各条线上出现的<u>电压的<strong>范围</strong></u></li><li>功能特性：某条线上出现的某一电平的<u>电压表示何种<strong>意义</strong></u></li><li>过程特性：对于不同功能的各种可能<u>事件的出现<strong>顺序</strong></u></li></ul></li></ul><hr><h3 id="二数据通信的基础知识">二、数据通信的基础知识</h3><ul><li><p>信道：向某一方向传送信息的<strong>介质</strong></p></li><li><p>消息：通信的目的是<u>传送<strong>消息</strong></u>，如话音、文字、图像等；消息的实体是<strong>数据</strong></p></li><li><p>信号：数据的电气or电磁表现，分为模拟信号和数字信号两大类</p><ul><li><p>模拟信号：连续信号，代表消息的参数取值是连续的</p></li><li><p>数字信号：离散信号，代表消息的参数取值是离散的</p></li></ul></li><li><p>码元：在<u>时域</u>波形数字信号中，<u>代表<strong>不同</strong>离散数值的<strong>基本波形</strong></u>为码元</p><ul><li>码元速率：单位时间内通过信道的<strong>码元个数</strong>，单位为波特（baud）</li><li>数据速率：单位时间内通过信道的信息量（<strong>比特数</strong>），单位为（b/s）</li></ul><p><strong>注意</strong>：对于同一信道，使用<strong>二进制编码</strong>（仅有两种状态）<span class="math inline">\(\Leftrightarrow\)</span> 码元速率 = 数据速率<br>我们希望提高一个码元的比特数，以提高<strong>数据速率</strong>；但一个码元的比特数越多，解码难度与抗干扰难度就越大</p><hr></li><li><p>通信双方的交互方式</p><ul><li><p>单向通信（单工通信）：只能向一个方向通信且<u>没有反方向的交互</u>（如广播）</p></li><li><p>双向交替通信（半双工通信）：通信双方都可以发送消息，但<u>不能双方同时</u>发送or接收</p></li><li><p>双向同时通信（全双工通信）：通信双方<u>可以同时</u>发送or接收消息</p><p><strong>注意</strong>：单工通信仅需要一条信道，双工通信都需要两条信道</p></li></ul></li><li><p>数据通信系统模型：</p><figure><img src="/2024/03/14/computer_network/physical-layer/传输系统.png" alt="图片"><figcaption aria-hidden="true">图片</figcaption></figure></li><li><p>基带信号与带通信号</p><ul><li>基带信号：来自<strong>信源</strong>的信号，其往往含有较多低频成分（甚至有直流成分），必须对基带信号进行<strong>调制</strong>，才能使其在信道上传输</li><li>带通信号（仅在一段频率范围内可通过信道）：基带信号经过<u>载波调制</u>后，信号频率范围搬移到<strong>较高的频段</strong>，以便在信道中传输</li></ul></li><li><p>调制方法：主要分为以下两类</p><ul><li><p>基带调制：数字信号 编码成另一种数字信号，变换后的信号<strong>仍是基带信号</strong></p><ul><li><p>不归零制：正电平 <span class="math inline">\(\Rightarrow\)</span>1，负电平 <span class="math inline">\(\Rightarrow\)</span>0；没有自同步能力</p></li><li><p>归零制：位中心正脉冲 <span class="math inline">\(\Rightarrow\)</span> 1，位中心负脉冲 <span class="math inline">\(\Rightarrow\)</span> 0</p></li><li><p>曼彻斯特编码：位中心上跳 <span class="math inline">\(\Rightarrow\)</span> 1，位中心下跳 <span class="math inline">\(\Rightarrow\)</span>0；具有自同步能力，比不归零制的频率高</p></li><li><p>差分曼彻斯特编码：位开始边界跳变 <span class="math inline">\(\Rightarrow\)</span> 1，位开始边界不跳变 <span class="math inline">\(\Rightarrow\)</span>0；每个位中心都会跳变</p></li></ul></li><li><p>带通调制：使用载波进行调制，将基带信号搬运到较高频段 +转换为模拟信号</p><ul><li><p>调幅：载波的<strong>振幅</strong>随基带数字信号而变化</p></li><li><p>调频：载波的<strong>频率</strong>随基带数字信号而变化</p></li><li><p>调相：载波的<strong>初始相位</strong>随基带数字信号而变化</p></li></ul><figure><img src="/2024/03/14/computer_network/physical-layer/调制.png" alt="图片"><figcaption aria-hidden="true">图片</figcaption></figure></li><li><p>多元制的混合调制方法：可获得<u>更高的传输速率</u>，如<strong>正交振幅调制</strong>（振幅与相位相结合）</p></li></ul></li></ul><hr><ul><li><p>信道极限容量：</p><ul><li><p>信号失真问题：任何实际信道都是不理想的；<u>码元传输速率越高</u>or <u>信号传输距离越远</u> <span class="math inline">\(\Rightarrow\)</span>输出端波形<strong>失真越严重</strong></p></li><li><p>信道能够通过的频率范围：具体信道所能通过的<strong>频率范围是有限</strong>的，高频分量往往不能通过信道，不然会导致“<strong>码间串扰</strong>”</p></li><li><p>奈奎斯特定理：理想低通信道最大数据传输率 = <span class="math inline">\(2\text{H}\log_2 \text{V}\)</span>(bps)，H是信道带宽(Hz)、V是信号状态数<br><strong>注意</strong>：<u>信道频带<strong>越宽</strong></u>，高频分量就越多，<u>传输速率就可以<strong>越高</strong></u>（而不出现码间串扰）</p></li><li><p><span class="math inline">\(\text{bit rate}\)</span> = <span class="math inline">\(\text{2H} \log_2\text{V}\)</span>，其中H是带宽(Hz,Nyquist准则)，V是表示状态数（码元种类数，如4个状态需要2位编码）</p><hr></li><li><p>信噪比：信号的平均功率和噪声的平均功率之比，计算式 = <span class="math inline">\(10 \log_{10} (\dfrac{\text{S}}{\text{N}})\)</span>(dB)，描述信号与噪声的<strong>相对强度</strong></p></li><li><p>香农公式：信道<strong>极限</strong>信息传输速率 <span class="math inline">\(\text{C} = \text{W} \log_2 (1 +\dfrac{\text{S}}{\text{N}})\)</span> (bps)，W是信道带宽(Hz)、<span class="math inline">\(\dfrac{\text{S}}{\text{N}}\)</span> 是信噪比<br>香农公式意义：只要信号传输速率低于信道极限传输速率，就一定存在某种方法实现<strong>无差错传输</strong></p></li></ul></li></ul><hr><h3 id="三物理层下面的传输介质">三、物理层下面的传输介质</h3><ul><li><p>传输介质：数据传输系统中<u>发送器</u>和<u>接收器</u>之间的<strong>物理通路</strong></p></li><li><p>导引型传输介质：电磁波被导引沿着<strong>固体媒体</strong>传播</p><ul><li><p>双绞线：将两根绝缘铜线绞合，减少互相干扰</p><ul><li>特点：<u>价格便宜</u>，<u>传输距离短</u>，在网络时代前广泛应用于电话系统</li></ul><p><strong>注意</strong>：当传输速率增高时，可以使用<strong>屏蔽</strong>双绞线</p></li><li><p>同轴电缆：内导体铜质芯线外包裹网状编织的<strong>屏蔽层</strong></p><ul><li>特点：<u>抗干扰能力</u>和<u>传输速率</u>均高于双绞线，但造价较高</li></ul></li><li><p>光纤：由非常透明的<strong>石英玻璃</strong>拉成细丝，由<u>纤芯</u>和<u>包层</u>构成双层通信圆柱体，广泛用于<strong>长途干线传输</strong>，高宽带且可靠的网络连接</p><ul><li>优点：通信容量大、传输损耗小、抗干扰能力强、保密性好、体积小，重量轻</li><li>缺点：安装较为复杂，需依靠光电转换</li></ul></li></ul></li><li><p>非导引型传输介质：指可以<u>传播无线电波</u>的<strong>自由空间</strong>，适用于偏远地区通信、城市中敷设电缆困难的场所、<strong>移动设备</strong>等</p><ul><li>短波通信：通过<u>电离层反射</u>、传输距离长、通信质量较差、传输速率低（电离层不稳定）</li><li>微波通信与卫星通信：频率大于100MHz的电波几乎按<strong>直线</strong>传播，信噪比极高<ul><li>地面微波通信：每隔一定距离建立<strong>中继站</strong>，接力转发（"微波接力"）<ul><li>优点：信道频段范围宽、通信容量大；抗干扰能力强，成本低且建设速度快</li><li>缺点：相邻站需直视（无障碍）、易受地理或建筑物影响；易受气候影响；隐蔽性和保护性差</li></ul></li><li>卫星通信：通过<strong>卫星</strong>进行微波信号转发<ul><li>特点：通信距离远、覆盖范围广、通信容量大；但传播<u>时延较大</u></li><li>低轨道卫星：造价与发射成本较低、传输距离较短，时延相对较小（可与地面手持设备通信），<u>发展较快</u></li></ul></li><li>红外通信和激光通信：易受天气和可见光影响，通常用于<u>近距离</u>或<u>室内通信</u></li></ul></li></ul></li></ul><hr><h3 id="四信道复用技术">四、信道复用技术</h3><ul><li><p>频分复用与时分复用：在<u>一个信道</u>上传输多路信号，通过成对的<strong>复用器</strong>和<strong>分用器</strong>实现</p><ul><li><p>频分复用（FDM）：不同用户占用<strong>不同频带</strong>资源，每路信号以不同载波频率进行调制</p></li><li><p>时分复用（TDM）：将时间划分成一段段<strong>等长的时隙</strong>，所有用户在不同时间占用<u>相同的频带宽度</u>；接收端采用同步技术<br><strong>注意</strong>：TDM的轮转时隙数量 =用户总数，这种固定的分配方式会造成资源的浪费</p><figure><img src="/2024/03/14/computer_network/physical-layer/信道复用.png" alt="图片"><figcaption aria-hidden="true">图片</figcaption></figure></li><li><p>统计时分复用（STDM）：为每个用户动态按需分配时隙，可显著提高信道利用率</p><ul><li>每个用户<strong>独立</strong>往发送缓存队列中填入数据</li><li>发送器扫描缓存队列：若当前缓存块中有数据，就将其填入STDM帧中；<strong>一个STDM帧满了</strong>，就把该帧发送出去</li></ul><p><strong>注意</strong>：相较于普通的TDM，STDM的时隙<u>不是固定分配</u>给每个用户的；一个STDM帧长度&lt; 用户数量</p></li></ul></li><li><p>波分复用（WDM）：即<u>光</u>的<strong>频分复用</strong>，一根光纤上传输两路光载波信号<strong>密集</strong>波分复用（DWDM）：在一根光纤上复用更多路光载波信号</p></li><li><p>码分复用（CDM）：又被称为码分多址(CDMA)，各发送端使用相互正交的地址码调制发送信号</p><ol type="1"><li><p>每个比特被分为m个更短的间隔，每个间隔(1or-1)被称为码片（直接序列扩频） <br><strong>注意</strong>：实际发送数据率提高到 mbbit/s，所占用频带宽度实际提高 m 倍</p></li><li><p>每个站被分配一个<u>唯一</u>的m比特的<strong>码片序列</strong>，各站的码片序列必须<strong>相互正交</strong>，且<strong>相同码片规格化内积为1</strong></p></li><li><p>接收方T持有发送方的码片序列S，发送方发送的扩频信号为 <span class="math inline">\(\text{S}_x\)</span> 则接收方收到的扩频信号 = <span class="math inline">\(\text{S} \cdot (\text{S}_x + \text{othersignals})\)</span> = <span class="math inline">\(\text{S} \cdot\text{S}_x\)</span> + <strong>0</strong> = +1(发送了1) or-1(发送了0)</p><figure><img src="/2024/03/14/computer_network/physical-layer/CDMA.png" alt="图片"><figcaption aria-hidden="true">图片</figcaption></figure></li></ol><p><strong>注意</strong>：利用CDMA，网络中各用户可以使用同一载波，占用相同带宽、各用户可以<u><strong>同时</strong></u>发送or接收信号</p></li></ul><hr><h3 id="五数字传输系统">五、数字传输系统</h3><ul><li><p>早期数字传输的缺点 与 解决方案：</p><ul><li><p>缺点：速率标准不统一（国际范围的高速数据传输难以实现）；非同步传输（收发双方时钟同步问题）</p></li><li><p>解决方案：SONET + SDH，用于高速干线传输（特别是光纤传输）</p><ul><li>SONET（同步光纤网）：同步网络中的各级时钟来自一个非常精确的主时钟；定义了同步传输的线路速率等级结构<ul><li>第1级同步传送信号(STS-1)：SONET传输速率以STS-1为基础(51.840Mbit/s)，对应了电信号</li><li>第1级光载波(OC-1)：速率与STS-1相同，对应了光信号</li></ul></li><li>SDH（同步数字系列）：一般认为与SONET同义<ul><li>第1级同步传递模块(STM-1)：SDH传输速率以STM-1为基础(155.520Mbit/s)，相当于SONET中的OC-3</li></ul></li></ul><p><strong>注意</strong>：STS-n = OC-n，且 STS-n 速率为 STS-1 的 n倍</p></li></ul></li><li><p>脉码调制系统（PCM）：用于<strong>电话交换系统</strong>，实现话音由<u>模拟</u>到<u>数字</u>信号的变换；数字化的话音数据进行<strong>时分多路复用</strong></p><p><strong>注意</strong>：数字通信在传输质量 +经济上都明显优于模拟通信</p></li></ul><hr><h3 id="六宽带接入技术">六、宽带接入技术</h3><ul><li><p>ADSL技术：即非对称数字用户线</p><ul><li><p>ADSL特点：</p><ul><li><p>仍使用现有电话线，无需对原先庞大的电话布线系统进行改造</p></li><li><p>将 0 ~ 4kHz 低频频谱留给<strong>传统电话</strong>，把高端频谱40kHz ~ 1100kHz 用作<strong>网络接入</strong></p></li><li><p><strong>带宽非对称</strong>，即上行（用户 <span class="math inline">\(\rightarrow\)</span> ISP）带宽 <u>远小于</u>下行带宽（ISP <span class="math inline">\(\rightarrow\)</span>用户）</p><p><strong>注意</strong>：数据率越高，ADSL传输距离越短；用户线径越细，ADSL传输距离越短</p></li></ul></li><li><p>DMT调制技术：<u><strong>频分复用</strong></u>，将40kHz ~1.1MHz的高端频谱划分为多个子信道，每个子信道约4kHz宽</p><ul><li>25个子信道用于上行信道，并使用不同的载波进行<strong>数字调制</strong></li><li>249个子信道用于下行信道，并使用不同的载波进行<strong>数字调制</strong></li><li>用户线彼此差异很大，ADSL采用<strong>自适应调制技术</strong>使用户线能够传送尽可能高的数据率</li></ul><p><strong>注意</strong>：ADSL定义的传输速率是可能达到的<strong>最高传输速率</strong>，实际传输速率与<u>用户线路的<strong>质量</strong>和<strong>距离</strong></u>相关</p><hr></li><li><p>优点：可承载宽带业务、成本低、易于实现</p></li><li><p>缺点：带宽和质量差异性较大</p></li></ul></li><li><p>HFC技术：即<u>光纤</u>混合<u>同轴</u>网，在有线电视网CATV的基础上开发，能够提供<u>电话</u>、<u>数据</u>和<u>其它宽带</u>交互型业务</p><ul><li>改进：以CATV为基础的宽带接入技术<ul><li>单项广播式传输 <span class="math inline">\(\Rightarrow\)</span>具有<strong>双向传输</strong>功能，且扩展了传输频带</li><li>传输电视信号 <span class="math inline">\(\Rightarrow\)</span>可以传输电视、话音、数据等</li><li>以同轴电缆为主 <span class="math inline">\(\Rightarrow\)</span>改用<strong>光纤</strong> + 同轴电缆</li></ul></li><li>特点：<ul><li>同轴电缆主干线路采用<strong>光纤</strong></li><li>采用结点体系结构</li><li>具有比CATV网更宽的频谱，具有双向传递功能</li></ul></li></ul><figure><img src="/2024/03/14/computer_network/physical-layer/光纤同轴混合网.png" alt="图片"><figcaption aria-hidden="true">图片</figcaption></figure><ul><li>优点：频带很宽，并能利用<strong>已有的相当大</strong>的覆盖面的有线电视网</li><li>缺点：要将现有的<u>450MHz单向传输有线电视网</u> 改造为<u>750MHz双向传输HFC网</u> 需要相当的资源和时间</li></ul></li><li><p>FTTx技术：基于光纤的宽带接入（Fiber To The ...）</p><ul><li><p>FFTH：光纤到户，<strong>无源光网络</strong>（PON）采用了光纤到户技术（光纤配线网中无需供电、上下行使用<u>波分复用</u>）</p></li><li><p>FFTB：光纤到大楼</p></li><li><p>FFTC：光纤到路边</p><hr></li><li><p>优点：可提供最好的带宽和质量</p></li><li><p>缺点：现阶段线路工程成本太大</p></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>computer network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>『cyber security-1』encryption algorithm</title>
    <link href="/2024/03/12/cyber_security/encryption-algorithm/"/>
    <url>/2024/03/12/cyber_security/encryption-algorithm/</url>
    
    <content type="html"><![CDATA[<h2 id="密码算法">密码算法</h2><h3 id="一对称加密原理">一、对称加密原理</h3><ul><li><p>对称加密方案的5个组成部分：</p><ul><li>明文：加密算法的<strong>输入</strong>，属于<strong>原始</strong>可理解的消息和数据</li><li>加密算法：用于对明文进行各种<u>代换</u>和<u>变换</u>的算法</li><li>密钥：加密算法的<strong>参数</strong>（与明文一样都是算法的输入），算法所使用的特定代换和替代依赖于密钥</li><li>密文：加密算法的<strong>输出</strong>，依赖于明文与密钥，不同的密钥会产生不同的密文</li><li>解密算法：加密算法的<u>逆运算</u>，可由 密文 + 密钥 解密</li></ul></li><li><p>密码编码系统的划分方式：包含以下三种方式</p><ul><li>将明文转换为密文的<strong>运算类型</strong>：代换（将明文中的任意元素替换为另一元素）+置换（将明文中的元素重新排列）</li><li>所用密钥数目：对称加密（双方共享相同的密钥）+非对称加密（双方各自使用不同的密钥）</li><li>处理明文的方式：分组密码（每次处理一个分组）+流密码（连续处理输入元素）</li></ul></li><li><p>密码分析：试图<strong>破解</strong><u>明文</u>和<u>密钥</u>的过程，假设攻击者总是知道<u>加密算法</u></p><ul><li>唯密文攻击：仅知道 要解密的密文；该方法强度最低，最易防范</li><li>已知明文攻击：知道 要解密的密文 +用同一密钥加密的若干明文-密文对；一般加密算法必须能经受这种攻击<ul><li>攻击策略：该方法依靠<strong>明密文对应关系</strong> or某些明文的<strong>标准化格式</strong></li></ul></li><li>选择明文攻击：知道 待解密的密文 +攻击者<strong>任意选择</strong>的明文 +用（与待解密密文）同一密钥加密的密文<ul><li>攻击策略：攻击者会<u>故意选取</u>最有可能恢复出密钥的数据</li></ul></li><li>选择密文攻击：知道 待解密的密文 +攻击者<strong>有目的选择</strong>的密文 +用（与待解密密文）同一密钥解密的明文；该方法较少使用</li><li>选择文本攻击：知道 "选择明文攻击" + "选择密文攻击"中知道的<u>所有信息</u>；该方法也较少使用</li></ul></li><li><p>计算安全性：密文满足以下任一情况</p><ul><li>破译密码的<strong>代价</strong>超过密文信息的价值；代价一般难以估计，除非使用蛮力攻击</li><li>破译密码的<strong>时间</strong>超过密文信息的有效生命期</li></ul><p><strong>注意</strong>："蛮力攻击"指的是<u><strong>试遍</strong>所有可能的密钥</u>，直到有一个合法的密钥能够把密文还原成明文</p></li><li><p>Feistel密码结构：所有<strong>对称加密算法</strong>（如DES）使用的最普遍的结构，每轮依据一个<strong>密钥值</strong>进行<u>代换</u>和<u>置换</u></p><ul><li><p>迭代轮表达式：F 表示<strong>轮函数</strong>，子密钥<span class="math inline">\(\text{K}_i\)</span> 由整个 K 导出</p><ul><li>加密：<span class="math inline">\(\text{L}_i \gets\text{R}_{i-1}\)</span>，<span class="math inline">\(\text{R}_{i} \gets\text{L}_{i-1} \oplus \text{F}(\text{R}_{i-1}, \text{K}_i)\)</span></li><li>解密：<span class="math inline">\(\text{R}_{i-1} \gets\text{L}_i\)</span>，<span class="math inline">\(\text{L}_{i-1} \gets\text{R}_i \oplus \text{F}(\text{L}_i, \text{K}_i)\)</span></li></ul><p><img src="/2024/03/12/cyber_security/encryption-algorithm/Feistel.png" width="80%"></p></li><li><p>Feistel参数和特征：</p><ul><li>分组长度：分组越长 <span class="math inline">\(\Rightarrow\)</span>安全性越高，加解密速度降低；128bit 比较合理</li><li>密钥长度：密钥越长 <span class="math inline">\(\Rightarrow\)</span>安全性越高，加解密速度降低，128bit 比较合理</li><li>迭代轮数：Feistel 采用多轮加密，以取得较高的安全性；典型值是 16轮</li><li>子密钥产生算法：子密钥越复杂，密码分析越困难</li><li>轮函数：轮函数越复杂，抗攻击的能力就越强</li><li>快速软件加/解密：许多情况下加密算法被<u>嵌入到应用程序</u>中（做成硬件不方便），故算法执行速度很重要</li></ul></li></ul></li></ul><hr><h3 id="二数据加密标准">二、数据加密标准</h3><ul><li>数据加密标准(DES)：Feistel 结构的微调，同样包含 16 轮处理过程<ul><li>分组长度：64 bit</li><li>密钥长度：56 bit；生成的 16 个子密钥 <span class="math inline">\(\text{K}_i\)</span> 分别应用于每一轮</li></ul></li><li>三重DES：使用三个密钥 <span class="math inline">\(\text{K}_i\)</span> 执行三次 DES 算法<ul><li>密钥长度：<span class="math inline">\(\text{K}_i\)</span> 长度 = 56bit <span class="math inline">\(\Rightarrow\)</span><strong>有效密钥长度</strong> = 56 bit <strong>x 3</strong> = 168bit，穷举攻击没有可能 <br><strong>注意</strong>：联邦信息处理标准 46-3允许仅使用两个密钥，即 <span class="math inline">\(\text{K}_1 =\text{K}_3\)</span> <span class="math inline">\(\Rightarrow\)</span><strong>有效密钥长度</strong> = 56bit <strong>x 2</strong> = 112bit</li><li>加密过程：<span class="math inline">\(\text{C} =\text{E}(\text{K}_3, \text{D}(\text{K}_2, \text{E}(\text{K}_1,\text{P})))\)</span>；即 加密 <span class="math inline">\(\Rightarrow\)</span> 解密（便于下一步使用DES加密）<span class="math inline">\(\Rightarrow\)</span> 加密</li><li>解密过程：<span class="math inline">\(\text{P} =\text{D}(\text{K}_1, \text{E}(\text{K}_2, \text{D}(\text{D}_3,\text{C})))\)</span>；即 解密 <span class="math inline">\(\Rightarrow\)</span> 加密 <span class="math inline">\(\Rightarrow\)</span> 解密</li></ul></li></ul><hr><h3 id="三高级加密标准">三、高级加密标准</h3><ul><li><p>高级加密标准(AES)综述：最终将取代 DES 和 3DES</p><ul><li>分组长度：128 bit</li><li>密钥长度：128bit 或 196 bit 或 256 bit</li><li>加密轮数：128bit 密钥 <span class="math inline">\(\Rightarrow\)</span> 10轮；192bit 密钥 <span class="math inline">\(\Rightarrow\)</span> 12轮；256bit 密钥 <span class="math inline">\(\Rightarrow\)</span> 14轮</li></ul></li><li><p>AES 特点：</p><ul><li><p>没有采用 Feistel结构（一半修改另一半，再交换两部分），包括<u>一个置换</u>和<u>三个代换</u></p></li><li><p>输入的密钥(128bit)被扩展为44个32位字组成的数组 w[0...43]，其中第i 轮使用 w[4i ... 4i+3] 作为该轮的<strong>轮密钥</strong></p><ol type="1"><li>字节代换：使用 <strong>S盒</strong>对分组中的每个字节进行替换；S盒即"Substitution Box"</li><li>行移位：用一<strong>行</strong>代替另一行的置换</li><li>列混淆：对<strong>列</strong>的每个字节做替换，是一个与本列全部字节有关的函数</li><li>轮密钥加：利用<u>当前分组</u>和<u>扩展密钥的特定部分</u>进行<strong>按位异或</strong>，增强加密过程随机性</li></ol><p><img src="/2024/03/12/cyber_security/encryption-algorithm/AES轮.png" width="70%"></p><p><strong>注意</strong>：AES是<strong>面向字节</strong>操作的，在软件和硬件上都能快速地加解密，相对来说<u>易于操作</u>且<u>占用存储空间少</u></p></li><li><p>每个阶段可逆，解密过程分别为对应的逆操作</p></li><li><p>加密和解密的最后一个阶段均只包含三个阶段（少了列混淆）</p><p><img src="/2024/03/12/cyber_security/encryption-algorithm/AES算法.png" width="75%"></p></li></ul></li></ul><hr><h3 id="四流密码和rc4">四、流密码和RC4</h3><ul><li><p>流密码的结构：持续处理输入元素，每次加密一字节的明文</p><ul><li>伪随机字节发生器：根据<u>输入的密钥</u>每次随机产生一串 8bit数字</li><li>伪随机流：发生器的输出，即连续的<strong>密钥流</strong></li><li>加密流程：一个字节的明文 <span class="math inline">\(\oplus\)</span>一个字节的密钥流</li><li>解密流程：一个字节的密文 <span class="math inline">\(\oplus\)</span>一个字节的密钥流</li></ul></li><li><p>流密码的用途：数据通信信道 or网页浏览器/Web链路（不成块的数据）</p><p><img src="/2024/03/12/cyber_security/encryption-algorithm/流密码.png"></p></li><li><p>RC4算法：可变密码长度、面向字节操作的流密码；设状态矢量S[0...255]，任何时刻S包含从0~255的所有 8bit 数</p><ol type="1"><li><p>初始化S：先将S中各字节按升序排序，即 S[0]=0, S[1]=1, ...,S[255]=255</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// K是变长密钥, 循环重复使用密钥K中的值赋给T</span><br><span class="hljs-comment">// T是与S等长的临时矢量</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">255</span>; i++) &#123;<br>    s[i] = i;<br>    T[i] = K[i % keylen]<br>&#125;<br><br><span class="hljs-comment">// 根据T对S进行初始置换, 即把S[i]与S中的另一个字节S[j]交换位置</span><br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">255</span>; i++) &#123;<br>    j = (j + S[i] + T[i]) % <span class="hljs-number">256</span>;<br>    swap(S[i], S[j]);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>子密钥序列的生成：状态矢量S一旦初始化完毕，就不再使用输入密钥K</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 持续生成密钥流, 故 while(1)</span><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">// S[255]完成置换后, 回到S[0]继续重复</span><br>    i = (i + <span class="hljs-number">1</span>) % <span class="hljs-number">256</span>;<br>    j = (j + S[i]) % <span class="hljs-number">256</span>;<br>    swap(S[i], S[j]);<br>    t = (S[i] + S[j]) % <span class="hljs-number">256</span>;<br>    <span class="hljs-comment">// 加密时, 子密钥序列k与下一个明文字节异或XOR</span><br>    <span class="hljs-comment">// 解密时, 子密钥序列k与下一个密文字节异或XOR</span><br>    k = S[t];<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：若子密钥序列k出现了<strong>重复</strong>，密文就可能被破解；RC4应用于SSL/TLS，WEP，WPA等</p></li></ol></li></ul><hr><h3 id="五分组密码的工作模式">五、分组密码的工作模式</h3><ul><li><p>电子簿模式ECB：一次处理b位明文，每次加密都使用<strong>相同的密钥</strong>；任何b位明文都只有<u>唯一的密文</u>与之对应（类似密码簿）</p><ul><li>加密：<span class="math inline">\(\text{C}_j = \text{E}(\text{K},\text{P}_j)\)</span></li><li>解密：<span class="math inline">\(\text{P}_j = \text{D}(\text{K},\text{C}_j)\)</span></li><li>优点：有利于<strong>并行</strong>运算，误差不会传递（密文块损坏只会导致对应的明文块损坏）</li><li>缺点：由于<u>相同的明文</u>会生成<u>相同的密文</u>，故同样信息多次出现可能造成<strong>泄露</strong>（借助代换 or 重排 进行攻击）</li></ul><p><strong>注意</strong>：ECB在传递 长消息 or 高度结构化的消息时不够安全，需要能将重复的明文组加密成不同的密文组</p></li><li><p>密码块链接模式CBC：加密算法的每轮输入与当前明文组<strong>无固定关系</strong>（隐藏重复明文模式）；加密每一组明文使用的<strong>密钥相同</strong></p><ul><li>加密：<span class="math inline">\(\text{C}_j = \text{E}(\text{K},\text{C}_{j-1} \oplus \text{P}_j)\)</span>，第一个密文块 由 第一个明文块<span class="math inline">\(\oplus\)</span>随机<strong>初始向量IV</strong> 得到</li><li>解密：<span class="math inline">\(\text{P}_j = \text{C}_{j-1} \oplus\text{D}(\text{K}, \text{C}_j)\)</span>，第一个明文块 由第一块密文解密结果 <span class="math inline">\(\oplus\)</span><strong>初始向量IV</strong> 得到</li><li>优点：不容易被主动攻击，安全性好于ECB；适合传输长报文</li><li>缺点：不利于并行计算（序列加密），误差会传递（一个密文块<span class="math inline">\(\text{C}_j\)</span>损坏 <span class="math inline">\(\Rightarrow\)</span> 两个明文块<span class="math inline">\(\text{P}_j\)</span>和<span class="math inline">\(\text{P}_{j+1}\)</span>损坏）</li></ul><p><img src="/2024/03/12/cyber_security/encryption-algorithm/CBC.png" width="70%"></p></li><li><p>密码反馈模式CFB：上一轮加密结果与作为<strong>伪随机数算法</strong>的输入，而输出与明文异或送入下一层</p><ul><li>加密：<span class="math inline">\(\text{C}_j = \text{P}_{j} \oplus\text{S}_s(\text{E}(\text{K}, \text{IV}))\)</span>，其中 <span class="math inline">\(\text{S}_s\)</span>表示选择加密输出的<strong>高s位</strong></li><li>解密：<span class="math inline">\(\text{P}_j = \text{C}_j \oplus\text{S}_s(\text{E}(\text{K},\text{IV}))\)</span>，注意解密过程使用的也是<strong>加密函数E</strong></li><li>优点：隐藏了明文模式，可将任意<u>分组密码</u>转化为<u>流密码</u>；可以及时加密传送<strong>小分组数据</strong></li><li>缺点：不利于<strong>并行处理</strong>（序列加密），误差会传递，对于不同的消息IV必须唯一</li></ul><p><img src="/2024/03/12/cyber_security/encryption-algorithm/CFB.png" width="70%"></p><p><strong>注意</strong>：伪随机数使用移位寄存器，每轮加密左移s位，并将s位的密文填入移位寄存器的低s位置</p></li><li><p>输出反馈模式OFB：与上一个CFB基本相同，同样需要初始向量IV</p><ul><li>特点：可将任意<u>分组密码</u>转化为<u>流密码</u>，且误差不会传递</li></ul><p><strong>注意</strong>：相较于CFB，OFB加密算法的输入是上一轮加密算法的输出（而不是伪随机数算法的输出）</p></li><li><p>计数器模式：将循环计数器的值作为加密（解密）算法的输入；在异步传输模式ATM和IPSec中应用广泛</p><ul><li>加密：<span class="math inline">\(\text{C}_j = \text{P}_j \oplus\text{E}(\text{K}, \text{cnt})\)</span></li><li>解密：<span class="math inline">\(\text{P}_j = \text{C}_j \oplus\text{E}(\text{K}, \text{cnt})\)</span></li><li>优点：支持并行处理，硬件效率和软件效率高</li><li>缺点：若计数器的值出现重复，就有可能被攻破</li></ul><p><img src="/2024/03/12/cyber_security/encryption-algorithm/CTR.png" width="70%"></p></li></ul><hr><h3 id="六对称加密设备的位置">六、对称加密设备的位置</h3><ul><li><p>链路加密：在通信链路的两端设置加密设备</p><ul><li>优点：保证链路上的所有信息传输是安全的</li><li>缺点：在分组交换的时候需要将消息解密成明文，此时易于受到攻击</li></ul></li><li><p>端对端加密：加密过程在主机or终端进行</p><ul><li>优点：可保证用户数据的安全</li><li>缺点：如果对整个包加密，转发方就无法读取信息头，限制了路由</li></ul><p><img src="/2024/03/12/cyber_security/encryption-algorithm/加密位置.png" width="70%"></p><p><strong>注意</strong>：整个分组使用<strong>链路加密</strong>（路由自由），而其中的用户数据使用<strong>端对端加密</strong>（保证数据安全）</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>cyber security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>『compiler-8』LR</title>
    <link href="/2023/11/27/compiler/LR/"/>
    <url>/2023/11/27/compiler/LR/</url>
    
    <content type="html"><![CDATA[<h2 id="lr-语法分析器">LR 语法分析器</h2><h3 id="一自底向上的语法分析">一、自底向上的语法分析</h3><ul><li><p>“自顶向下”和“自底向上”的区别：</p><p>自顶向下：<u>从文法的<strong>开始符号</strong>出发</u>，反复使用产生式，寻找匹配的“推导”；如递归下降语法分析，LL(1)语法分析</p><p>自底向上：<u>从<strong>输入串</strong>开始逐步规约</u>，到达文法的开始符号的“规约”；如LR语法分析</p><hr></li><li><p>规约：自底向上语法分析过程，即为串<span class="math inline">\(\omega\)</span>“规约”为文法的<strong>开始符号</strong>的过程</p><p>每个规约步骤，一个与<strong>某<u>产生式体</u>相匹配的特定子串</strong>被替换为该<strong><u>产生式头部</u>的非终结符号</strong></p><p><strong>注意</strong>：一次规约即为一次最右推导的<strong>逆操作</strong></p></li><li><p>句柄：设<span class="math inline">\(S\overset{*}{\underset{rm}{\Rightarrow}} \alpha A \omega\underset{rm}{\Rightarrow} \alpha \beta\omega\)</span>，那么<u>紧跟在A之后</u>的产生式<span class="math inline">\(A \rightarrow \beta\)</span>就是串<span class="math inline">\(\alpha \beta\omega\)</span>的一个<strong>句柄</strong>（简称<span class="math inline">\(\beta\)</span>是一个句柄）</p><p><strong>注意</strong>：句柄<span class="math inline">\(\beta\)</span>右侧的串<span class="math inline">\(\omega\)</span>只由<strong>终结符号</strong>组成（即句子）</p></li><li><p>句柄剪枝：设串<span class="math inline">\(\omega\)</span>是文法G中的句子，关于其<strong>最右推导</strong>为<span class="math inline">\(S \underset{rm}{\Rightarrow} \gamma_1\underset{rm}{\Rightarrow} ... \underset{rm}{\Rightarrow} \gamma_{n-1}\underset{rm}{\Rightarrow} \gamma_n =\omega\)</span>，将该推导过程<strong>反向</strong>即可获得规约过程</p><p>每一步规约从<span class="math inline">\(\gamma_i\)</span>中寻找<strong>句柄</strong><span class="math inline">\(\beta_i\)</span>，将<span class="math inline">\(A\rightarrow \beta_i\)</span>替换入<span class="math inline">\(\gamma_i\)</span>获得<span class="math inline">\(\gamma_{i-1}\)</span></p></li><li><p>移入——规约语法分析：维护<strong>栈</strong>保存文法符号，从左到右扫描输入串</p><ul><li><p>移入：将<strong>输入串的最左端</strong>转移到<strong>栈顶</strong></p></li><li><p>规约：将<strong>栈顶</strong>的文法符号串进行<strong>规约</strong></p><p><strong>注意</strong>：<u>可被规约的符号串必然在<strong>栈顶</strong></u>，一旦栈顶出现可被规约的串就要寻找对应的句柄进行“规约”操作</p></li><li><p>接受：宣布自底向上的语法分析结束（栈中只有S，且输入已空）</p></li><li><p>报错：发现一个语法错误，并调用一个错误恢复函数</p></li></ul></li><li><p>移入——规约中的冲突：</p><ul><li>面对含有二义性的文法，由于<u>只向前看一步</u>，可能不确定是要执行“移入”还是“规约”</li><li>找到句柄后，不确定要使用<u>哪一个产生式</u>进行替换规约</li></ul></li></ul><hr><h3 id="二lr语法分析技术">二、LR语法分析技术</h3><ul><li><p>LR(k)语法的定义：目前最流行的<u><strong>自底向上</strong></u>的语法分析器⭐</p><p>"L"表示对输入串<strong>从左到右</strong>扫描</p><p>"R"表示构造一个<strong>最右推导序列</strong></p><p>"k"表示决定<strong>向前看k个</strong>输入符号，一般k=0或1</p></li><li><p>LR(1)的特点：</p><ul><li>几乎可围绕<strong>所有的程序设计语言</strong>（只要能写出<u>上下文无关文法</u>）构造LR语法分析</li><li>运用最通用的<strong>无回溯-规约分析技术</strong></li><li>LR技术可在从左到右进行扫描时<strong>尽可能早</strong>地检测到错误</li><li>可用LL语法分析的语言都可以使用LR语法分析</li></ul><hr></li><li><p>文法G的<u>一个</u>LR(0)<strong>项</strong>：G的<u>一个</u>产生式再插入一个位于它的产生式体中的某处的<strong>点</strong></p><p>产生式<span class="math inline">\(A \rightarrowXYZ\)</span>可产生四个项（产生式体中可在四个位置插入点）</p><p>产生式<span class="math inline">\(A \rightarrow\epsilon\)</span>只能产生一个项<span class="math inline">\(A \rightarrow\cdot\)</span></p><p><strong>注意</strong>：一个项通常可以表示为<strong>一对整数</strong>：产生式编号+ 点的位置</p></li><li><p>项集：项的列表</p></li><li><p>项与语法分析：项中的<strong>定点</strong>表示<u>目前识别到的产生式中的位置</u></p><p>项<span class="math inline">\(A \rightarrow X \cdotYZ\)</span>表示刚在输入串中看到一个可由X推导得到的串，并希望<strong>接下来</strong>能看到一个能从YZ推导得到的串</p><p>项<span class="math inline">\(A \rightarrow XYZ\cdot\)</span>表示已经看到了该产生式体XYZ，可将其<strong>规约</strong>为A</p><hr></li><li><p>LR(0)自动机</p><ul><li><p>增广文法：设S是文法G的开始符号</p><p>G的增广文法G'就是在G中增加<strong>新的开始符号S'</strong>和<strong>产生式<span class="math inline">\(S&#39; \rightarrow S\)</span></strong></p></li><li><p>项集的闭包CLOSURE函数：设I是文法G的一个<strong>项集</strong>，那么称CLOSURE(I)是I的一个<strong>项集</strong>：</p><ol type="1"><li>先将<strong>I中所有的项</strong>加入到CLOSURE(I)中</li><li>若<span class="math inline">\(A \rightarrow \alpha \cdot B\beta\)</span>在CLOSURE(I)中，则对于<strong>所有</strong>产生式<span class="math inline">\(B \rightarrow \gamma\)</span>，项<span class="math inline">\(B \rightarrow \cdot \gamma\)</span>也应属于CLOSURE(I)</li></ol><p><strong><u>反复执行</u>上面的第二步</strong>直至<u>CLOSURE(I)不再扩大</u>为止</p><p><strong>注意</strong>：构造闭包的过程中需要时刻注意CLOSURE内的产生式体中<strong>点<u>右侧可扩展</u>的非终结符</strong></p><hr></li><li><p>GOTO函数：设I是一个项集，X是一个文法符号</p><p>GOTO(I, X) = CLOSURE(J)</p><p>其中项集J = <span class="math inline">\(\{所有形如A \rightarrow\alpha X \cdot \beta的项 | A \rightarrow \alpha \cdot X \beta \inI\}\)</span>（即把点挪到X后面）</p><p><strong>注意</strong>：求解GOTO(I,X)即是<strong>将点向右挪动</strong>并求闭包的过程，蕴含了识别过程的推进</p></li><li><p>规范LR(0)项集族：LR(0)自动机中的每个<u><strong>状态</strong></u>代表<strong>规范LR(0)项集族C中的一个<u>项集</u></strong>，设增广文法为G'：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">void items(G’) &#123;<br>/* 自动机的开始状态即为CLOSURE(&#123;S’ -&gt; .S&#125;) */<br>C = &#123; CLOSURE(&#123;S’ -&gt; .S&#125;) &#125;;<br>do &#123;<br>for (C中的每个项集I) &#123;<br>for (每个文法符号X) &#123;<br>if (GOTO(I, X)非空 &amp;&amp; GOTO(I, X)不在C中) &#123;<br>将GOTO(I, X)加入到C中;<br>/* 根据 当前项集 和 可能的输入符号 确定待加入的项集 */<br>/* GOTO -&gt; 右移 + 扩展闭包 */<br>&#125;<br>&#125;<br>&#125;<br>&#125; while (在该轮循环中/* 有新的项集 */被加入到项集族C中);<br>&#125;<br></code></pre></td></tr></table></figure><figure style="text-align:center;"><p><img src="/2023/11/27/compiler/LR/LR(0)自动机.png" width="80%" height="80%"></p><figcaption><p>LR(0)自动机示例（灰色部分都可以省略不写）</p></figcaption></figure></li></ul><hr><ul><li><p>LR语法分析算法</p><ul><li><p>文法符号与状态：若存在状态转移GOTO(<span class="math inline">\(I_i\)</span>, X) = <span class="math inline">\(I_j\)</span>，则<strong>状态j</strong>对应了<strong>唯一的文法符号X</strong></p></li><li><p>LR语法分析器：输入、输出、状态栈、分析表（ACTION +GOTO）、语法分析表</p><figure style="text-align:center;"><p><img src="/2023/11/27/compiler/LR/LR语法分析器.png" width="80%" height="80%"></p><figcaption><p>LR语法分析器</p></figcaption></figure></li><li><p>LR语法分析表：由<strong>语法分析动作函数ACTION</strong>和<strong>转换函数GOTO</strong>组成</p><ul><li>ACTION[i, a]：接收状态i和终结符号a（可以是$），包含以下四种动作：<ul><li>移入状态j：将终结符号a对应的状态压栈</li><li>规约<span class="math inline">\(A \rightarrow\beta\)</span>：将栈顶的<span class="math inline">\(\beta\)</span>规约为其产生式头A</li><li>接受：语法分析器接受输入并完成语法分析</li><li>报错：在输入中发现了一个错误并执行错误恢复程序</li></ul></li><li>GOTO[<span class="math inline">\(I_i\)</span>, A] = <span class="math inline">\(I_j\)</span>：转移函数将状态i和<strong>非终结符号A</strong>映射到状态j，状态可以还原为其对应字符</li></ul></li><li><p>LR语法分析器的格局（configuration）：<u>栈</u>和<u>余下的输入</u></p><ul><li><p>格局：有序对 <span class="math inline">\((s_0s_1...s_m,a_ia_{i+1}...a_n \$)\)</span></p></li><li><p>格局对应的<strong>最右句型</strong>：<span class="math inline">\(X_1X_2...X_ma_ia_{i+1}...a_n\)</span></p><p>其中<span class="math inline">\(X_i\)</span>是状态<span class="math inline">\(s_i\)</span>对应的文法符号，<span class="math inline">\(s_0\)</span>不代表任何文法符号</p></li></ul></li><li><p>构造SLR语法分析表（ACTION +GOTO）：<u><strong>基于LR(0)自动机确定语义动作</strong></u>，设增广文法为G'</p><ol type="1"><li>构造G'的规范LR(0)项集族 <span class="math inline">\(C = \{I_0, I_1,..., I_n\}\)</span></li><li>根据<span class="math inline">\(I_i\)</span>构造状态i，及其<strong>语法分析动作</strong>：<ul><li>若 <span class="math inline">\(A \rightarrow \alpha \cdot a\beta\in  I_i\)</span> （存在移进项）并且GOTO(<span class="math inline">\(I_i\)</span>, a) = <span class="math inline">\(I_j\)</span>（状态i在a上存在转换），则ACTION[i, a]= “移入状态j”</li><li>若 <span class="math inline">\(A \rightarrow \alpha \cdot \inI_i\)</span>且 <span class="math inline">\(A \neS&#39;\)</span>（存在规约项），则对于<strong>FOLLOW(A)</strong>中的所有a，ACTION[i,a] = “规约<span class="math inline">\(A \rightarrow\alpha\)</span>”</li><li>若 <span class="math inline">\(S&#39; \rightarrow S \cdot \inI_i\)</span>，则ACTION[i, $] = “接受”</li></ul></li><li>将未定义的ACTION条目设置为“报错”</li><li>设置语法分析器的初始状态是根据<strong><span class="math inline">\(S&#39; \rightarrow \cdotS\)</span>所在项集</strong>构造得到的状态</li></ol></li><li><p>LR语法分析器的<u>行为解析</u>：先读入当前输入符号<span class="math inline">\(a_i\)</span>和栈顶状态<span class="math inline">\(s_m\)</span>，再查ACTION表项：</p><ul><li><p>若ACTION(<span class="math inline">\(s_m\)</span>, <span class="math inline">\(a_i\)</span>) = “移入状态s”，则格局转为<span class="math inline">\((s_0s_1...s_ms, a_{i+1}...a_n\$)\)</span></p></li><li><p>若ACTION(<span class="math inline">\(s_m\)</span>, <span class="math inline">\(a_i\)</span>) = “规约<span class="math inline">\(A\rightarrow \beta\)</span>”，则格局转为<span class="math inline">\((s_0s_1...s_{m-r}s, a_ia_{i+1}...a_n\$)\)</span></p><p>其中r是<span class="math inline">\(\beta\)</span>的长度，且<strong>s= GOTO(<span class="math inline">\(s_{m-r}\)</span>,A)</strong>，输入符号保持不变</p></li><li><p>ACTION(<span class="math inline">\(s_m\)</span>, <span class="math inline">\(a_i\)</span>) = “接受”，则语法分析完成</p></li><li><p>ACTION(<span class="math inline">\(s_m\)</span>, <span class="math inline">\(a_i\)</span>) =“报错”，则调用错误恢复程序</p></li></ul></li><li><p>LR语法分析算法流程：设栈内初始为<span class="math inline">\(s_0\)</span>，输入缓冲区为输入串<span class="math inline">\(\omega\)</span></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">初始化：字符a为ω中的/* 第一个符号 */;<br>while (true) &#123;<br>s = stack.top();<br>if (ACTION(s, a) == “移入t”) &#123;<br>stack.push(t);<br>a = next();<br>&#125; else if (ACTION(s, a) == “规约A -&gt; β”) &#123;<br>/* 先从栈中弹出β长度个状态 */<br>int cnt = |β|;<br>while (cnt &gt; 0) &#123;<br>stack.pop();<br>cnt--;<br>&#125;<br>t = stack.top();<br>/* 再将产生式的头压栈 */<br>stack.push(GOTO(t, /* A */));<br>(输出产生式A -&gt; β);<br>&#125; else if (ACTION(s, a) == “接受”) &#123;<br>/* 语法分析完成，跳出循环 */<br>break;<br>&#125; else &#123;<br>/* 调用错误恢复程序 */<br>error();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="三更强大的lr语法分析器">三、更强大的LR语法分析器</h3><ul><li><p>移入——规约冲突：对于ACTION中的同一表项，既可将其设置为“移入”、又可将其设置为“规约”</p><p><strong>注意</strong>：移入——规约冲突产生的原因在于SLR语法分析不够强大，不能记录足够多的上下文信息，以至于无法解析部分文法</p></li><li><p>规范LR(1)项：对规范LR(0)项的扩展，<span class="math inline">\([A\rightarrow \alpha \cdot \beta,a]\)</span>，其中第二分量a表示<strong>向前看符号</strong> <br>规约项<span class="math inline">\([A \rightarrow \alpha \cdot, a]\)</span>表示当<strong>栈顶为状态<span class="math inline">\(\alpha\)</span></strong>且<strong>后续符号为a</strong>时才进行“规约<span class="math inline">\(A \rightarrow \alpha\)</span>”</p></li><li><p>构造CLOSURE：<u>若要规约为A，则要先规约为B</u>；设增广文法为G'</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">SetOfItems CLOSURE(I) &#123;<br>do &#123;<br>for (项集I中的每个项[A -&gt; α.Bβ, a]) &#123;<br>for (G’中的每个产生式 B -&gt; γ) &#123;<br>/* 能够被规约为B的串后接βa */<br>for (FIRSt(βa)中的每个终结符号b) &#123;<br>将[B -&gt; .γ, b]加入到项集I中;<br>&#125;<br>&#125;<br>&#125;<br>&#125; while (在该轮循环中有/* 新的项 */加入到I中);<br>    return I;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>构造GOTO：描述LR(1)状态机的状态转移</li></ul><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">SetOfItems GOTO(I) &#123;<br>J = 空集;<br>for (项集I中的每个项 [A -&gt; α.Xβ, a]) &#123;<br>/* 将点右移 */<br>将项[A -&gt; αX.β, a]加入到项集J中;<br>&#125;<br>return CLOSURE(J);<br>&#125;<br></code></pre></td></tr></table></figure></p><ul><li>构造LR(1)项集族：LR(1)自动机中的每个<u><strong>状态</strong></u>代表<strong>规范LR(1)项集族C中的一个<u>项集</u></strong>，设增广文法为G'：</li></ul><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">void items(G’) &#123;<br>/* 自动机的开始状态即为CLOSURE(&#123;S’ -&gt; .S, $&#125;) */<br>C = &#123; CLOSURE(&#123;[S’ -&gt; .S, $]&#125;) &#125;;<br>do &#123;<br>for (项集族C中的每个项集) &#123;<br>for (每个文法符号X) &#123;<br>if (GOTO(I, X)非空 &amp;&amp; GOTO(I, X)不在C中) &#123;<br>将GOTO(I, X)加入到项集族C中;<br>/* 根据 当前项集 和 可能的输入符号 确定待加入的项集 */<br>/* GOTO -&gt; 右移 + 扩展闭包 */<br>&#125;<br>&#125;<br>&#125;<br>&#125; while (在该轮循环中有/* 新的项集 */加入到项集族C中);<br>&#125;<br></code></pre></td></tr></table></figure></p><hr><ul><li><p>构造规范LR(1)语法分析表（ACTION +GOTO）：<u><strong>基于LR(1)自动机确定语义动作</strong></u>，设增广文法为G'</p><ol type="1"><li>构造G'的LR(1)项集族 <span class="math inline">\(C&#39; = \{I_0, I_1,..., I_n\}\)</span></li><li>根据项集<span class="math inline">\(I_i\)</span>构造状态i，及其<strong>语法分析动作</strong>：<ul><li>若 <span class="math inline">\([A \rightarrow \alpha \cdot a \beta,b] \in I_i\)</span>（存在移进项），且GOTO(<span class="math inline">\(I_i\)</span>, a) = <span class="math inline">\(I_j\)</span>，则ACTION[i, a] = “移入状态j”</li><li>若 <span class="math inline">\([A \rightarrow \alpha \cdot, a] \inI_i\)</span> 且 <span class="math inline">\(A \neS&#39;\)</span>（存在规约项），则ACTION[i, a] = “规约 <span class="math inline">\(A \rightarrow \alpha\)</span>”</li><li>若 <span class="math inline">\([S&#39; \rightarrow S \cdot, \$] \inI_i\)</span>，则ACTION[i, $] = “接受”</li></ul></li><li>未定义的ACTION条目都设置为“报错”</li><li>设置语法分析器的初始状态为包含 <span class="math inline">\([S&#39;\rightarrow \cdot S, \$]\)</span> 的项集构造得到的状态</li></ol></li><li><p>LR语法中的错误恢复</p><ul><li>恐慌模式：设出错部分可由某个<strong>非终结符号A</strong>推导出，一旦出错：<ol type="1"><li>从栈顶向下扫描直至找到状态s，且这个状态s拥有一个在A上的转换GOTO(s,A)</li><li><strong>跳过若干个输入符号</strong>，直至发现一个可以<strong>合法地跟在非终结符号A后面的符号</strong></li><li>将GOTO(s, A)压栈</li></ol></li></ul><p><strong>注意</strong>：这种恢复方法试图<u>装作完成了对非终结符号A的解析</u>，并继续前进</p></li><li><p>短语层次修复：根据LR(1)语法分析表中的报错条目推断语法错误的类型，修改<strong>栈顶状态</strong>或<strong>当前第一个输入符号</strong></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>compiler</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>『database-9』distributed database</title>
    <link href="/2023/11/23/database/distributed-database/"/>
    <url>/2023/11/23/database/distributed-database/</url>
    
    <content type="html"><![CDATA[<h2 id="分布式数据库">分布式数据库</h2><h3 id="一分布式数据库系统">一、分布式数据库系统</h3><ul><li>分布式数据库：由一组分布在计算机网络中的不同节点上的数据组成，支持局部应用（场地自治）+全局应用（网络通信）<ul><li>局部应用：只操作<strong>一个节点</strong>上的数据库的应用</li><li>全局应用：操作<strong>两个或多个的节点</strong>的数据库的应用</li></ul></li><li>场地自治与协作性：<ul><li>场地自治：每个场地有自己的数据库，一组终端、是独立的 DBS</li><li>协作性：从用户角度看，分布式数据库逻辑上如同一个集中式数据库</li></ul></li><li>分布式数据库特点：<ul><li>数据独立性：逻辑 +物理独立性；分布独立性：数据的逻辑切片、物理位置分布、重复副本一致性对用户透明</li><li>集中与自治：<ul><li>自治功能：各局部的DBMS可以独立管理局部数据库，具有自治功能</li><li>集中控制：协调各局部 DBMS 工作，执行全局应用</li></ul></li><li>数据冗余：在不同节点存储同一数据的多个副本<ul><li>提高系统可靠性 +可用性：当某一个节点出现故障时，可对另一节点进行相同操作</li><li>提高系统性能：选择与用户最近的数据副本进行操作，减少通信代价</li></ul></li><li>全局一致性，可串行性，可恢复性</li></ul></li></ul><hr><h3 id="二分布式数据库系统的体系结构">二、分布式数据库系统的体系结构</h3><ul><li>模式结构：<ul><li>全局外模式：全局应用的用户视图，全局概念模式的子集</li><li>全局概念模式：定义分布式数据库中数据的整体逻辑结构，使数据如同没有分布一样</li><li>分片模式：每个全局关系可被分为若干个互不相交的<strong>片段</strong></li><li>分布模式：定义片段的存放节点，该部分的映像类型决定了分布式数据库是冗余的还是非冗余的</li></ul></li><li>分片结构：<ul><li>水平分片：将关系<strong>按行分</strong>为互不相交的若干子集，每个子集称为一个水平分段</li><li>垂直分片：将关系<strong>按列分</strong>为若干属性子集，，每个子集称为垂直片段，垂直分片的诸多片段往往<strong>包含码</strong></li><li>导出（水平）分片：水平分片的条件来自<strong>其它关系的属性</strong>条件</li><li>混合分片：按上述三种方式得到的片段，继续按另一种方式分片</li></ul></li><li>分片的性质：<ul><li>完全性：一个全局关系中的数据必须<strong>完全划分</strong>为若干个片段，不允许某些数据不属于任何片段</li><li>不相交性：不允许一个全局关系的某些数据同时属于多个片段（垂直分片的码属性除外）</li><li>可重构性：可由片段重构全局关系（垂直分片用连接，水平分片用并集）</li></ul></li><li>分布透明性：<ul><li>分片透明性：用户只需对全局关系进行操作，无需考虑关系分片</li><li>位置透明性：用户无需了解片段的存储场地，以及数据副本的一致性</li><li>局部数据模型透明性：用户无需了解局部场地上使用的是哪种数据模型，模型转换等由分布模式-局部概念模式映像实现</li></ul></li></ul><hr><h3 id="三分布式数据库系统的主要技术">三、分布式数据库系统的主要技术</h3><ul><li><p>分布式查询类型：</p><ul><li>局部查询 &amp;远程查询：只涉及单个节点的数据，可直接采用集中式数据库的处理技术</li><li>全局查询：涉及多个节点数据</li></ul></li><li><p>分布式查询过程：</p><ol type="1"><li>查询分解：把全局查询分解为若干个子查询，每个子查询<strong>只涉及一个节点</strong>的数据，可由局部DBMS处理</li><li>选择操作执行的次序：确定<strong>不同节点</strong>上关系的连接 or并操作的的次序</li><li>选择执行操作的方法：选择存取路径、选择某种操作的算法、连接的执行方法</li></ol></li><li><p>查询优化的目标：使查询执行时的<strong>通信代价</strong>最省</p></li><li><p>半连接：提高传输效率</p><hr></li><li><p>分布事务处理：具有原子性 + 可串行性：</p><ul><li>原子性：组成事务的所有子事务（分布在不同节点）要么全部提交，要么全部回滚</li><li>可串行性：各事务的某一次调度得到的执行结果与串行执行得到的结果一致</li></ul></li><li><p>两段提交协议：对各局部事务管理器进行协调，保证分布事务原子性</p><ul><li><p>协调者：负责作出事务是提交还是撤销的<strong>最终决定</strong></p></li><li><p>参与者：负责管理<strong>相应子事务的执行</strong>，以及在各局部数据库上执行写操作</p><hr></li><li><p>第一阶段：</p><ol type="1"><li>协调者向所有参与者发送“准备提交”的信息，并记入日志，参与者<strong>回复</strong>“就绪”or“撤销”</li><li>若在规定时间内协调者收到所有参与者的“就绪”消息，则做出“提交”<strong>决定</strong>，否则做出“撤销”<strong>决定</strong></li></ol></li><li><p>第二阶段：</p><ol type="1"><li>协调者将决定写入日志，并将该决定<strong>发送</strong>给所有参与者</li><li>各参与者收到命令后，在日志中写入“收到提交/撤销决定”，向协调者发送<strong>应答</strong>信息，<strong>执行相应决定</strong></li><li>协调者收到所有应答者的应答消息后，事务执行<strong>结束</strong></li></ol><p><strong>注意</strong>：当系统发生故障时，各场地使用各自有关的日志进行事务恢复</p></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>『database-8』transaction</title>
    <link href="/2023/11/16/database/transaction/"/>
    <url>/2023/11/16/database/transaction/</url>
    
    <content type="html"><![CDATA[<h2 id="事务处理技术">事务处理技术</h2><h3 id="一事务概念">一、事务概念</h3><ul><li><p>事务的特性：ACID</p><ul><li>原子性：事务中的所有操作要么都做，要么都不做</li><li>一致性：事务执行的结果必须是从一个一致性状态到另一个一致性状态</li><li>隔离性：一个事务的执行不能被其它事务干扰，并发执行的各事务间不能相互干扰</li><li>持久性：一个事务一旦提交，对数据库的影响必须是永久的</li></ul><p><strong>注意</strong>：原子性 和 持久性由恢复机制实现，隔离性由并发控制实现，一致性由事务的原子性保证</p></li></ul><hr><h3 id="二数据库恢复技术">二、数据库恢复技术</h3><ul><li><p>数据库恢复：把数据库从<u>错误状态</u>恢复到<u>某个正常状态</u>的功能，保证了事务原子性，确保故障时可以恢复到正确状态</p></li><li><p>事务内部故障：分为可预期和不可预期故障（应用程序无法处理），意味着既没有提交、也没有显式回滚</p></li><li><p>系统故障：造成<strong>系统停止运转</strong>，使所有事务<strong>异常终止</strong>，但不会破坏数据库</p></li><li><p>介质故障：外存故障，如磁盘损坏，这会破坏数据库</p></li><li><p>计算机病毒：人为破坏</p><hr></li><li><p>数据转储：DBA定期将整个数据库复制到另一个磁盘上保存起来</p><ul><li><p>静态转储：无事务运行时转储，转储时不允许对数据库做任何读取或修改；保证副本一致性，但可用性低</p></li><li><p>动态转储：转储时允许对数据库做存取或修改；不影响可用性，但要把转储期对数据库的修改记录在日志中</p><hr></li><li><p>海量转储：一次性转储全部数据库</p></li><li><p>增量转储：每次只转储上次转储后<strong>更新</strong>过的内容</p></li><li><p>日志文件：一条日志记录包括“事务标识”、“操作类型”、“操作对象”、“更新前旧值”、“更新后新值”以数据块为单位的日志文件，日志记录包括 事务标识 + 被更新的数据块</p><ul><li>动态转储：后备副本 + 日志文件 才能恢复数据库</li><li>静态转储：通过 日志文件 恢复转储结束 <span class="math inline">\(\Rightarrow\)</span> 故障点间 的事务</li></ul><p><strong>注意</strong>：必须按照并发事务的执行<strong>先后</strong>顺序写入日志文件，且要<u>先写日志、后写数据库</u></p></li><li><p>事务故障恢复：撤销操作，即<strong>反向扫描</strong>日志文件，对各更新操作执行<strong>逆操作</strong>，直至读到事务开始标志</p></li><li><p>系统故障恢复：撤销未完成的事务 +重做已完成的事务，<strong>正向扫描</strong>日志文件：</p><ul><li>将故障前已提交的事务加入到<strong>重做队列</strong></li><li>将故障时未完成的事务加入到<strong>撤销队列</strong></li></ul></li><li><p>介质故障恢复：</p><ol type="1"><li>装入最新的数据库<strong>后备副本</strong>，使数据库恢复到最近一次转储时的一致性状态</li><li>装入转储后的<strong>日志文件副本</strong>，重做已经完成了的事务</li></ol><hr></li><li><p>检查点技术：在日志文件中新增一类记录（检查点记录），新增重新开始文件</p><ul><li>检查点记录：建立该记录时刻所有正在执行的<strong>事务清单</strong> +这些事务<strong>最近一个日志记录</strong>的地址</li><li>重新开始文件：记录各检查点记录在日志文件中的地址</li></ul></li><li><p>动态维护日志文件：建立检查点 + 保存数据库状态</p><ol type="1"><li>将日志缓存中的所有日志记录<strong>写回</strong>日志文件</li><li>在日志文件上写入一个<strong>检查点记录</strong>（先写日志）</li><li>将当前数据缓存中的所有数据记录<strong>写回</strong>磁盘数据库（后写数据库）</li><li>把检查点记录在日志文件中的地址记录在<strong>重新开始文件</strong></li></ol></li><li><p>检查点技术的恢复</p><ol type="1"><li>根据重新开始文件的最后一个地址，找到日志中最后一个检查点记录</li><li>把最后一个检查点建立时刻所有正在运行的事务暂时加入到 UNDO-LIST</li><li>从检查点正向扫描日志文件，若该任务<strong>新开始</strong>，则将其暂时加到UNDO；若该任务<strong>已提交</strong>，则将其从 UNDO 移动到 REDO</li><li>对 UNDO 中的任务执行撤销操作，对 REDO 中的任务执行重做操作</li></ol><hr></li><li><p>数据库镜像：每当主数据库更新时，DBMS自动把整个数据库复制到另一个磁盘上</p><ul><li>数据库恢复：数据库故障时，镜像磁盘可供继续使用、以及数据恢复（不必重装数据库副本）</li><li>数据库可用：正常情况下，一个用户对数据库添加排他锁时，其他用户可读取镜像数据库上的数据</li></ul></li></ul><hr><h3 id="三数据库并发控制">三、数据库并发控制</h3><ul><li><p>并发操作导致的数据不一致性：</p><ul><li>丢失更新：两个事务读取同一数据并先后修改提交，T2的提交破坏了T1的提交结果</li><li>读脏数据：T2读取了T1修改的数据，但T1的修改数据被撤销，导致T2读到的数据不一致</li><li>不能重复读：T1读取数据后，T2更新数据，T1再次读数据时发现读取结果无法复现</li></ul></li><li><p>封锁：排他锁（X）和 共享锁（S）</p><ul><li>一级封锁协议：事务在修改数据前必须加 <strong>X</strong>锁，直至<strong>事务结束</strong>后才释放<br>保证不丢失修改（不会被干扰覆盖），但由于读数据不需要申请锁，故不保证避免脏读+ 可重复读</li><li>二级封锁协议：在一级封锁协议的基础上，读数据前先加<strong>S</strong> 锁，<strong>读完</strong>即释放<br>进一步保证不读“脏数据”（修改事务结束前不能读），但不保证可重复读（应该在事务中的<strong>所有读操作结束</strong>后才释放）</li><li>三级封锁协议：在一级封锁协议的基础上，读数据前先加<strong>S</strong> 锁，直至<strong>事务结束</strong>才释放<br>进一步保证可重复读</li></ul><hr></li><li><p>活锁：很长时间等待其它事务释放锁，轮不到自己</p><ul><li>预防方法：先来先服务</li></ul></li><li><p>死锁：互相持有锁，无法结束，解决方案如下：</p><ul><li>预防死锁：<ul><li>一次封锁法：一次性把事务所有资源全部加锁，否则不能执行，并发度较低</li><li>顺序封锁法：预先对各数据对象规定一个封锁顺序，实现难度较大</li></ul></li><li>检测死锁：<ul><li>超时法：等待时间超过规定期限，就认为发生死锁</li><li>等待图法：若等待图中存在有向回路，说明出现死锁</li></ul></li></ul><hr></li><li><p>封锁粒度：封锁粒度大，并发度低，封锁开销小；封锁粒度小，并发度高。封锁开销大</p><ul><li>多粒度树：根表示整个数据库，自顶向下是数据库、关系、元组<ul><li>显示封锁：直接加到对象上的锁</li><li>隐式封锁：该对象上没有独立加锁，但其上级节点加锁导致该对象加了<strong>同类型的锁</strong></li></ul></li><li>封锁检查：对某个对象加锁，需要同时做以下检查<ul><li>是否与其本身上的显示封锁冲突</li><li>是否与其隐式封锁冲突（检查其所有上级节点）</li><li>是否与其下级节点显示封锁冲突（检查其所有下级节点）</li></ul></li><li>意向锁：把那个对称表记住</li></ul><hr></li><li><p>并发调度与可串行性：</p><ul><li><p>可串行化调度：多个事务的并发执行是正确的，当且仅当其结果与按<strong>某次串行执行这些事务</strong>时结果相同</p></li><li><p>冲突可串行化调度：</p><ul><li>冲突操作：不同事务对同一数据的读写操作 or 写写操作</li><li>冲突可串行调度：一个调度<strong>保证冲突操作次序不变</strong>的情况下，通过交换两个事务的<u>不冲突操作的次序</u>的到另一个调度，且新的调度是<strong>串行</strong>的</li></ul><p><strong>注意</strong>：调度是正确的 <span class="math inline">\(\Leftrightarrow\)</span>调度是可串行化的；冲突可串行化 <span class="math inline">\(\Rightarrow\)</span>可串行化，调整时尽量将相同事务的操作聚在一起</p></li></ul></li><li><p>两段锁协议：对任何数据进行读写操作前都要申请封锁；释放一个封锁后，该事务不再获得任何其它锁（扩展<span class="math inline">\(\rightarrow\)</span> 收缩）</p><ul><li>定理：若所有事务都遵循<strong>两段锁协议</strong>，则这些事务的并发调度都是可串行化的，即<strong>并发调度一定是正确</strong>的</li></ul><p><strong>注意</strong>：遵循两段锁协议的事务仍可能发生死锁；所有事务遵循两段锁协议<span class="math inline">\(\Rightarrow\)</span> 可串行化</p></li></ul><hr><ul><li><p>其它并发控制方法：</p><ul><li><p>事务隔离级别：SQL定义了 4种隔离级别：“读未提交”、“读已提交”、“可重复读”、“可串行化”</p></li><li><p>时间戳排序协议：为每个事务分配一个全局唯一的时间戳，使所有事务单调排序，事务仅能访问排在其前的数据<br><strong>注意</strong>：时间戳排序协议可产生冲突可串行化调度；若两个事务冲突，终止其中一个，<strong>将其回滚并重新调度</strong>，赋予新的时间戳</p></li><li><p>乐观并发控制协议：分为以下三个阶段：</p><ol type="1"><li>读操作：从数据库读入数据，在事务私有工作区写操作</li><li>验证：有效性检查测试是否满足所需的隔离限制，若检测失败则终止事务，否则继续写操作</li><li>写操作：将私有工作区中的更新数据写回到数据库中</li></ol><p><strong>注意</strong>：以上两种方法都是乐观并发控制，假设不会发生冲突，提交时才检查，做冲突处理</p></li><li><p>多版本控制：维护一个数据的多个物理版本，<strong>无锁</strong>并发控制</p><ul><li>事务进行写操作时，产生该数据的一个<strong>新版本</strong></li><li>事务进行读操作时，读取该事务开始时的数据的最新版本</li></ul><p><strong>注意</strong>：事务读操作无需等待且一定成功，但<strong>无法解决丢失更新</strong>的问题</p></li></ul></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>『database-7』optimization</title>
    <link href="/2023/11/14/database/optimization/"/>
    <url>/2023/11/14/database/optimization/</url>
    
    <content type="html"><![CDATA[<h2 id="查询处理与优化">查询处理与优化</h2><h3 id="一关系查询处理步骤">一、关系查询处理步骤</h3><ul><li><p>查询分析：SQL 词法分析 + 语法分析</p></li><li><p>查询检查：语义检查 + 存取权限检查 + SQL <span class="math inline">\(\Rightarrow\)</span> 关系代数</p></li><li><p>查询优化：选择高效执行的查询处理策略</p></li><li><p>查询执行：生成查询计划代码</p><hr></li><li><p>查询代价度量：</p><ul><li>驻留在磁盘上的大型数据库：I/O代价</li><li>取一个块就访问一次磁盘：访盘块数</li></ul></li></ul><hr><h3 id="二查询操作的实现">二、查询操作的实现</h3><ul><li><p>选择操作：</p><ul><li>全表扫描法：按物理顺序读取表的 M 块到内存，将 M 块中满足条件的元组 t输出</li><li>索引扫描法：若在选择条件的属性上建有索引，先根据索引域找到目标索引项，再通过索引项找到元组t</li></ul></li><li><p>连接操作：</p><ul><li>嵌套-循环法：将<strong>较小表 s 作为外表</strong>，r作为内表，缓冲区 k-1 块分配给外表 r，1 块分配给内表 s <br>则总 I/O 次数= <span class="math inline">\(\text{b}_r + \dfrac{\text{b}_r}{k-1} *\text{b}_s\)</span>，前项表示内表的总 I/O 次数、后项表示外表的总 I/O次数</li><li>索引连接法：若关系s的连接属性上有索引，对于每个元组<span class="math inline">\(\text{t}_r\)</span>，可根据索引查找s中满足连接条件的<span class="math inline">\(\text{t}_s\)</span></li><li>排序合并法：分为两步<ol type="1"><li>将关系r和s分别根据连接属性排序</li><li>设两个动指针 <span class="math inline">\(\text{p}_r\)</span> 和<span class="math inline">\(\text{p}_s\)</span>，对于 <span class="math inline">\(\text{p}_r\)</span> 指向的连接属性值，移动 <span class="math inline">\(\text{p}_s\)</span> 找到 s 中与 r值相等的元组</li></ol></li><li>Hash-Join 法：设哈希函数为hash<ol type="1"><li>hash 将连接属性映射到{0, ..., n}，根据连接属性将关系 r 划分为 <span class="math inline">\(\text{r}_0, ..., \text{r}_n\)</span>，将 s 划分为<span class="math inline">\(\text{s}_0, ..., \text{s}_n\)</span></li><li>将 <span class="math inline">\(\text{r}_i\)</span> 和 <span class="math inline">\(\text{s}_i\)</span>中的元组相比较进行连接运算；这种方法仅适用于等值（or 自然）连接</li></ol></li></ul></li><li><p>排序：分两种情况</p><ul><li>内存中可完全容纳的关系：直接快速排序</li><li>内存中不可完全容纳关系：外排序 -归并法，即先建立多个内部有序的归并段，再对各归并段排序</li></ul></li><li><p>去重：先使重复数据相邻，再保留其中一个</p></li><li><p>投影：在每个元组上执行投影，之后去重</p></li><li><p>集合运算：类似 排序合并法 or Hash-Join 法</p><hr></li><li><p>表达式的执行：分为 物化 or 流水线方法</p><ul><li>物化：运算结果被物化到一个临时关系中，临时关系一般需要写回磁盘（适用范围广，但读写开销大）</li><li>流水线：直接将运算结果传递给下一个运算，不存储临时关系</li></ul></li></ul><hr><h3 id="三查询优化">三、查询优化</h3><ul><li><p>查询优化目标：选择高效执行的查询处理策略，使查询代价最小，即访问磁盘块数最少</p></li><li><p>关系代数表达式等价变换规则：</p><ul><li>连接（×）和 笛卡尔积（<span class="math inline">\(\Join\)</span>）遵循交换律、结合律</li><li>投影 和 选择 遵循串接律（两步压缩成一步运算）</li><li>选择 和 投影 遵循交换律（先选择，后投影）</li><li>选择 与 笛卡尔积 遵循交换律（可将“选择F”拆分作用在内层仅含 <span class="math inline">\(\text{F}_i\)</span>中属性的关系上，达到<strong>先选择后求积</strong>）</li><li>选择 与 并、差、自然连接遵循分配律（可将“选择F”直接作用在内层关系上，再做并、差、自然连接运算，达到<strong>先选择后运算</strong>）</li><li>投影 与 笛卡尔积遵循分配律（可将投影属性按关系拆成两部分，先分别投影再连接，达到<strong>先投影后求积</strong>）</li><li>投影 与 并遵循分配律（可将投影直接作用在内层关系上，再取并集，达到<strong>先投影后求并</strong>）</li></ul></li><li><p>查询树的启发式优化：</p><ul><li><strong>选择</strong>运算尽早执行（减少元组数目）</li><li>投影运算尽早执行（减少属性数目）</li><li>笛卡尔积 + 选择 <span class="math inline">\(\Rightarrow\)</span>条件连接（笛卡尔积得到的中间结果往往很大）</li><li>找出公共子表达式，把公共子表达式的结果写入中间文件，复用运算结果</li></ul><hr></li><li><p>物理优化：</p><ul><li>基于启发式规则的操作算法选择：<ul><li>选择操作：小关系直接全表扫描；大关系可采用索引扫描</li><li>连接操作：<ul><li>两表均按连接属性排序使用：排序-合并法</li><li>一个表上的连接属性有索引：索引连接法</li><li>连接属性上未建索引 且 未排序：Hash-Join法</li><li>最后使用嵌套循环法，并选择小表作为外循环表</li></ul></li></ul></li><li>基于代价估算的优化：基于<strong>数据库统计信息</strong>计算各种操作的执行代价，选择具有最小代价的执行计划</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>『database-6』memory management</title>
    <link href="/2023/11/07/database/memory-management/"/>
    <url>/2023/11/07/database/memory-management/</url>
    
    <content type="html"><![CDATA[<h2 id="存储管理与索引">存储管理与索引</h2><h3 id="一物理存储系统">一、物理存储系统</h3><ul><li><p>存储分级：数据库中的数据只有调入<strong>内存</strong>中才能被处理，DBMS管理<u>内存</u>与<u>外存</u>的数据交换</p><figure style="text-align:Center"><p><img src="/2023/11/07/database/memory-management/存储分级.png"></p></figure></li><li><p>DBMS存储管理目标：最小化<u>访问磁盘</u>的次数</p><hr></li><li><p>磁盘块（内存中指页）：由若干连续的<strong>扇区</strong>组成，是存储分配与检索的<strong>逻辑单元</strong></p></li><li><p>磁盘访问时间：寻道时间 + 旋转时间 + 传输时间</p></li><li><p>物理存储管理器：DBMS结构中<strong>最底层</strong>模块，隔离<u>上层</u>与<u>底层</u>的模块</p><ul><li>交换单元：以<strong>磁盘块</strong>（物理页）为基本单位</li><li>基本功能：负责数据在<u>磁盘</u>与<u>主存</u>之间的移动</li><li>实现方法：调用操作系统<strong>文件</strong>接口 orDBMS自己实现（支持跨平台 + 功能扩展）</li></ul></li></ul><hr><h3 id="二数据库存储结构">二、数据库存储结构：</h3><ul><li><p>数据库：由若干<strong>文件</strong>组成；一个<u>表</u>被映射到一个<u>文件</u></p></li><li><p>文件：存放在若干<strong>磁盘块</strong>上；<u>块</u>是存储分配与数据传输的<strong>基本单位</strong><strong>注意</strong>：文件可以占据连续的磁盘块 or 链接的磁盘块 or簇（内部连续）分配磁盘块 or 索引分配磁盘块（含索引块）</p></li><li><p>记录：文件数据的基本单位；一条记录只属于<u>唯一的块</u></p><figure><p><img src="/2023/11/07/database/memory-management/数据库存储结构.png"></p></figure></li><li><p>数据库页/块：存储元组（记录）、元数据、索引，一般使用分槽页结构：</p><ul><li>Header：已使用的槽数 + 最后一个被使用槽的起始位置偏移 + 槽数组</li><li>slot：存储对应tuple在该页中的起始位置的偏移量</li><li>增加记录：槽数组从<u>开始到尾部</u>增长、记录数据从数据区<u>尾部向开始</u>方向生长</li></ul></li><li><p>记录：由DBMS负责解释为属性类型与对应值</p><ul><li>记录头部：元数据、如加锁信息</li><li>记录数据：属性对应的实际数据，按表定义的属性顺序存储</li><li>唯一标识符ID：每个纪录被分配一个ID，如 页ID-slot</li></ul><p><strong>注意</strong>：文件中的记录存放可以是 堆 + 顺序 + 索引 + 散列+ 聚集</p><ul><li>堆文件组织：链表方式（header页）+页目录方式（借助特殊页保存文件在数据页中的位置）</li><li>顺序文件组织：记录按<strong>搜索码顺序</strong>在文件中排列；通过指针把记录链接起来</li><li>索引文件组织：包括了主文件（存放记录） + 索引表（key <span class="math inline">\(\rightarrow\)</span> addr）<ul><li>索引表：表内索引必须按主关键字key有序排列</li><li>主文件：主文件中的记录可按主关键字有序组织 or 无序组织</li></ul></li><li>散列文件组织：一个文件有N个桶，将键值为k的记录存储在 hash(k)对应的桶中， <br>处理溢出使用<u>主桶</u> 链接 多个<u>溢出桶</u></li><li>聚集文件组织：将具有<u>相同属性值</u>的<strong>记录</strong>存储在<strong>连续的磁盘块</strong>中<br>一个文件可容纳来自多个关系的记录，适用于连表查询（一次性拿出聚集项），但单表访问会变慢</li></ul></li></ul><hr><h3 id="三缓冲区管理">三、缓冲区管理</h3><ul><li><p>缓冲区：内存中的页面数组（元素称为“帧”，存放一个磁盘块副本），页表项包含以下元数据</p><ul><li>Dirty Flag：线程对页修改后设置，通知存储管理器该页必须写回磁盘</li><li>Pin计数器：缓冲页被读写操作时要被Pin住，防止该页被移出</li></ul></li><li><p>加锁与替换：</p><ul><li>加锁：读操作加共享锁、更新操作加排他锁</li><li>替换：LRU (Least Recently Used)</li></ul><hr></li><li><p>缓冲区管理器：负责缓存空间分配，以及内外存间的交换</p></li><li><p>执行引擎操作磁盘块：</p><ul><li>该块在缓冲区中，直接返回该块在内存中的地址</li><li>该块不在缓冲区，将该块<strong>调入缓冲区</strong>，并将其内存地址返回给调用者</li></ul></li><li><p>缓冲区管理目标：最小化<u>磁盘</u>与<u>主存</u>间的传输存储块的数量，可通过在主存中保持尽可能多的块实现</p></li></ul><hr><h3 id="四索引">四、索引</h3><ul><li><p>索引记录（索引项）：索引文件由索引记录组成，包括 索引域 +指针</p><ul><li>索引域：存储数据文件中的一个 or 一组域（<strong>属性</strong>）</li><li>指针：指向<u>索引域值为K</u>的记录所在磁盘块的<strong>地址</strong></li></ul></li><li><p>排序索引：索引项是排序的</p></li><li><p>哈希索引：索引项使用索引域上的 hash 函数确定位置</p><hr></li><li><p>聚集索引与非聚集索引：</p><ul><li>聚集索引：<u>索引域</u>的排列顺序与<u>对应记录</u>在文件中的排列顺序<strong>一致</strong></li><li>非聚集索引：<u>索引域</u>的排列顺序与<u>对应记录</u>在文件中的排列顺序<strong>不一致</strong></li></ul></li><li><p>稠密索引与非稠密索引：</p><ul><li>稠密索引：文件中的每个<u>搜索码值</u>都有对应的一个<u>索引项</u></li><li>非稠密索引：仅文件中的部分搜索码值有索引记录，仅当<u>文件记录<strong>按索引域排序</strong></u>时可以使用<br><strong>注意</strong>：由于非聚集索引不必按索引域值排序，故非聚集索引都是稠密索引</li></ul></li><li><p>多级索引：<strong>外层索引</strong>作为基本索引的稀疏索引；<strong>内层索引</strong>作为基本索引文件，指向数据块<br>多级索引一般分为“二叉树索引”和“多叉树索引”，可能会导致“非平衡问题”</p><hr></li><li><p>B树：一种自平衡树。根节点有[2, n]个子节点，中间节点有[<span class="math inline">\(\dfrac{n}{2}\)</span>,n]个子节点，叶节点有[(n-1)/2, n-1]个记录指针<strong>注意</strong>：B树的关键字散布在各层；所有叶节点都在同一层上</p></li><li><p>B+树：B树的一种改进，将<strong>所有关键字</strong>按<u>从左到右递增</u>的顺序安排在叶节点上，并用<span class="math inline">\(\text{P}_n\)</span>指针链接起来</p><p><img src="/2023/11/07/database/memory-management/B+树.png" width="70%"></p><ul><li>查询：从树的根节点开始，比较搜索码V和节点关键字K向下遍历B+树，返回叶节点的记录指针</li><li>插入：考虑两种情况<ul><li>若叶节点未满直接插入即可（<span class="math inline">\(\le\)</span>m-1）</li><li>否则将插入后的叶节点拆成左右两半，并在两个新叶节点间插入父节点索引</li></ul></li></ul><hr></li><li><p>Hash 索引：基于哈希表实现</p><ul><li><p>哈希表（散列表）：记录 Key <span class="math inline">\(\rightarrow\)</span> Value 的映射，实现了 Hash函数</p></li><li><p>哈希方案：解决<u>一个哈希</u>对应<u>多个冲突</u>的方法，一般采用溢出链接法（桶链表）</p><hr></li><li><p>静态哈希：哈希表的大小固定，但太多的溢出桶会导致访问性能降低</p></li><li><p>动态哈希：哈希表的大小可动态修改（重哈希），定期重哈希or线性哈希</p></li></ul><p><strong>注意</strong>：Hash索引适用于哈希码取特殊值的记录检索，不适用于区间or部分匹配；有多个重复值的列不适合做key</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>『compiler-7』optimization</title>
    <link href="/2023/11/05/compiler/optimization/"/>
    <url>/2023/11/05/compiler/optimization/</url>
    
    <content type="html"><![CDATA[<h2 id="代码优化">代码优化</h2><h3 id="一基本块与流图">一、基本块与流图</h3><ul><li><p>基本块：一段<u>顺序执行</u>的代码块，满足以下三条性质：</p><ul><li>基本块中的代码是<strong>连续</strong>的语句序列</li><li>程序的执行只能从基本块的<strong>第一条</strong>语句<u>进入</u></li><li>程序的执行只能从基本块的<strong>最后一条</strong>语句<u>离开</u></li></ul><p><strong>注意</strong>：每条中间代码属于且仅属于一个基本块</p></li><li><p>流图：<u>节点</u>是<strong>基本块</strong>、<u>有向边</u>表示基本块之间的<strong>前驱后继关系</strong>（转移、条件假转移、紧随块）</p><hr></li><li><p>基本块划分算法：输入中间代码语句序列，输出基本块序列</p><ol type="1"><li><p>确定<strong>入口语句</strong>：</p><ul><li><u>整个语句序列</u>的<strong>第一条</strong>语句是入口语句</li><li>由转移（有条件or无条件）语句<strong>转移到的首条语句</strong>属于入口语句</li><li><strong>紧跟在跳转语句之后的首条语句</strong>属于入口语句</li></ul><p><strong>注意</strong>：第二种表示基本块的<strong>起点</strong>、第三种表示基本块的<strong>出口</strong></p></li><li><p>确定<strong>基本块内容</strong>：<u>入口语句</u>直到<u>下一条入口语句</u>（or结束语句）之间的所有语句属于同一个基本块</p></li></ol></li><li><p>基本块内优化：消除局部公共子表达式、窥孔优化</p><ul><li><p>DAG图表示：DAG图是<strong>有向无环图</strong></p><ul><li>叶节点：由<u>变量名</u>or<u>常量值</u>所标记</li><li>中间节点：由中间代码中的<u>操作符</u>所标记</li></ul></li><li><p>消除局部公共子表达式：输入基本块内的中间代码序列，输出删除局部公共子表达式的DAG</p><ol type="1"><li>建立<strong>空节点表</strong>，该表条目记录了变量名（常量值）+节点序号（[x, i]）</li><li>从第一条中间代码开始，构建DAG：注意每一步用于分配的节点新编号都从“1”开始<strong>递增分配</strong><ol type="1"><li>设 z = x op y，x的节点编号为i（y同理），查找节点表：<ul><li>若找得到，先记下x的节点编号i（y同理，用于<u>下一步<strong>找op</strong></u>）</li><li>若找不到，在DAG中新建叶节点（标记为x），在节点表中增加新表项 (x,i)，y同理</li></ul></li><li>在DAG中寻找中间节点op，满足其<u>左操作数编号为i</u>，<u>右操作数编号为j</u><ul><li>若找得到，先记下op的节点编号k（用于<u>下一步更新z的编号</u>）</li><li>若找不到，设其编号为k，并在DAG中<strong>新建子树</strong>x-z-y，即把z的左右节点分别连接x和y</li></ul></li><li>在节点表中寻找z：<ul><li>若找得到，将z对应的节点编号<strong>更改为k</strong></li><li>若找不到，在节点表中增加新表项（z, k）</li></ul></li></ol></li><li>对所有中间代码重复上述操作步骤</li></ol><figure><p><img src="/2023/11/05/compiler/optimization/消除局部公共子表达式.png"></p></figure><p><strong>注意</strong>：在 z = x op y 中， x 和 y<strong>均可为空</strong>；若 op 为空，则 z 的编号由 x（或y）赋值</p></li><li><p>从DAG图重新导出中间代码：输入DAG，输出中间代码序列</p><ol type="1"><li>初始化放置DAG图的<strong>中间节点</strong>的空栈</li><li>若DAG中<u><strong>所有中间节点</strong>都已进入栈</u>，则直接转入最终步骤v.</li><li>否则，选取一个尚未进入节点栈，但其<u><strong>所有父节点</strong>都已进入节点栈</u>的<strong>中间节点n</strong>，将其推入栈<br>或者 选择<u>没有父节点</u>的中间节点n，将其推入栈</li><li>沿着n的<u><strong>最左</strong>子节点链</u>，将<u><strong>符合iii.中条件</strong></u>的中间节点推入栈，直到不满足iii.条件就重新转入ii.</li><li>最后，将节点栈中的各中间节点<strong>依次弹出</strong>，整理成中间代码序列</li></ol><figure style="text-align:center"><p><img src="/2023/11/05/compiler/optimization/从DAG导出中间代码.png"> <figurecap>op节点实际应被看作存储运算结果 的中间节点</figurecap></p></figure></li></ul></li></ul><hr><ul><li><p>窥孔优化：“窥孔”指仅关注目标指令的一个<strong>较短序列</strong>；“优化”指删除（or改进）其中的部分代码</p></li><li><p>常数合并和常量传播：</p><ul><li>常数合并：将能够<u>在编译时</u>计算出值的表达式<strong>用相应的值替代</strong>，如A = 2 + 3 + C <span class="math inline">\(\Rightarrow\)</span> A = 5 +C</li><li>常量传播：<u>在编译时</u><strong>已知的变量值</strong>代替程序中对这些变量的引用</li></ul></li></ul><hr><h3 id="二全局优化">二、全局优化</h3><ul><li><p>数据流方程：out[S] = gen[S] <span class="math inline">\(\cup\)</span> (in[S] - kill[S])</p><ul><li>out[S]：表示在S末尾得到的数据流信息</li><li>gen[S]：表示在S本身产生的数据流信息</li><li>in[S]：表示进入S时的数据流信息</li><li>kill[S]：表示S注销的数据流信息</li></ul><figure style="text-align:center"><p><img src="/2023/11/05/compiler/optimization/数据流方程.png"></p></figure></li></ul><hr><ul><li><p>到达定义的数据流分析：分析某个<u>变量的值</u>是在哪里<u>被定义的</u>；自前向后计算</p><ul><li><p>设基本块中的某条<strong>定义语句</strong>为 d1: u := v opw，则由数据流方程为 out[d1] = gen[d1] <span class="math inline">\(\cup\)</span> (in[d1] - kill[d1])</p><ul><li>gen[d1] = { d1 }，表示 d1 语句产生了一个定义点</li><li>kill[d1]：包含<u>整个程序</u>中<strong>其它<u>所有</u>对 u定义</strong>的定义语句的集合</li></ul></li><li><p>基本块B的数据流方程：out[B] = gen[B] <span class="math inline">\(\cup\)</span> (in[B] - kill[B])</p><ul><li><p>kill[B] = kill[d1] <span class="math inline">\(\cup\)</span> ...<span class="math inline">\(\cup\)</span> kill[dn]</p></li><li><p>gen[B] = gen[dn] <span class="math inline">\(\cup\)</span>(gen[d(n-1)] - kill[dn]) <span class="math inline">\(\cup\)</span> ...<span class="math inline">\(\cup\)</span> (gen[d1] - kill[d2] - ... -kill[dn])</p><hr></li><li><p>in[B] = <span class="math inline">\(\bigcup_{\text{B的所有**前驱**基本块P}}\text{out[P]}\)</span></p></li><li><p>out[B]：直接由数据流方程导出</p></li></ul></li><li><p>到达定义数据流分析：<u>输入</u>程序流图、各基本块的kill与gen集合；<u>输出</u>各基本块的in和out集合</p><ol type="1"><li>将所有基本块的out集合初始化为<span class="math inline">\(\varnothing\)</span></li><li>根据in[B]和out[B]的公式，先后计算（更新）各基本块的in与out集合<br><strong>注意</strong>：若某个基本块的 out发生了改变，则要重新求解其<strong>所有后继块</strong>的 in 集合</li><li>若某一轮更新迭代中存在out[B]发生了<strong>变化</strong>，则循环迭代ii.直至所有out[B]都不再变化</li></ol></li></ul><hr></li><li><p>活跃变量分析：分析变量x在程序的某个点（及其之后的任意执行路径）是否被使用（活跃）；自后向前计算</p><ul><li><p>基本块B的数据流方程：in[B] = use[B] <span class="math inline">\(\cup\)</span> (out[B] - def[B])</p><ul><li><p>def[B]：基本块B中的，<u>定义</u>先于<u><strong>任何</strong>对其使用</u>的变量集合</p></li><li><p>use[B]：基本块B中的，<u>使用</u>先于<u><strong>任何</strong>对它的定义</u>的变量集合</p><hr></li><li><p>out[B] = <span class="math inline">\(\bigcup_{\text{B的所有**后继**基本块P}}\text{in[P]}\)</span></p></li><li><p>in[B]：直接由数据流方程导出</p></li></ul></li><li><p>活跃变量数据流分析：<u>输入</u>程序流图、各基本块的use与def集合；<u>输出</u>各基本块的in和out集合</p><ol type="1"><li>将所有基本块的in集合初始化为空集</li><li>根据out[B]和in[B]的计算公式，先后计算（更新）各基本块的out与in集合<br><strong>注意</strong>：若某个基本块的 in发生了改变，则要重新求解其<strong>所有前驱块</strong>的 out 集合</li><li>若某一轮更新迭代中存在in[B]发生了<strong>变化</strong>，则循环迭代ii.直至所有in[B]都不再变化</li></ol></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>compiler</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>『database-5』database design</title>
    <link href="/2023/10/26/database/database-design/"/>
    <url>/2023/10/26/database/database-design/</url>
    
    <content type="html"><![CDATA[<h2 id="数据库设计">数据库设计</h2><h3 id="一数据库设计阶段概览">一、数据库设计阶段概览</h3><ol type="1"><li><p>需求分析：对<u>应用环境</u>进行详细调查，收集支持系统目标的<strong>基础数据</strong>及其处理</p></li><li><p>数据库概念结构设计：</p><ul><li>对用户需求进行<u>综合</u>、<u>归纳</u>与<u>抽象</u></li><li>设计<u>独立于</u>数据库逻辑结构与DBMS的概念模型（可用 E-R图表示）</li></ul></li><li><p>数据库逻辑结构设计：</p><ul><li>将概念结构转换为某个DBMS所支持的数据模型，并作优化</li><li>将得到的逻辑结构转换成特定的DBMS能处理的<strong>模式</strong>、<strong>子模式</strong></li></ul></li><li><p>数据库物理结构设计：设计物理设备的<u>存储结构</u>与<u>存取方法</u></p><ol type="1"><li>确定数据库的<strong>内模式</strong></li><li>对物理结构进行时间与空间效率的<strong>评价</strong></li></ol></li><li><p>数据库实施：用<strong>DDL</strong>描述三级模式，并调试产生<strong>目标模式</strong>，组织数据入库并<strong>试运行</strong></p></li><li><p>数据库运行与维护：数据库正式运行后，由DBA对数据库维护</p><figure style="text-align:center"><p><img src="/2023/10/26/database/database-design/数据库设计基本步骤.png"><figurecap>数据库设计阶段</figurecap></p></figure></li></ol><hr><h3 id="二需求分析">二、需求分析</h3><ul><li><p>需求分析的目标：调查重点是“数据”与“处理”</p><ul><li>处理要求：用户需要完成何种<strong>处理功能</strong></li><li>信息要求：指系统中所涉及的<strong>数据</strong>及<strong>数据间联系</strong></li><li>安全性与完整性约束</li></ul></li><li><p>需求分析的步骤：</p><ol type="1"><li>调查用户实际需求，与用户达成共识</li><li>使用<u>数据流图</u>表达<strong>数据处理间的关系</strong>；使用<u>数据字典</u>描述系统中的<strong>各类数据</strong></li></ol></li><li><p>数据流图：以图形方式表达系统功能、数据在系统内部的逻辑流向</p><figure style="text-align:center"><p><img src="/2023/10/26/database/database-design/数据流图.png"> <figurecap>自顶向下分解的 销售管理系统数据流图</figurecap></p></figure><hr></li><li><p>数据字典：对数据库中数据的描述（即<strong>元数据</strong>），其原子单位是数据项，包含以下</p><ul><li>数据项语义定义：名字 + 实际含义</li><li>数据项类型定义：数据类型 + 数据宽度 + 小数位数</li><li>完整性约束定义：值约束 + 空值约束 + 其它完整性约束</li></ul><p><strong>注意</strong>：数据字典还包括数据在系统内的<u>传输路径</u>、<u>存储位置</u>等</p></li></ul><hr><h3 id="三概念结构设计">三、概念结构设计</h3><ul><li><p>E-R 法：使用 <strong>E-R图</strong> 描述现实世界</p></li><li><p>E-R 图：由<u>实体</u>、<u>联系</u>、<u>属性</u>构成</p></li><li><p>自底向上的 E-R图设计方法：先设计<strong>局部</strong>应用的概念结构，再将其<strong>集成</strong>起来</p><ul><li><p>局部 E-R 图设计：</p><ol type="1"><li>选择局部应用：将需求分解形成不同的概念模式</li><li>以需求分析中的数据元素为基础，利用<strong>数据抽象</strong>机制，得到<u>实体</u>与<u>属性</u><br><strong>注意</strong>：“数据抽象”包括分类（对象的类型）、聚集（类型的组成）和概括（类型间的联系）</li><li>确定实体间的联系类型，用 E-R图表示这些<u>实体与实体间的<strong>联系</strong></u>，形成分 E -R图</li></ol></li><li><p>综合局部 E-R 图：将分 E-R图<u>合并</u>，<u>消除冲突与冗余</u>，最终形成基本 E-R 图</p><ul><li><p>生成初步 E-R 图：消除分 E-R 图的冲突，需消除属性冲突 + 命名冲突 +结构冲突</p><ul><li>属性冲突：属性的<u>类型</u>、<u>取值范围</u>或<u>取值集合</u>不同</li><li>命名冲突：不同意义的对象具有相同名字 or相同意义的对象具有不同名字</li><li>结构冲突：同一对象在<u>不同应用</u>中具有<strong>不同层次的抽象</strong>；同一实体拥有<strong>不同的属性</strong></li></ul></li><li><p>生成基本 E-R 图：对初步 E-R图<strong>消除冗余</strong>；方法包括分析法 + 规范化</p><ul><li><p>冗余数据：可由基本数据<strong>导出</strong>的数据；系总人数 =<span class="math inline">\(\sum\text{各系人数}\)</span>，系总人数为冗余数据</p></li><li><p>冗余联系：可由其它联系<strong>导出</strong>的联系</p><hr></li><li><p><strong>规范化</strong>消除冗余联系：筛除分E-R图中的冗余关系</p><ol type="1"><li>确定分E-R图中的数据依赖：将<u>每对联系</u>表示为<u>实体码间</u>的<strong>函数依赖</strong>集合F</li><li>对上述依赖集进行<strong>极小化处理</strong>获得 <span class="math inline">\(\text{F}_m\)</span>，设 D = F - <span class="math inline">\(\text{F}_m\)</span></li><li>考察 D 中的每个依赖式，筛除其中的冗余联系</li></ol><p><strong>注意</strong>：冗余信息或许能够提高数据库效率，可以选择保留</p></li></ul></li></ul></li></ul></li></ul><hr><h3 id="三逻辑结构设计">三、逻辑结构设计</h3><ul><li>E-R 图向关系模式的转化：<ul><li>实体型 <span class="math inline">\(\Rightarrow\)</span>关系模式：关系的属性 <span class="math inline">\(\gets\)</span>实体的属性；关系的码 <span class="math inline">\(\gets\)</span>实体的码</li><li>联系 <span class="math inline">\(\Rightarrow\)</span>关系模式：关系的属性 <span class="math inline">\(\gets\)</span>各实体的<strong>码</strong> + <strong>联系的属性</strong><ul><li>1: 1联系：<u>每个实体的码</u>都是该关系的候选码</li><li>1:n联系：该关系的码是<u><strong>n端</strong>实体的码</u>（唯一确定性）</li><li>n:m联系：该关系的码是<u><strong>两端</strong>实体码的<strong>组合</strong></u>（唯一确定性）</li></ul></li></ul></li><li>关系模型的优化：考虑 <u>水平分解</u> + <u>垂直分解</u><ul><li>水平分解：将<strong>经常使用的那部分<u>元组</u></strong>分离出来单独作为一个关系</li><li>垂直分解：将关系模式R中<strong>经常在一起使用的<u>属性</u></strong>分解出来形成子模式</li></ul></li></ul><hr><h3 id="四物理结构设计">四、物理结构设计</h3><ul><li><p>数据库物理结构：包含物理设备上的 <u>存储结构</u> +<u>存取方法</u></p></li><li><p>存取方法：包括 索引 + 聚集 + HASH</p><ul><li><p>索引记录：索引文件中的记录，包括 索引域 + 指针；常用 B+ 树</p><ul><li>索引域：存储数据文件中若干域的<strong>特定值K</strong><br><strong>注意</strong>：索引域应选择<u>经常被查询</u>到的属性、max（min）函数的<u>参数</u>、<u>连接属性</u>等</li><li>指针：指向<strong>索引域值K</strong>的记录所<u>在磁盘块的地址</u></li></ul><p><strong>注意</strong>：索引也会占据内存，同时具有维护开销，故索引不是越多越好</p><figure style="text-align:center"><p><img src="/2023/10/26/database/database-design/B+树.png"> <figurecap>各关键字按递增顺序 从左到右链接在叶结点上</figurecap></p></figure></li><li><p>聚集：将在若干属性上<u>值相同</u>的记录集中存放在<strong>连续的物理块</strong>上</p><ul><li>选择原则：经常进行<u>自然连接</u>操作的关系、某属性<u>值重复率高</u>的模式</li></ul><p><strong>注意</strong>：建立聚集系统的开销很大，对于更新操作<strong>远多于连接操作</strong>的关系，不应建立聚集</p></li><li><p>HASH：利用hash函数将<strong>记录关键字</strong>转化为地址；记录r（A上值为a）的存储地址addr = hash(a)</p><figure style="text-align:center"><p><img src="/2023/10/26/database/database-design/HASH.png"> <figurecap>Hash查找</figurecap></p></figure></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>『compiler-6』syntax directed translation</title>
    <link href="/2023/10/18/compiler/syntax-directed-translation/"/>
    <url>/2023/10/18/compiler/syntax-directed-translation/</url>
    
    <content type="html"><![CDATA[<h2 id="语法制导翻译">语法制导翻译</h2><h3 id="一翻译文法">一、翻译文法</h3><ul><li><p>输入文法：未插入动作符号的文法，可以推导产生输入序列</p></li><li><p>翻译文法：一种上下文无关文法，其终结符号集合由<strong>输入符号 +动作符号（@）</strong>组成，可以推导产生活动序列</p><hr></li><li><p>活动序列：插入了动作符号的输入序列，由<strong>终结符和动作符号</strong>组成</p></li><li><p>输入序列：从活动序列中<u>抽去动作符号</u>，得到输入序列（原始的程序输入）</p></li><li><p>输出序列：从活动序列中<u>抽去输入序列</u>，得到动作序列（执行动作序列完成翻译任务）</p></li></ul><hr><h3 id="二语法制导的翻译">二、语法制导的翻译</h3><ul><li>语法制导翻译的定义：根据翻译文法的翻译获得<strong>动作序列</strong>，并<strong>执行</strong>该动作序列</li><li>语法制导翻译的实现方法：<ol type="1"><li>在文法的适当位置插入语义动作符号</li><li>获得对偶序列，对偶的第一元为<strong>输入序列</strong>、第二元为<strong>动作符号序列</strong></li></ol></li></ul><hr><h3 id="三属性翻译文法">三、属性翻译文法</h3><ul><li>属性：在翻译文法的基础上，为<u>非终结符</u>、<u>终结符</u>、<u>动作符号</u>赋予属性，表示参数值<ul><li>综合属性：按照自右向左、自底向上的顺序求值，如属性变量 <span class="math inline">\(\uparrow p\)</span></li><li>继承属性：按照自左向右、自顶向下的顺序求值，如属性变量 <span class="math inline">\(\downarrow q\)</span></li></ul></li></ul><hr><h3 id="四l-属性翻译文法l-atg">四、L-属性翻译文法（L-ATG）</h3><ul><li><p>L-ATG 的定义：</p><ul><li><p>文法中的<u>终结符</u>、<u>非终结符</u>、<u>动作符号</u>都带有属性</p></li><li><p>非终结符和动作符号的属性可分为<strong>继承属性</strong>和<strong>综合属性</strong></p></li><li><p><strong>开始符号的继承属性</strong> 和<strong>终结符的综合属性</strong>具有指定初始值</p></li><li><p>继承属性的求值规则：</p><ul><li><strong>规则左部非终结符</strong>的继承属性，取自<strong>上面规则右部</strong>该符号的继承属性（取自己已有即可）</li><li><strong>规则右部符号</strong>的继承属性，用<strong>该规则左部符号</strong>的继承属性or出现在<strong>该符号左侧符号</strong>的属性计算<br><strong>注意</strong>：自顶向下（自左向右）：取自父节点的继承属性 或依据父节点和左兄弟属性计算</li></ul></li><li><p>综合属性的求值规则：</p><ul><li><strong>规则右部非终结符</strong>的综合属性，取自<strong>下面规则左部</strong>该符号的综合属性（取自己已有即可）</li><li><strong>规则左部非终结符</strong>的综合属性，用<strong>该规则左部符号</strong>的继承属性or<strong>某个右部符号</strong>的属性计算<br><strong>注意</strong>：自底向上（自右向左）：取自自己的继承属性 或依据子节点属性计算</li><li><strong>动作符号</strong>的综合属性使用<strong>该符号的继承属性</strong>或<strong>某个右部符号</strong>的属性计算</li></ul><p><strong>注意</strong>：理解<u>继承属性</u>和<u>综合属性</u>，可以从<strong>函数传参与返回值</strong>的角度考虑：</p><ul><li>继承属性：作为入参（形参）<ul><li>左部的继承属性：必然由其上方规则右部的继承属性值<strong>传入</strong></li><li>右部的继承属性（形参）：只能使用该产生式<u>已经求出</u>（即左侧）的属性值计算</li></ul></li><li>综合属性：作为返回值（地址）<ul><li>右部的综合属性：必然由其下方规则左部的综合属性值<strong>返回</strong></li><li>左部的综合属性：只能使用该产生式对应过程的入参（继承属性）or右部属性（过程内部的局部变量）计算</li></ul></li></ul></li></ul></li></ul><hr><h3 id="五简单赋值形式的-l-atgsl-atg">五、简单赋值形式的L-ATG（SL-ATG）</h3><ul><li><p>简单赋值形式的 L-ATG文法：将属性求值规则简化为<u>仅简单赋值形式</u>的</p></li><li><p>SL-ATG 的定义：L-ATG 是一个SL-ATG，当且仅当满足以下两个条件：</p><ul><li>规则右部符号的继承属性是一个<strong>常量</strong>，其<strong>等于</strong><u>规则左部符号的继承属性值</u>，或<u>该符号左侧</u>的综合属性值</li><li>规则左部符号的综合属性是一个<strong>常量</strong>，其<strong>等于</strong><u>规则左部符号的继承属性</u>，或<u>右部符号</u>的综合属性</li></ul></li><li><p>将 L-ATG 改写为 SL-ATG：设有求值函数 f 及其求值规则 I :=f(R,S)</p><figure><p><img src="/2023/10/18/compiler/syntax-directed-translation/改写SL-ATG.png"></p></figure><p><strong>注意</strong>：如果将 <span class="citation" data-cites="f">@f</span> 插入到 a 后 &lt;B&gt; 前，继承属性 <span class="math inline">\(\text{I}_2\)</span> 就无法借助 S求出值（违反了L-ATG中继承属性的求值规则）</p></li></ul><hr><h3 id="六自顶向下的语法制导翻译">六、自顶向下的语法制导翻译</h3><ul><li><p>翻译文法的自顶向下翻译（无参数）：直接在解析到对应位置时<strong>执行动作符号</strong>即可</p><figure style="text-align:center"><p><img src="/2023/10/18/compiler/syntax-directed-translation/翻译文法自顶向下.png" width="60%"></p></figure></li><li><p>属性翻译文法的自顶向下翻译（含形参与引用）</p><ul><li><p><u>符号下</u>的属性传递：</p><ul><li>继承属性：属性名作为解析程序的形参（<strong>传值</strong>）</li><li>综合属性：属性名作为解析程序的指针参数（<strong>传地址</strong>），支持收集返回值</li></ul></li><li><p>属性命名规定：</p><ul><li>产生式<u>左部</u>的<strong>同名非终结符</strong>必须使用<strong>相同的属性名</strong></li><li>具有<u><strong>相同值</strong>的属性</u>拥有<u>相同的属性名</u></li></ul></li><li><p>翻译示例：设 <span class="math inline">\(\text{&lt;A&gt;}_{\uparrow \text{P}} \rightarrowc_{\uparrow U} @y_{\downarrow U} \text{ &lt;A&gt;}_{\uparrow Q} \text{S}_{\downarrow z} @v_{\downarrow P}b\)</span> ；求值规则为：P := Q +U、Z := U - 3<br>其中<u>左部P</u>是综合属性，传入指针P；<u>U</u>是终结符c的综合属性，自带初始值；<u>Q和Z</u>分别传值和地址</p><figure style="text-align:center"><p><img src="/2023/10/18/compiler/syntax-directed-translation/属性翻译（上）.png" width="80%"><img src="/2023/10/18/compiler/syntax-directed-translation/属性翻译（下）.png" width="80%"></p></figure></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>compiler</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>『database-4』relational data theory</title>
    <link href="/2023/10/12/database/relational-data-theory/"/>
    <url>/2023/10/12/database/relational-data-theory/</url>
    
    <content type="html"><![CDATA[<h2 id="关系数据理论">关系数据理论</h2><h3 id="一函数依赖">一、函数依赖</h3><ul><li><p>函数依赖的定义：设 R(U) 是属性全集 U 上的关系模式，X、Y <span class="math inline">\(\subseteq\)</span> U，r $$ R，t、s <span class="math inline">\(\in\)</span> r <br>若 t[X] = s[X]，则有 t[Y] =t[Y]，称为 <strong>X 函数决定 Y</strong>，或 <strong>Y 函数依赖于X</strong>，记作 X <span class="math inline">\(\rightarrow\)</span> Y<br><strong>注意</strong>：X <span class="math inline">\(\rightarrow\)</span> Y可以表述为对于属性组X上的任一值，Y中有<u>唯一的值</u>与其对应</p></li><li><p>平凡与非平凡的函数依赖：设 X <span class="math inline">\(\rightarrow\)</span> Y</p><ul><li>平凡的函数依赖：若 Y <span class="math inline">\(\subseteq\)</span>X，则称 X <span class="math inline">\(\rightarrow\)</span> Y是<strong>平凡</strong>的函数依赖；任一关系模式下<u>平凡依赖总是成立</u></li><li>非平凡的函数依赖：若 Y <span class="math inline">\(\nsubseteq\)</span> X，则称 X <span class="math inline">\(\rightarrow\)</span> Y是<strong>非平凡</strong>的函数依赖</li></ul></li><li><p>决定因素：设 X <span class="math inline">\(\rightarrow\)</span>Y，则称 X 为<strong>决定因素</strong></p><figure style="text-align:Center"><p><img src="/2023/10/12/database/relational-data-theory/函数依赖例图.png"> <figurecap>从 X 到 Y满足单射</figurecap></p></figure><p><strong>注意</strong>：<strong>函数依赖不随时间而变</strong>；虽然关系R 随时间而变化，但 X <span class="math inline">\(\rightarrow\)</span> Y总保持不变</p></li><li><p>函数依赖与属性间联系：可分为 1 : 1、1 : n、n : m 三种</p><ul><li>一对一：若 X 与 Y 满足一对一关系（学号 与 身份证号），则有 X <span class="math inline">\(\leftrightarrow\)</span> Y</li><li>一对多：若 X 与 Y 满足一对多关系（部门号 与 部门员工号），则有且仅有Y <span class="math inline">\(\rightarrow\)</span> X</li><li>多对多：若 X 与 Y 满足多对多关系（学号 与 课程号），则 X 与 Y之间不存在函数依赖</li></ul><p><strong>注意</strong>：函数依赖是根据<strong>具体场景下的<u>语义</u></strong>确定的</p><hr></li><li><p>函数依赖类型：设关系模式 R(U) 下有 X <span class="math inline">\(\rightarrow\)</span> Y</p><ul><li>完全函数依赖：若对 X 的<u>任意真子集</u> X'，<strong>都有 X' <span class="math inline">\(\nrightarrow\)</span> Y</strong>，则 Y 对 X完全函数依赖，记作 X <span class="math inline">\(\xrightarrow{f}\)</span> Y</li><li>部分函数依赖：若不满足完全函数依赖，则为部分函数依赖，记作 X <span class="math inline">\(\xrightarrow{p}\)</span> Y</li><li>传递函数依赖：若 X <span class="math inline">\(\rightarrow\)</span>Y、Y <span class="math inline">\(\rightarrow\)</span> Z，但 Y <span class="math inline">\(\nrightarrow\)</span> X，则称 Z 对 X<strong>传递函数依赖</strong>，记作 X <span class="math inline">\(\xrightarrow{t}\)</span> Z<strong>注意</strong>：这里若 Y <span class="math inline">\(\rightarrow\)</span> X，相当于 X 与 Y之间满足<u>一对一关系</u>，故有 X <span class="math inline">\(\xrightarrow{直接}\)</span> Z，而不是间接依赖</li></ul><hr></li><li><p>候选码：设 K 为 R&lt;U, F&gt; 中的属性组，若 K <span class="math inline">\(\xrightarrow{f}\)</span> U，则称 K 是 R的候选码（主码是其中一个候选码）<br><strong>注意</strong>：“完全依赖”表明码具有<strong>最小性</strong>，若抽去任意一个属性该候选码将失去<strong>唯一标识性</strong></p></li><li><p>主属性与非主属性：</p><ul><li>主属性：包含在任意一个候选码中的属性</li><li>非主属性：不包含在任何码中的属性</li></ul><hr></li><li><p>逻辑蕴含：设关系模式为 R&lt;U, F&gt;，若可从 F中的函数依赖<strong>推导出</strong> X <span class="math inline">\(\rightarrow\)</span> Y，则称 F 逻辑蕴含 X <span class="math inline">\(\rightarrow\)</span> Y</p></li><li><p>函数依赖集F的闭包：为 F所<strong><u>逻辑蕴含</u>的函数依赖的全体</strong>称作F的闭包，记作<span class="math inline">\(\text{F}^+\)</span></p></li><li><p>Armstrong公理系统：设关系模式为 R&lt;U, F&gt;</p><ul><li>自反律：若 Y <span class="math inline">\(\subseteq\)</span> X，则 X<span class="math inline">\(\rightarrow\)</span> Y 为 F所蕴含（平凡依赖）</li><li>增广律：若 X <span class="math inline">\(\rightarrow\)</span> Y 被 F所蕴含，则 XZ <span class="math inline">\(\rightarrow\)</span> YZ 被 F所蕴含（可拼接相同的属性组）</li><li>传递律：若 X <span class="math inline">\(\rightarrow\)</span> Y 和 Y<span class="math inline">\(\rightarrow\)</span> Z 为 F 所蕴含，则 X<span class="math inline">\(\rightarrow\)</span> Z 为 F所蕴含（注意这不是传递依赖）</li></ul></li><li><p>Armstrong公理系统推论：</p><ul><li><p>合并规则：设 X <span class="math inline">\(\rightarrow\)</span>Y，X <span class="math inline">\(\rightarrow\)</span> Z，有 X <span class="math inline">\(\rightarrow\)</span> YZ（直接用定义证明）</p></li><li><p>伪传递规则：设 X <span class="math inline">\(\rightarrow\)</span>Y、WY <span class="math inline">\(\rightarrow\)</span> Z，有 WX <span class="math inline">\(\rightarrow\)</span> Z（增广律WX <span class="math inline">\(\rightarrow\)</span> WY + 传递律）</p></li><li><p>分解规则：设 X <span class="math inline">\(\rightarrow\)</span>Y，若 Z <span class="math inline">\(\subseteq\)</span> Y，有 X <span class="math inline">\(\rightarrow\)</span> Z（自反律Y <span class="math inline">\(\rightarrow\)</span> Z + 传递律）</p><hr></li><li><p>合并规则 + 分解规则：X <span class="math inline">\(\rightarrow\)</span> <span class="math inline">\(A_1A_2\dots A_k\)</span> 成立 <span class="math inline">\(\Leftrightarrow\)</span> X <span class="math inline">\(\rightarrow A_i\)</span> 成立（i = 1, 2, ...,k）</p></li></ul></li><li><p>依赖集的闭包：设关系模式为 R&lt;U, F&gt;，为 F所<strong>逻辑蕴含的函数依赖的全体</strong>称作 F 的闭包，记作 <span class="math inline">\(\text{F}^+\)</span></p></li><li><p>属性集X关于依赖集F的闭包：设关系模式 R&lt;U, F&gt;，且 X <span class="math inline">\(\subseteq\)</span> U <br><span class="math inline">\(X_F^+ = \{A \text{ | } X \rightarrow A \text{能由F根据Armstrong公理推导出}\}\)</span>（可理解为<u>X所能决定的</u><strong>属性</strong>集合）</p><p>如何求解 <span class="math inline">\(X_F^+\)</span>？利用以下算法<strong>反复迭代</strong>（计算不动点）</p><figure style="text-align:center"><p><img src="/2023/10/12/database/relational-data-theory/闭包算法.png"></p></figure><p><strong>注意</strong>：迭代中的每一步，是抽取闭包集合中的一个<u>属性<strong>子集A</strong></u>，查找是否存在由<u>以该子集为<strong>决定因素</strong></u>的函数依赖</p></li><li><p><strong>定理</strong>：X <span class="math inline">\(\rightarrow\)</span> Y 能够由 F 根据 Armstrong公理导出 <span class="math inline">\(\Leftrightarrow\)</span> Y <span class="math inline">\(\subseteq\)</span> <span class="math inline">\(\text{X}_F^+\)</span></p></li><li><p>Armstrong公理系统的有效性与完备性:</p><ul><li>有效性：由 F 出发根据 Armstrong公理推导出的<strong>每个函数依赖</strong>必定在 F所蕴含的函数依赖的全体中</li><li>完备性：F 所蕴含的函数依赖全体为 <span class="math inline">\(\text{F}^+\)</span>中的<strong>每个函数依赖</strong>，必可由F根据Armstrong公理导出</li></ul><hr></li><li><p>函数依赖集等价：设函数依赖集F、G，若<span class="math inline">\(\text{F}^+ = \text{G}^+\)</span>，则称 F 与 G等价；<span class="math inline">\(\text{F}^+ = \text{G}^+\Leftrightarrow \text{F} \subseteq \text{G}^+\)</span> 且 <span class="math inline">\(\text{G} \subseteq \text{F}^+\)</span></p></li><li><p>极小依赖集：若 F 同时满足下列条件，则称 F为一个极小函数依赖集</p><ol type="1"><li>依赖右部A必须是<strong>单属性</strong>：F 中的任一函数依赖 X <span class="math inline">\(\rightarrow\)</span> A，A 必须是单属性的</li><li>不存在<strong>多余的函数依赖</strong> X <span class="math inline">\(\rightarrow\)</span> A：F 中不存在函数依赖 X <span class="math inline">\(\rightarrow\)</span> A，使得 F 与 F - {X <span class="math inline">\(\rightarrow\)</span> A} 等价</li><li>依赖<strong>左部无多余属性Z</strong>：F 中不存在函数依赖 X <span class="math inline">\(\rightarrow\)</span> A，使得 Z <span class="math inline">\(\subset\)</span> A，F 与 F - {X <span class="math inline">\(\rightarrow\)</span> A} <span class="math inline">\(\cup\)</span> {Z <span class="math inline">\(\rightarrow\)</span> A} 等价</li></ol></li><li><p>依赖集的极小化算法：每个函数依赖集 F 均等价于一个极小依赖集 <span class="math inline">\(\text{F}_m\)</span></p><ol type="1"><li>对 F 中的所有依赖 X <span class="math inline">\(\rightarrow\)</span><span class="math inline">\(A_1A_2\dots A_n\)</span>，直接用 X <span class="math inline">\(\rightarrow\)</span> <span class="math inline">\(A_k\)</span>（k = 1, ...,n）替代它（右部单属性化）</li><li>对 F 中的所有依赖X <span class="math inline">\(\rightarrow\)</span>A，设X = <span class="math inline">\(B_1B_2\dots B_n\)</span>，若A <span class="math inline">\(\in\)</span> <span class="math inline">\((X -B_i)_F^+\)</span>，则X = X - <span class="math inline">\(B_i\)</span>（消去左部多余属性）<br><strong>注意</strong>：这一步 <u>不需要</u> 更改依赖集合 F</li><li>对 F 中的所有依赖 X <span class="math inline">\(\rightarrow\)</span>A，令 G = F - {X <span class="math inline">\(\rightarrow\)</span> A}，若A <span class="math inline">\(\in\)</span> <span class="math inline">\((X)_G^+\)</span>，则从F中去掉 X <span class="math inline">\(\rightarrow\)</span> A（消去多余依赖）</li></ol></li></ul><hr><h3 id="二规范化">二、规范化</h3><ul><li><p>范式的等级：1NF <span class="math inline">\(\supset\)</span> 2NF<span class="math inline">\(\supset\)</span> 3NF <span class="math inline">\(\supset\)</span> BCNF <span class="math inline">\(\supset\)</span> 4NF <span class="math inline">\(\supset\)</span>5NF；低级关系模式可以<strong>分解</strong>为若干高一级的关系模式</p></li><li><p>1NF：关系表中每一行和列的交叉位置上总是一个单一的值（而非值的集合），即不允许“表中套表”</p></li><li><p>2NF：R <span class="math inline">\(\in\)</span> 1NF，且每个<strong>非主属性<u>完全依赖</u>于所有候选码</strong></p><ul><li>1NF <span class="math inline">\(\rightarrow\)</span>2NF：将不完全依赖于码的非主属性A<strong>分离出来</strong>，<u>与其依赖的主属性搭配</u>起来形成新的2NF模式</li></ul></li><li><p>3NF：R <span class="math inline">\(\in\)</span>2NF（非主属性不部分依赖于任何候选码），且每个<strong>非主属性都<u>不传递依赖于</u>的任何候选码</strong></p><ul><li>2NF <span class="math inline">\(\rightarrow\)</span>3NF：将传递路径上的各<u>决定因素</u>分离出来作为新的码，<strong>切断原先的传递路径</strong></li></ul></li><li><p>BCNF：设关系模式 R&lt;U, F&gt;，若 F中的每个<strong>决定因素都<u>包含了候选码</u></strong>，则 R <span class="math inline">\(\in\)</span> BCNF<br><strong>注意</strong>：根据上述定义，BCNF也可以定义为：不存在<u><strong>主属性</strong></u>和非主属性，部分依赖or传递依赖于任何候选码</p><ul><li>所有非主属性都完全函数依赖于每个候选码</li><li>所有<u><strong>主属性</strong></u>都完全函数依赖于每个不包含它的候选码</li><li>没有任何属性完全函数依赖于非码的任何一组属性</li></ul><p><strong>注意</strong>：若决定因素仅包含候选码的<u>一部分</u>，则存在对候选码的<strong>部分依赖</strong><br>若决定因素<u>不包含</u>候选码，则存在对候选码的<strong>传递依赖</strong></p></li></ul><hr><h3 id="三多值依赖与第四范式">三、多值依赖与第四范式</h3><ul><li><p>多值依赖的定义：设关系模式为 R(U)，X、Y、Z <span class="math inline">\(\subseteq\)</span> U，且 Z = U - X - Y（Z 与X和Y均互不相容） <br>给定（X, Z）下的<u>任一值</u>（x, z），有<u>一组 Y的值</u> <span class="math inline">\(\{y \text{ | } y \in\text{Dom(Y)}\}\)</span>，使得该组Y值<strong><u>仅取决于x值</u>而与z值无关</strong><br>记作 X <span class="math inline">\(\rightarrow \rightarrow\)</span>Y <br><strong>注意</strong>：多值依赖反映了属性之间 <strong>1 :n</strong>的关系，常出现在<strong>同一组织下客体间<u>双向全选</u></strong>的情景中</p></li><li><p>关系中存在多值依赖：找到<strong>X值相同</strong>的两个元组，仅交换Y值，若两个<strong>新的元组均仍在原关系中</strong>，说明X <span class="math inline">\(\rightarrow \rightarrow\)</span> Y<br><strong>注意</strong>：上述方法说明，只需取定X的值，就足以对<u>Y的值集</u>产生决定性影响</p></li><li><p>平凡与非平凡的多值依赖：设 X <span class="math inline">\(\rightarrow \rightarrow\)</span> Y，Z = U - X -Y</p><ul><li>平凡多值依赖：若 Z = <span class="math inline">\(\varnothing\)</span>，则为平凡多值依赖（U仅由X和Y组成）</li><li>非平凡多值依赖：若 Z <span class="math inline">\(\ne\)</span> <span class="math inline">\(\varnothing\)</span>，则为非平凡多值依赖（U除了X和Y，还有Z）</li></ul></li><li><p>多值依赖的性质：设 Z = U - X - Y</p><ul><li>对称性：若 X <span class="math inline">\(\rightarrow\rightarrow\)</span> Y，则 X <span class="math inline">\(\rightarrow\rightarrow\)</span> Z（Y 与 Z 对称）</li><li>传递性：若 X <span class="math inline">\(\rightarrow\rightarrow\)</span> Y，Y <span class="math inline">\(\rightarrow\rightarrow\)</span> Z，则 X <span class="math inline">\(\rightarrow\rightarrow\)</span> Z - Y</li><li>X <span class="math inline">\(\rightarrow\)</span> Y 可以看作是 X<span class="math inline">\(\rightarrow \rightarrow\)</span> Y的特殊情况 （Y值集 <span class="math inline">\(\Rightarrow\)</span>Y单值）<ul><li>若 X <span class="math inline">\(\rightarrow \rightarrow\)</span>Y，X <span class="math inline">\(\rightarrow \rightarrow\)</span>Z，则有 X <span class="math inline">\(\rightarrow \rightarrow\)</span>YZ</li><li>若 X <span class="math inline">\(\rightarrow \rightarrow\)</span>Y，X <span class="math inline">\(\rightarrow \rightarrow\)</span>Z，则有 X <span class="math inline">\(\rightarrow \rightarrow\)</span> Y<span class="math inline">\(\cap\)</span> Z</li><li>若 X <span class="math inline">\(\rightarrow \rightarrow\)</span>Y，X <span class="math inline">\(\rightarrow \rightarrow\)</span>Z，则有 X <span class="math inline">\(\rightarrow \rightarrow\)</span> Y- Z，X <span class="math inline">\(\rightarrow \rightarrow\)</span> Z -Y</li></ul></li></ul></li><li><p>多值依赖与函数依赖的区别：</p><ul><li>X <span class="math inline">\(\rightarrow \rightarrow\)</span> Y 在U 上成立，则必在W（XY <span class="math inline">\(\subseteq\)</span> W<span class="math inline">\(\subseteq\)</span>U）上成立，<u><strong>反之不一定</strong></u>（多值依赖与其余属性Z有关）<br>X <span class="math inline">\(\rightarrow\)</span> Y在任意属性集W（XY <span class="math inline">\(\subseteq\)</span> W <span class="math inline">\(\subseteq\)</span> U）上总是成立</li><li>X <span class="math inline">\(\rightarrow\)</span> Y 在 R(U)上成立，则对于任意 Y' <span class="math inline">\(\subseteq\)</span>Y，X <span class="math inline">\(\rightarrow\)</span> Y' 总是成立 <br>X<span class="math inline">\(\rightarrow \rightarrow\)</span> Y 在 R(U)上成立，但对于任意 Y' <span class="math inline">\(\subseteq\)</span>Y，X <span class="math inline">\(\rightarrow \rightarrow\)</span> Y'不一定成立</li></ul><hr></li><li><p>4NF：设关系模式 R&lt;U, F&gt;，对于R的每个<u>非平凡的多值依赖</u>X <span class="math inline">\(\rightarrow \rightarrow\)</span>Y，<strong>X都含有码</strong><br>由于“码”表示依赖具有<strong>唯一值性</strong>，故非平凡<u>且左部含码</u>的多值依赖本质上即为<u><strong>函数依赖</strong></u><br><strong>注意</strong>：4NF也可定义为：R <span class="math inline">\(\in\)</span>BCNF，且不存在<strong><u>非平凡的非函数依赖</u>的多值依赖</strong></p></li><li><p>规范化过程：见下图</p><figure><p><img src="/2023/10/12/database/relational-data-theory/规范化过程.png"></p></figure></li><li><p>证明 (x+1)NF <span class="math inline">\(\subset\)</span>xNF：反设 R <span class="math inline">\(\in\)</span> (x+1)NF 且 R <span class="math inline">\(\notin\)</span> xNF， 由 xNF 的反向性质推出(x+1)NF 的矛盾</p></li></ul><hr><h3 id="四模式分解理论">四、模式分解理论</h3><ul><li><p>关系模式分解：</p><ul><li>函数依赖的投影 <span class="math inline">\(F_i\)</span>：<span class="math inline">\(F_i = \{X \rightarrow Y \text{ | }X \rightarrow Y\in F^+ \land XY \subseteq U_i\}\)</span>，称 <span class="math inline">\(F_i\)</span> 为 <strong>F 在 <span class="math inline">\(U_i\)</span> 上的投影</strong><br><strong>注意</strong>：函数依赖的分集合要求依赖的<strong>左右两侧必须均在<span class="math inline">\(U_i\)</span>中</strong>，且 <strong>X <span class="math inline">\(\rightarrow\)</span> Y可由 F 推导</strong></li><li>关系模式的分解 <span class="math inline">\(\rho\)</span>：<span class="math inline">\(\rho = \{R_1&lt;U_1, F_1&gt;, \dots,R_n&lt;U_n,F_n&gt;\}\)</span> 其中 $_{i=1}^n U_i = $ U，且不存在 <span class="math inline">\(U_i \subseteq U_j\)</span>（i <span class="math inline">\(\ne\)</span> j）</li></ul></li><li><p>无损分解：设 <span class="math inline">\(\rho = \{R_1&lt;U_1,F_1&gt;, \dots ,R_n&lt;U_n, F_n&gt;\}\)</span> 是 R&lt;U, F&gt;的一个<strong>分解</strong>，定义 <span class="math inline">\(m_{\rho} =\Join \Pi_{R_i}(r)\)</span> <br>其中 <span class="math inline">\(\Pi_{R_i}(r)\)</span> 为 关系 r <span class="math inline">\(\in\)</span> R 上关于对应属性列 <span class="math inline">\(U_i\)</span> 的<strong>投影</strong>，<span class="math inline">\(\Join \Pi_{R_i}(r)\)</span>表示将<strong><u>各分模式上的属性列</u>连接起来</strong><br>若对<strong>任意关系</strong> r <span class="math inline">\(\in\)</span> R，都有 r = <span class="math inline">\(m_{\rho}(r)\)</span>，则称 <span class="math inline">\(\rho\)</span> 为无损分解</p></li><li><p>无损分解的判定算法：设 <span class="math inline">\(\rho =\{R_1&lt;U_1, F_1&gt;, \dots,R_k&lt;U_k, F_k&gt;\}\)</span>，<span class="math inline">\(U = \{A_1, \dots A_n\}\)</span></p><ol type="1"><li>建立n列k行的二维表M：列表示属性<span class="math inline">\(A_i\)</span>、行表示一个分模式<span class="math inline">\(R_i\)</span></li><li>初始化二维表：若 <span class="math inline">\(A_j \inU_i\)</span>，则 <span class="math inline">\(m_{ij} = a_j\)</span>；若<span class="math inline">\(A_j \notin U_i\)</span>，则 <span class="math inline">\(m_{ij} = b_{ij}\)</span></li><li>对 <span class="math inline">\(F_i\)</span> 中的<u>每个函数依赖</u>X <span class="math inline">\(\rightarrow\)</span>Y，若M中存在<u>横向元组</u><span class="math inline">\(t_1\)</span>、<span class="math inline">\(t_2\)</span>，使得 <span class="math inline">\(t_1[X] =t_2[X]\)</span>，则对<strong>每个</strong><span class="math inline">\(A_i \in Y\)</span>：<ul><li>若 <span class="math inline">\(t_1[A_i] = t_2[A_i]\)</span>中有一个为 <span class="math inline">\(a_i\)</span>，则将另一个也改成<span class="math inline">\(a_i\)</span></li><li>否则，令 <span class="math inline">\(t_1[A_i] \getst_2[A_i]\)</span>（二维表中<span class="math inline">\(t_1\)</span>在<span class="math inline">\(t_2\)</span>的上方）</li></ul></li><li>反复迭代第3步，根据最终结果判断是否为无损分解：<ul><li>若二维表中的某行为 <span class="math inline">\(a_1\dotsa_n\)</span>，则为无损分解</li><li>否则，为有损分解</li></ul></li></ol></li><li><p>无损分解的充要条件：设 R&lt;U, F&gt; 的一个分解为 <span class="math inline">\(\rho = \{R_1&lt;U_1, F_1&gt;,R_2&lt;U_2,F_2&gt;\}\)</span> <br><span class="math inline">\(\rho\)</span>为无损分解 <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(R_1\)</span> 和 <span class="math inline">\(R_2\)</span> 的<u>共同属性</u>至少构成 <span class="math inline">\(R_1\)</span>、<span class="math inline">\(R_2\)</span> <strong>之一的候选码</strong>，即<span class="math inline">\(U_1 \cap U_2 \rightarrow U_1 - U_2 \inF^+\)</span></p><figure><p><img src="/2023/10/12/database/relational-data-theory/无损分解判定算法.png"></p></figure><hr></li><li><p>分解的保持函数依赖性：若 <span class="math inline">\(F^+ =(\bigcup_{i=1}^n F_i)^+\)</span>，则称 <span class="math inline">\(\rho\)</span> 保持<strong>函数依赖</strong> <br>即R 中的每个函数依赖都可以从 <span class="math inline">\(F_1, \dotsF_n\)</span> 的<u>并集</u>中<strong>逻辑导出</strong></p></li><li><p>判断是否保持函数依赖：设 <span class="math inline">\(G =\{\bigcup_{i=1}^n F_i\}\)</span>，则保持函数依赖有<span class="math inline">\(F^+ = G^+\)</span> <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(F \subseteq G^+ \land G \subseteq F^+\)</span><br>即对<strong>任意 X <span class="math inline">\(\rightarrow\)</span>Y <span class="math inline">\(\in\)</span> F</strong>，若总有 Y <span class="math inline">\(\in\)</span> <span class="math inline">\(X_{G^+}^+\)</span>，说明 <strong>X <span class="math inline">\(\rightarrow\)</span> Y <span class="math inline">\(\in\)</span> <span class="math inline">\(G^+\)</span></strong>（充要性定理），即 <span class="math inline">\(F \subseteq G^+\)</span>，反之亦然<br><strong>注意</strong>：这里是在判断对于 F 中的 X <span class="math inline">\(\rightarrow\)</span> Y，X 能否借助 <span class="math inline">\(G^+\)</span> 决定 Y</p><hr></li><li><p>模式分解能够达到的范式等级：</p><ul><li>若要求分解<strong>保持函数依赖</strong>，模式分解总可以达到<strong>3NF</strong>，但不一定能达到BCNF</li><li>若要求分解<strong>保持函数依赖</strong>，且保持<u>无损连接性</u>，模式分解可以达到<strong>3NF</strong>，但不一定能够达到BCNF</li><li>若要求分解具有<strong>无损连接性</strong>，模式分解一定至少能够达到<strong>4NF</strong></li></ul></li><li><p>达到3NF的、<strong>保持函数依赖</strong>的模式分解：（自底向上合成法）</p><ol type="1"><li><p>对F进行<strong>极小化</strong>处理，并令 F <span class="math inline">\(\gets\)</span> <span class="math inline">\(\text{F}_m\)</span></p></li><li><p>将<u>不在F中的属性</u><span class="math inline">\(\text{U}&#39; =\{A_1, \dots A_k\}\)</span>剔除出来，单独构成一个关系模式<span class="math inline">\(\text{R}&#39;\)</span>，并令 U <span class="math inline">\(\gets\)</span> U - <span class="math inline">\(\text{U}&#39;\)</span></p></li><li><p>若有 X <span class="math inline">\(\rightarrow\)</span> A，且 XA= U，则最终分解为 <span class="math inline">\(\rho =\{\text{R}\}\)</span>，分解算法结束</p></li><li><p>对F中具有<u>相同左部</u>的规则<strong>分成k组</strong>，每组函数依赖所涉及的<strong>全体属性</strong>（左部+ 右部）设为<span class="math inline">\(\text{U}_i\)</span> <br>若有<span class="math inline">\(\text{U}_i \subseteq \text{U}_j\)</span>（i<span class="math inline">\(\ne\)</span> j，出现冗余模式），则要去掉<span class="math inline">\(\text{U}_i\)</span>；设 <span class="math inline">\(\text{F}_i\)</span> 是 F 在 <span class="math inline">\(\text{U}_i\)</span> 上的投影 <br>则 <span class="math inline">\(\rho = \{\text{R}_i &lt;\text{U}_i, \text{F}_i&gt;\text{ | } i = 1 \dots k \} \cup \text{R}&#39;\)</span> 是 R&lt;U, F&gt;的<strong>保持函数依赖</strong>的分解，且均有 $_i $ 3NF</p></li></ol></li><li><p>达到3NF的、同时<strong>保持无损连接</strong>与<strong>函数依赖</strong>的分解：</p><ol type="1"><li><p>设<span class="math inline">\(\rho\)</span>是R&lt;U,F&gt;上的依据<u>合成法</u>分解得到的<strong>已经保持函数依赖</strong>的3NF分解，<u>X是R的码</u></p></li><li><p>若有某个分<span class="math inline">\(\text{U}_i\)</span>，X<span class="math inline">\(\subseteq \text{U}_i\)</span>，则 <span class="math inline">\(\rho\)</span> 为所求</p></li><li><p>否则，令<span class="math inline">\(\tau = \rho \cup\{\text{R}^*&lt;\text{X}, \text{F}_X&gt;\}\)</span>，<span class="math inline">\(\tau\)</span> 即为所求分解（<span class="math inline">\(\text{F}_X\)</span> 表示F在X上的投影）</p></li></ol></li><li><p>达到BCNF、具有<strong>无损连接性</strong>分解算法：（自顶向下分解法）令<span class="math inline">\(\rho = \{\text{R}&lt;\text{U},\text{F}&gt;\}\)</span></p><ol type="1"><li><p>若 <span class="math inline">\(\rho\)</span> 中的各关系模式均<span class="math inline">\(\in\)</span> BCNF，则算法结束</p></li><li><p>否则，设 <span class="math inline">\(\rho\)</span> 中的<span class="math inline">\(\text{R}_i&lt;\text{U}_i, \text{F}_i&gt;\)</span><span class="math inline">\(\notin\)</span> BCNF，则存在 X <span class="math inline">\(\rightarrow\)</span> A <span class="math inline">\(\in\)</span> <span class="math inline">\(\text{F}_i^+\)</span>，<strong>X 不是 <span class="math inline">\(\text{R}_i\)</span> 的码</strong>；故 XA <span class="math inline">\(\subset\)</span> <span class="math inline">\(\text{U}_i\)</span> <br>对 <span class="math inline">\(\text{R}_i\)</span> 分解为 <span class="math inline">\(\sigma = \{\text{S}_1,\text{S}_2\}\)</span>，<span class="math inline">\(\text{U}_{\text{S}_1}= \text{XA}\)</span>（避免决定因素不含码），且 <span class="math inline">\(\text{U}_{\text{S}_2} = \text{U}_i -\{\text{A}\}\)</span>，再令 <span class="math inline">\(\text{R}_i \gets\sigma\)</span></p></li><li><p>反复执行上一步骤，直至无法继续分解（<span class="math inline">\(\rho\)</span> 中均为 BCNF）</p></li></ol></li></ul><hr><h3 id="五候选码的求解理论与算法">五、候选码的求解理论与算法</h3><ul><li><p>依赖中的属性类型：可分为4类</p><ul><li>L类：<strong>仅</strong>出现在F的函数依赖<u>左部</u>的属性</li><li>R类：<strong>仅</strong>出现在F的函数依赖<u>右部</u>的属性</li><li>N类：在F的函数依赖的<strong>左右两侧均未出现过</strong>的属性</li><li>LR类：在F的函数依赖<strong>左右两边均出现过</strong>的属性</li></ul></li><li><p>快速求解候选码：设关系模式 R&lt;U, F&gt;，X（X <span class="math inline">\(\subseteq\)</span> U）的类型分类如下</p><ul><li>L类属性：X必出现在R的所有候选码中 <br><strong>注意</strong>：若<span class="math inline">\(\text{X}_{\text{F}}^+ =\text{U}\)</span>，则X为R的唯一候选码</li><li>R类属性：X不出现在R的任意候选码中</li><li>N类属性：X必出现在R的所有候选码中 <br><strong>注意</strong>：若 X是N类和L类组成的属性集，且 <span class="math inline">\(\text{X}_{\text{F}}^+ =\text{U}\)</span>，则X为R的唯一候选码</li></ul><hr></li><li><p>函数关系依赖图：设关系模式为R&lt;U, F&gt;</p><ul><li><p>节点：对应 U 中的<strong>单属性</strong></p></li><li><p>有向边：&lt;<span class="math inline">\(\text{A}_i\)</span>,<span class="math inline">\(\text{A}_j\)</span>&gt; 表示一个函数依赖<span class="math inline">\(\text{A}_i \rightarrow\text{A}_j\)</span></p><hr></li><li><p><strong>原始点</strong>：仅有引出线而无引入线，对应L类属性</p></li><li><p>终结点：仅有引入线而无引出线，对应R类属性</p></li><li><p>途中点：既有引出线又有引入线，对应LR类属性</p></li><li><p><strong>孤立点</strong>：既无引出线又无引入线，对应N类属性</p><hr></li><li><p>关键点：<u>原始点</u>和<u>孤立点</u>统称为关键点</p></li><li><p>关键属性：关键点对应的属性</p><hr></li><li><p>回路：类比有向图中的有向环</p></li><li><p>孤立回路：不能由其它节点到达的回路</p></li></ul></li><li><p>候选码的图论判定方法：</p><ul><li>若依赖图中存在关键点，则<u>关键点</u>对应属性必在R的所有候选码中，所有<u>终结点</u>必不在任何候选码中</li><li>属性集X是R的唯一候选码 <span class="math inline">\(\Leftrightarrow\)</span> X可到达G中的任意节点<br><strong>注意</strong>：在单属性依赖集中，R具有唯一候选码 <span class="math inline">\(\Leftrightarrow\)</span> G中不存在独立回路</li><li>设 Y 是<u>中途点</u>，则Y必在某个候选码中 <span class="math inline">\(\Leftrightarrow\)</span>Y为某个<strong>独立回路的节点</strong></li></ul></li><li><p>单属性依赖集候选码图论求解法：设 F为<u><strong>单属性</strong>依赖集</u></p><ol type="1"><li>求出F的极小依赖集<span class="math inline">\(\text{F}_m\)</span>，构造对应的函数依赖图G</li><li>从G中找出<strong>关键属性集X</strong></li><li>若G中不存在独立回路，则X为R的唯一候选码</li><li>否则，从<u>各独立回路中取一节点</u>对应属性与<u>X</u>组成一个候选码（<strong>取尽所有组合</strong>）</li></ol></li><li><p>多属性依赖集候选码图论求解法：设 F不是<u><strong>单属性</strong>依赖集</u></p><ol type="1"><li>将R的所有属性分为四类，并令X代表L、N（即关键属性），Y代表LR类</li><li>求 <span class="math inline">\(\text{X}_{F}^+\)</span>，若 <span class="math inline">\(\text{X}_{F}^+ =\text{U}\)</span>，即X为R的唯一候选码，候选码求解结束</li><li>否则，求 <span class="math inline">\((\text{XB})_{F}^+\)</span>，若<span class="math inline">\((\text{XB})_{F}^+ = \text{U}\)</span>，则 XB是一个候选码，候选码中属性的个数由此确定<br>其中B是Y中的若干个属性；迭代求解的过程要按照B中<u>属性个数<strong>递增</strong>的顺序</u>（1,2, ..., n）求解</li></ol></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>『compiler-5』runtime memory management</title>
    <link href="/2023/10/10/compiler/runtime-memory-management/"/>
    <url>/2023/10/10/compiler/runtime-memory-management/</url>
    
    <content type="html"><![CDATA[<h2 id="运行时存储管理">运行时存储管理</h2><h3 id="一静态存储分配">一、静态存储分配</h3><ul><li><p>静态分配概念：在<u>编译阶段</u>由<strong>编译程序</strong>实现对存储空间的管理，为源程序中的变量分配存储<br><strong>注意</strong>：静态分配要求能够确定变量在运行时的数据空间大小，且运行时不变</p></li><li><p>分配策略：无可变长的串or数组，且不允许递归调用</p><ol type="1"><li>开辟<strong>数据区</strong>，其首地址在加载时确定</li><li>按编译顺序给每个<strong>模块</strong>分配存储空间</li><li>在模块内部按顺序给模块的变量分配存储（使用<strong>相对地址</strong>）</li><li>目标地址填入<strong>变量的符号表</strong>中</li></ol></li><li><p>FORTRAN子程序的数据区：一个子模块主要包括<u>隐式参数区</u>、<u>形式参数区</u>、<u>局部变量和临时参数区</u></p><ul><li>隐式参数区：存放调用<strong>返回地址</strong> or不便从寄存器返回的<strong>函数返回值</strong></li><li>形式参数区：存放<strong>实参</strong>的地址或值</li><li>局部变量和临时变量区：记录<strong>临时变量</strong>的存储空间</li></ul><p><strong>注意</strong>：该情况下程序运行栈是由各子模块组成的，运行栈是自顶向下生长的</p></li></ul><hr><h3 id="二动态存储分配">二、动态存储分配</h3><ul><li><p>动态分配概念：在<u>目标程序运行阶段</u>由<strong>目标程序</strong>实现对存储空间的管理，为源程序中的变量分配存储<br><strong>注意</strong>：动态存储分配中，要求编译程序能够生成<strong>有关存储分配</strong>的目标代码</p></li><li><p>分配策略：数据区为一个<strong>栈</strong></p><ol type="1"><li>进入一个过程：在栈顶为其<strong>开辟</strong>一个数据区</li><li>退出一个过程：<strong>撤销</strong>栈顶的过程数据区</li></ol></li><li><p>活动记录：创建于<strong>运行栈</strong>上的专有数据区，包括<u>局部数据区</u>、<u>参数区</u>、<u>display</u> 区</p><ul><li><p>局部数据区：存放本模块定义的<strong>各局部变量</strong></p></li><li><p>参数区：存放隐式参数和显式参数</p><ul><li>显式参数区：存放模块调用的各个实参值 or 实参地址</li><li>隐式参数区：<ul><li>prevabp：指向<strong>caller</strong>模块的<strong>基地址</strong></li><li>ret addr(n)：本模块<strong>返回到模块n</strong></li><li>ret value：函数的<strong>返回值</strong></li></ul></li></ul></li><li><p>display区：存放本模块的<strong>各外层模块</strong>AR的<strong>基地址abp(1~ i-1)</strong></p><ul><li><p>变量的二维编址：(BL, ON)，其中 BL 指<strong>嵌套深度</strong>、ON指变量<strong>在本层的变量顺序号</strong>（<span class="math inline">\(\ge 0\)</span>）</p><figure style="text-align:center"><p><img src="/2023/10/10/compiler/runtime-memory-management/变量的二维编址.png"><figurecap>内层模块可以引用外层模块的变量</figurecap></p></figure></li><li><p>构造AR的display区：假设从某第 i 层模块进入某第 j层模块，若要创建第 j 层的display区：</p><ul><li><p>若 j = i + 1（即 i call j 或 i begin-j-end），则有：</p><figure style="text-align:center"><p><img src="/2023/10/10/compiler/runtime-memory-management/规则一.png"> <figurecap>j比i恰深一层</figurecap></p></figure></li><li><p>若 j <span class="math inline">\(\le\)</span> i，即从 i跳到某个外层or同层的模块 j，则有：</p><figure style="text-align:Center"><p><img src="/2023/10/10/compiler/runtime-memory-management/规则二.png"> <figurecap>j外层的所有AR基址（1 ~j-1）赋给i的display区</figurecap></p></figure></li></ul></li></ul></li><li><p>运行时的变量地址计算：设要在 LEV 层访问的变量为 (BL,ON)，且当前模块基址为 abp</p><ul><li><p>若 BL = LEV ：ADDR = abp + (BL - 1) + nip + ON</p><figure style="text-align:center"><p><img src="/2023/10/10/compiler/runtime-memory-management/同层地址计算.png"> <figurecap>同层地址计算</figurecap></p></figure></li><li><p>若 BL &lt; LEV ：ADDR = <strong>display[BL]</strong> + (BL - 1) +nip + ON</p><figure><p><img src="/2023/10/10/compiler/runtime-memory-management/外层地址计算.png"></p></figure></li><li><p>若 BL <span class="math inline">\(\ge\)</span> LEV：说明要访问内层模块的变量，不合法</p><p><strong>注意</strong>：(BL - 1)+nip 表示要<u>向上跨过</u>display区和隐式参数区，才能到达<strong>显式参数区</strong>和局部数据<br>一个AR的结构如图所示：多个AR组成了运行栈（栈的方向在图中是<strong>向上增长</strong>的）</p><figure style="text-align:center"><p><img src="/2023/10/10/compiler/runtime-memory-management/活动记录.png"></p></figure></li></ul></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>compiler</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>『database-3』secruity control</title>
    <link href="/2023/10/10/database/secruity-control/"/>
    <url>/2023/10/10/database/secruity-control/</url>
    
    <content type="html"><![CDATA[<h2 id="数据库保护">数据库保护</h2><h3 id="一数据库安全性控制">一、数据库安全性控制</h3><ul><li><p>安全性含义：防止<u>不合法使用</u>导致的<strong>数据泄露</strong>、<strong>更改</strong>或<strong>破坏</strong></p><ul><li>向授权用户提供可靠服务</li><li>拒绝对数据的非授权访问请求</li></ul></li><li><p>数据库系统的安全性模型：</p><figure><p><img src="/2023/10/10/database/secruity-control/安全性系统.png"></p></figure></li><li><p>用户标识与鉴别：系统最外层的安全保护措施</p><ul><li><p>标识：系统采取一定方式标识其用户或应用程序的<strong>名字或身份</strong></p></li><li><p>认证：用户或应用程序登录时<strong>判断</strong>是否为合法的授权用户</p><p><strong>注意</strong>：标识常使用“<strong>用户名</strong>”，认证常使用“<strong>口令</strong>”</p></li></ul></li><li><p>存取控制：<u>合法用户</u>可以访问、<u>非法用户</u>不能访问</p><ul><li><p>用户权限定义：将用户权限记录定义在<strong>数据字典</strong>中，形成安全性规则或授权规则</p></li><li><p>合法权限检查：根据数据字典中的安全规则，对用户的操作请求进行<strong>合法权限检查</strong>，决定是否接受用户请求</p><hr></li><li><p>自主存取控制（<strong>DAC</strong>）：用户可以将拥有的权限<strong>转授</strong>给其他用户，用户权限包含<u>数据对象</u>和<u>操作类型</u>：</p><ul><li>数据对象：分为 <strong>模式</strong> （三级模式）+<strong>数据</strong>（表 + 属性列）</li><li>操作类型：包括 <u>建立 + 修改 + 检索</u>（模式）、<u>检索 + 插入 +删除 + 修改</u>（数据）</li></ul><p><strong>注意</strong>：对用户的授权应包括 用户名 + 数据对象名 +允许的操作类型</p><ul><li>角色：一组相关<strong>权限的集合</strong>，分配权限 <span class="math inline">\(\Leftrightarrow\)</span> 授予角色</li><li>SQL的数据安全性控制：包括<strong>GRANT</strong>和<strong>REVOKE</strong>语句</li></ul></li><li><p>强制存取控制（<strong>MAC</strong>）：每个用户和数据对象均标记一定的<strong>密级</strong></p><ul><li>主体与客体：主体包括实际用户 +用户进程；客体包括用户操纵的被动实体（如基本表等）</li><li>敏感度标记：主体称作<strong>许可证级别</strong>，客体称作<strong>密级</strong></li><li>对客体的存取规则：<ul><li>许可证级别 <span class="math inline">\(\ge\)</span>密级：主体允许<strong>读取</strong>相应客体（但不能写）</li><li>许可证级别 = 密级：主体允许<strong>改写</strong>相应客体</li></ul></li></ul><hr></li><li><p>视图机制：为每个用户定义不同的视图，可将对数据的<strong>访问限制</strong>在一定范围中</p></li><li><p>审计：将用户<u>对数据库的所有操作</u>自动记录在<strong>审计日志</strong>，支持DBA重现数据库操作，找出非法记录</p></li><li><p>数据加密：使用一定的算法将原始数据转变为不可识别的密文</p></li></ul></li></ul><hr><h3 id="二数据库完整性控制">二、数据库完整性控制</h3><ul><li><p>完整性内涵：数据的正确性和相容性（数据库对真实世界的表征）</p><ul><li>正确性：数据<strong>类型合法</strong> +数据处在<strong>取值范围</strong>内</li><li>相容性：<u>表示同一事实</u>的两个数据应该相同</li></ul><p><strong>注意</strong>：安全性防范非法用户or非法操作；完整性防范<strong>不合语义</strong>的数据</p></li><li><p>完整性约束条件：施加在数据库上的语义约束条件，作用对象包括<u>列、元组、关系</u></p><ul><li>实体完整性：元组的完整性约束；SQL中使用<strong>PRIMARYKEY</strong></li><li>参照完整性：关系的完整性约束；SQL中使用<strong>FOREIGNKEY</strong></li><li>用户自定义完整性：对列or元组的完整性约束；SQL中使用<strong>UNIQUE</strong>、<strong>NOTNULL</strong>、<strong>CHECK</strong></li></ul></li><li><p>静态约束：</p><ul><li>静态列级约束：对<strong>列取值域</strong>的说明，如数据类型、取值范围</li><li>静态元组约束：规定<strong>元组中各列间</strong>的约束关系</li><li>静态关系约束：各元组或各关系间的联系与约束，如<strong>实体完整性约束</strong>、<strong>参照完整性约</strong>束等</li></ul></li><li><p>动态约束：</p><ul><li>动态列级约束：<strong>修改</strong>列定义or列值时应满足的约束条件</li><li>动态元组约束：<strong>修改</strong>元组值时需要满足的约束条件</li><li>动态关系约束：关系<strong>变化前后</strong>状态上的限制条件</li></ul><p><strong>注意</strong>：静态约束反映数据库在<strong>确定状态</strong>下的约束条件；动态约束反映数据库<strong>状态变迁</strong>的约束条件</p><hr></li><li><p>完整性控制的功能实现：</p><ul><li>定义功能：提供<strong>定义</strong>完整性约束条件的机制</li><li>检查功能：<strong>检查</strong>用户请求是否违背完整性约束条件</li><li>违约响应：在<u>违背了完整性约束的情况</u>下，采取一定措施保证数据完整性</li></ul></li><li><p>完整性检查的时机：</p><ul><li>立即执行约束：在一条语句执行后<strong>立即进行</strong>完整性约束</li><li>延迟执行约束：在整个用户事务<strong>执行完毕后</strong>，再进行完整性约束的检查</li></ul></li><li><p>完整性规则的表示：五元组 (D, O, A, C, P)</p><ul><li>D（数据）：约束<strong>作用的数据对象</strong></li><li>O（操作）：<strong>触发</strong>完整性检查的数据操作</li><li>A（断言）：数据对象必须满足的断言or语义约束</li><li>C（谓词）：若对数据对象施加断言A，则该对象必须满足的谓词条件</li><li>P（过程）：违反完整性约束规则时触发的过程</li></ul></li><li><p>SQL中的完整性约束：</p><ul><li><p>CREATE TABLE 语句：定义列级完整性约束、表级完整性约束</p></li><li><p><strong>CREATE ASSERTION</strong> &lt;断言名&gt;<strong>CHECK</strong>(约束条件)</p></li><li><p>触发器：用户对表的更新操作，<strong>自动激活相应触发器</strong>执行完整性约束（事件驱动）</p><figure><p><img src="/2023/10/10/database/secruity-control/触发器.png"></p></figure><ul><li><p>表名：触发器只能定义在<strong>基本表</strong>上，不能定义在视图上</p></li><li><p>触发时机：BEFORE表示在执行触发事件前激活触发器，AFTER则相反</p></li><li><p>触发事件：可以是 INSERT、UPDATE、DELETE或其组合，也可以指定操作列名 如 UPDATE <strong>OF</strong>(若干触发列)</p><ul><li><p>触发器类型：规定触发动作执行的间隔尺寸，对于每条SQL语句</p><ul><li><p>ROW：每操作一个元组，就执行一次触发动作</p></li><li><p>STATEMENT：执行该SQL语句后，才执行一次触发动作</p><p><strong>注意</strong>：若没有FOR语句，则可以<strong>引用</strong>OLDTABLE（表中原先内容）和 NEWTABLE（表中变化后的部分）</p></li></ul></li></ul></li><li><p>触发条件：WHEN后的语句为真，触发动作才会执行（缺省则触发器激活后立即进行）</p></li><li><p>触发动作体（匿名SQL块）：触发的SQL执行块；若触发动作体执行失败，触发事件也会失效<br><strong>注意</strong>：对于<strong>行级触发器</strong>，可以使用NEW/OLD引用<u>更新或插入后的新值</u>或<u>更新或删除前的旧值</u></p></li></ul></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>『machine learning-4』linear model</title>
    <link href="/2023/10/10/machine_learning/linear-model/"/>
    <url>/2023/10/10/machine_learning/linear-model/</url>
    
    <content type="html"><![CDATA[<h2 id="线性模型">线性模型</h2><h3 id="一回归模型">一、回归模型</h3><ul><li>“回归”：样本倾向于接近以平均值</li><li>回归函数：<span class="math inline">\(f(x, \omega) = \sum_{i=0}^{m}\omega_i \phi_i(x) = \omega^T \phi(x)\)</span>，其中 <span class="math inline">\(\phi\)</span>表示<strong>基函数</strong>，x表示<strong>样本特征</strong><ul><li>线性函数：<span class="math inline">\(\phi_i(x)\)</span> = <span class="math inline">\(x_i\)</span>，这种最简单</li><li>多项式函数：<span class="math inline">\(\phi_i(x)=x^i\)</span></li><li>高斯函数：<span class="math inline">\(\phi_i(x) =e^{-\frac{(x-\mu_i)^2}{2s^2}}\)</span>，其中 <span class="math inline">\(\mu_i\)</span> 表示样本均值，s表示样本方差</li></ul></li></ul><hr><h3 id="二梯度下降">二、梯度下降</h3><ul><li><p>损失函数<span class="math inline">\(J(\omega)\)</span>：以最小化<strong>训练集预测值f</strong>和<strong>真实输出y</strong>之间的差异为目标，一般情况下：<span class="math display">\[J(\omega) = \frac{1}{2} \sum_{i=1}^N (f(x_i) - y_i)^2\]</span></p></li><li><p>梯度下降求解法：以<strong>负梯度方向</strong>为搜索方向，越接近目标值，步长越小</p><ol type="1"><li><p>设参数初始值为 <span class="math inline">\(\omega^0\)</span></p></li><li><p>更新 <span class="math inline">\(\omega\)</span> 使得<span class="math inline">\(J(\omega)\)</span>减小，即对参数向量 <span class="math inline">\(\omega\)</span> 的第 j 个分量 <span class="math inline">\(\omega_j\)</span> 有： <span class="math display">\[\begin{align}\omega_j^t &amp;= \omega_j^{t-1} - \alpha \frac{\partial}{\partial\omega_j}J(\omega) \\其中 \text{ } \frac{\partial}{\partial \omega_j} J(\omega) &amp;=\sum_{i=1}^{N} [(f(x_i) - y_i) \cdot x_{ij}]\end{align}\]</span></p></li><li><p>使 <span class="math inline">\(J(\omega)\)</span>取最小值的极值点 <span class="math inline">\(\omega^*\)</span>即为线性模型的参数 <span class="math inline">\(\omega\)</span></p></li></ol><p><strong>注意</strong>：<u>样本量较小</u>时使用<strong>求偏导解方程组</strong>求解（规避大矩阵）；<u>样本量较大</u>时可使用<strong>梯度下降法</strong>求解</p></li></ul><hr><h3 id="三线性判别函数">三、线性判别函数</h3><ul><li><p>贝叶斯估计的可能问题：</p><ul><li><p>类条件概率密度 <span class="math inline">\(p(x \text{ |}\omega_i)\)</span> <u>参数未知</u></p></li><li><p>即便参数可以通过样本估计得到，其<u>形式仍难以确定</u></p></li><li><p>非参数估计方法需要<u>大量样本</u></p></li></ul><p><strong>注意</strong>：线性判别函数可以根据样本集<strong>直接设计分类器</strong>，避免了繁杂的统计工作</p></li><li><p>线性判别函数：一般形式为 <span class="math inline">\(g(x) =\omega^T x + \omega_0\)</span>，其中 x 是样本特征向量</p><ul><li><p>若 <span class="math inline">\(g(x) \gt 0\)</span>，则 <span class="math inline">\(x \in C_1\)</span></p></li><li><p>若 <span class="math inline">\(g(x) \lt 0\)</span>，则 <span class="math inline">\(x \in C_2\)</span></p></li><li><p>若 <span class="math inline">\(g(x) = 0\)</span>，则可将样本<span class="math inline">\(x\)</span> 划分为任意一类或拒绝</p><hr></li><li><p>线性判别函数 <span class="math inline">\(g(x)\)</span>即为超平面方程，<span class="math inline">\(\dfrac{g(x)}{|{|{\omega}}||}\)</span>表示样本点 x与超平面 <span class="math inline">\(g(x)\)</span>的<strong>有向距离</strong></p></li></ul><p><strong>注意</strong>：可以引入<strong>基函数 <span class="math inline">\(\phi\)</span></strong>，利用线性函数的简单性解决复杂问题；但可能导致“维数灾难”</p></li><li><p>求解线性分类器：分类器的设计 <span class="math inline">\(\Leftrightarrow\)</span>求<strong>准则函数</strong>极值点，求解步骤如下</p><ol type="1"><li>获得样本集<span class="math inline">\(X = \{x_1, \dotsx_N\}\)</span></li><li>确定准则函数<span class="math inline">\(J\)</span>：满足 <span class="math inline">\(J\)</span> 是样本集与 <span class="math inline">\(\omega\)</span> 的函数，且 <span class="math inline">\(J\)</span> 的极值对应最佳决策</li><li>求解准则函数 <span class="math inline">\(J\)</span> 的极值点<span class="math inline">\(\omega_0^*\)</span>，获得<strong>线性判别函数</strong></li></ol></li><li><p>Fisher 准则：将 d维空间的样本投影到一维空间（直线上），总可以找到某个方向<br>使得样本在该方向上的投影分离效果最好，以二分类问题为例：</p><ol type="1"><li><p>求解两类样本各自的<strong>样本均值</strong> <span class="math inline">\(m_i = \dfrac{1}{N_i} \sum_{y \in C_i}y\)</span>，其中 <span class="math inline">\(i = 1, 2\)</span></p></li><li><p>求解样本<strong>类内散度</strong> <span class="math inline">\(S_i^2 = \sum_{y \in C_i} (y - m_i)(y -m_i)^T\)</span>，其中 <span class="math inline">\(i = 1,2\)</span></p></li><li><p>求解 Fisher 准则函数的极大值点，<span class="math inline">\(J_F(\omega) = \dfrac{(m_i - m_2)^2}{S_1^2 +S_2^2}\)</span></p></li><li><p>Lagrange乘子法求解结果：<span class="math inline">\(\omega^* =S_{\omega}^{-1}(m_1 - m_2)\)</span>，其中： <span class="math display">\[S_{\omega} = \sum_{y \in C_1} (y-m_1)(y-m_1)^T + \sum_{y \inC_2}(y-m_2)(y-m_2)^T = S_1^2 + S_2^2\]</span></p></li><li><p>获得线性判别函数 <span class="math inline">\(y = \omega^*x\)</span>，并设置决策阈值用于分类</p></li></ol><p><strong>注意</strong>：Fisher准则目标在于尽可能使<strong>两类均值之差增大</strong>（分子），同时尽可能使<strong>各样本内部聚集</strong>（分母）</p><figure style="text-align:center"><p><img src="/2023/10/10/machine_learning/linear-model/Fisher准则.png"><figurecap>寻找最佳投影直线</figurecap></p></figure><hr></li><li><p>线性可分性：设数据集 D = <span class="math inline">\(\{(x_1,y_1), \dots (x_N, y_N)\}\)</span>，<span class="math inline">\(x_i \in\mathbb{R}^d\)</span>，<span class="math inline">\(y_i \in \{+1,-1\}\)</span> <br>若存在某个超平面S: <span class="math inline">\(\omegax + b = 0\)</span>，使得 <strong><span class="math inline">\(y_i (\omegax_i + b) \lt 0\)</span></strong> 对任意的 <span class="math inline">\(x_i\)</span>恒成立，说明该数据集是<strong>线性可分</strong>的</p></li><li><p>感知机准则：设置<strong>损失函数</strong>，<span class="math inline">\(J(\omega, \omega_0) = -\sum_{x_i \in M} y_i(\omegax_i + \omega_0)\)</span>，其中<span class="math inline">\(M\)</span>表示<u>误分类样本</u>的集合</p><ol type="1"><li>任选一个初始超平面 <span class="math inline">\(\omega,\omega_0\)</span>，使用随机梯度下降法求解 <span class="math inline">\(\min (J(\omega, \omega_0))\)</span></li><li>若存在样本点<span class="math inline">\((x_i, y_i)\)</span>，使得<span class="math inline">\(y_i(\omega x_i + \omega_0) \le0\)</span>（被误识别） <br>则<strong>更新</strong> <span class="math inline">\(\omega \gets \omega + \eta y_i x_i\)</span>，<span class="math inline">\(\omega_0 \gets \omega_0 + \eta y_i\)</span>（<span class="math inline">\(0 \lt \eta \le 1\)</span> 表示学习率）<br><strong>注意</strong>：迭代每一步，表示使超平面不断靠近被错分类的点，最终被正确分类</li><li>反复迭代直至<strong>没有被误识别</strong>的样本点（<span class="math inline">\(J(\omega, \omega_0)\)</span> = 0）</li></ol><p><strong>注意</strong>：超平面初始值不同，最终解出的超平面也可能不同</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>machine learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>『compiler-4』symbol table</title>
    <link href="/2023/10/09/compiler/symbol-table/"/>
    <url>/2023/10/09/compiler/symbol-table/</url>
    
    <content type="html"><![CDATA[<h2 id="符号表管理技术">符号表管理技术</h2><h3 id="一语义分析">一、语义分析</h3><ul><li><p>语义分析任务：对识别出的各种语法成分进行<strong>语义分析</strong>，产生相应的<strong>中间代码</strong></p><ul><li>上下文<u>相关</u>分析：标识符的作用域</li><li>类型的一致性检查</li><li>语义处理：主要处理<strong>声明语句</strong> +<strong>执行语句</strong></li></ul><p><strong>注意</strong>：上下文无关语法只能描述语法结构，而<u>不能描述其语义</u>，故只能把上下文相关分析交给语义分析<br>通过语义分析的程序未必是“正确的程序”</p></li></ul><hr><h3 id="二符号表">二、符号表</h3><ul><li><p>符号表的概念：编译过程中用于记录源程序中的各种<strong>名字</strong>及其<strong>特性</strong>信息</p><ul><li><p>名字：存放<strong>标识符</strong>（如变量、函数等）的符号串</p></li><li><p>特性：表示标识符的有关信息，有关信息包括：</p><figure><p><img src="/2023/10/09/compiler/symbol-table/特性.png"></p></figure></li></ul></li><li><p>符号表的组织方式：</p><ul><li><p>统一符号表：将任何符号都填入<strong>统一格式</strong>的符号表中；符号表的属性数量需<strong>兼顾信息量最大</strong>的符号</p></li><li><p>分类符号表：对于不同种类的名字分别建立符号表</p><p><strong>注意</strong>：统一符号表查表简便、但浪费空间；分类符号表节省空间、但填查表不方便</p></li><li><p>折中符号表：将所有符号的大部分信息组成统一格式的符号表，<u>特殊信息另外附设表</u>，两表用指针连接</p></li></ul></li><li><p>非分程序的符号表：</p><ul><li><p>非分程序结构语言：每个可独立编译的程序单元<strong>不包含子模块</strong></p></li><li><p>标识符作用域：分为全局作用域 + 局部作用域</p><ul><li>具有全局作用域：<u>子程序名</u> + <u>函数名</u> +<u>公共区名</u></li><li>具有局部作用域：<strong>程序单元内部</strong>声明的变量（即局部变量）</li></ul></li><li><p>符号表管理：分为全局符号表 + 局部符号表</p><ol type="1"><li>子程序名 + 函数名 + 公共区名填入全局符号表（具有全局作用域）</li><li>在子程序的<strong>声明部分</strong>读到标识符，先查本单元的表：<ul><li>若该符号已经存在，说明重复声明，报错</li><li>若该符号不存在，则直接填表</li></ul></li><li>在<strong>可执行语句部分</strong>读到标识符，先查本单元的表：<ul><li>若该符号已经存在，说明已被正确声明</li><li>若该符号不存在，转去查全局符号表；若仍不存在说明未声明，报错</li></ul></li><li>程序单元编译结束：释放该单元的局部符号表</li><li>整个程序编译完成：将全部符号表都释放掉</li></ol></li><li><p>符号表组织方式：</p><ul><li><p>无序符号表：仅<u>按扫描顺序</u>建立表，查表需要<strong>线性查找</strong></p></li><li><p>有序符号表：符号表按照变量名进行<u>字典式排序</u>，可使用<strong>折半查找</strong>，但插入开销大</p><p><strong>注意</strong>：平均查找长度：线性查表（ n + 1 /2）；折半查表（<span class="math inline">\(\log\)</span>n - 1）</p></li><li><p>散列符号表：符号表地址 = Hash (标识符名称)</p></li></ul></li></ul><hr></li><li><p>分程序的符号表：</p><ul><li>分程序结构语言：模块内部可以嵌套子模块</li><li>作用域：标识符的作用域为<strong>定义该标识符的子程序</strong><ul><li>函数内定义的标识符：作用域为函数体本身</li><li>循环语句中定义的标识符：作用域为该循环语句</li></ul></li><li>符号表管理：<ol type="1"><li>在<strong>声明部分</strong>读到标识符，先查本单元的表：<ul><li>若该符号已经存在，说明重复生命，报错</li><li>若该符号不存在，则直接查表</li></ul></li><li>在<strong>可执行语句</strong>部分读到标识符，先查本单元的表：<ul><li>若该符号已经存在，说明该符号已被正确声明</li><li>若该符号不存在，逐层向外查直接外层的符号表；若在最外层表中仍未查到，报错</li></ul></li><li>语言<strong>预先定义</strong>的标准标识符，用户不必声明即可使用，一般放于<u>最外层表</u></li><li>编译中识别出是分程序开始时，执行定位操作；分程序结束时执行重定位操作</li></ol></li></ul></li><li><p>定位与重定位：</p><ul><li><p>定位：编译<strong>进入</strong>新的分程序时，为新声明的标识符建立一个子表</p></li><li><p>重定位：编译<strong>离开</strong>当前分程序时，将符号表恢复为进入该分程序前的状态</p></li></ul></li></ul><hr><ul><li><p>栈式符号表：分程序结构语言最简单的符号表组织形式</p><ul><li><p>符号表管理：</p><ul><li>遇到标识符声明：考虑插入符号表</li><li>分程序结尾：将当前分程序对应的符号表弹栈</li></ul></li><li><p>插入符号：先查找考虑<strong>栈顶</strong>（当前编译步骤）符号表的符号信息，若未重复声明则将其插入</p></li><li><p>查表符号：<strong>从栈顶表到栈底表</strong>进行线性搜索，确保最内层定义的变量最先被找到</p></li><li><p>定位与重定位：</p><ul><li>定位：在分程序索引表顶端<strong>创建新的分区索引</strong>，并将索引值填为当前TOP值（开辟新表）</li><li>重定位：<strong>TOP下移</strong>至当前分区索引表顶端的元素值（移除顶表）</li></ul><figure style="text-align:center"><p><img src="/2023/10/09/compiler/symbol-table/栈式符号表.png"></p></figure></li><li><p>带有哈希表的栈式符号表：hash(ident) = ident符号在栈式符号表中的位置</p></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>compiler</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>『compiler-3』parser</title>
    <link href="/2023/09/27/compiler/parser/"/>
    <url>/2023/09/27/compiler/parser/</url>
    
    <content type="html"><![CDATA[<h2 id="语法分析">语法分析</h2><hr><h3 id="一语法分析的功能">一、语法分析的功能</h3><ul><li>根据<u>文法规则</u>，从源程序单词符号串中<strong>识别语法成分</strong></li><li>进行<strong>语法检查</strong>、报告错误</li></ul><hr><h3 id="二自顶向下分析">二、自顶向下分析</h3><ul><li>分析过程：给定符号串s，根据文法为s构造<strong>语法树</strong>；若成功，则s为语法树对应的语法成分，即s<span class="math inline">\(\in\)</span> L(G[Z])<br><strong>注意</strong>：该过程之前需要先<strong>预测</strong>串s属于哪种语法成分，且可能会<strong>回溯</strong></li></ul><hr><h3 id="三二义性问题">三、二义性问题</h3><ul><li>文法的二义性：对于文法的某个句子，若存在<strong>两棵不同的语法树</strong>，则该文法是二义性文法<br><strong>注意</strong>：具有二义性的文法，会导致句型的<strong>句柄不唯一</strong></li><li>二义性文法：0~3型文法均可能产生二义性</li><li>优先级规定：含有<strong>低优先级运算符</strong>的推导式被置于<strong>上层规则</strong>，以消除二义性<br>如正则表达式的规则定义<u>从上到下</u>依次为 选择、连接、重复</li></ul><hr><h3 id="四左递归问题">四、左递归问题</h3><ul><li><p>左递归文法的定义：存在形如 <span class="math inline">\(\text{U}\rightarrow \text{U} \dots\)</span> 的规则，其中 <span class="math inline">\(\text{U} \in \text{V}_n\)</span><br><strong>注意</strong>：左递归文法无法使用<u>自顶向下</u>的方法进行分析，需要消除左递归</p></li><li><p>消除左递归的三条规则</p><ol type="1"><li><p>规则一：设 <span class="math inline">\(\text{U} \rightarrow\text{xy | xw | ... | xz}\)</span>，可将其替换为 <span class="math inline">\(\text{U} \rightarrow \text{x(y | w | ... |z)}\)</span>，即提公因子x</p></li><li><p>规则二：设 <span class="math inline">\(\text{U} \rightarrow\text{x | y | ... | z | Uv}\)</span>，可将其替换为 <span class="math inline">\(\text{U} \rightarrow (\text{x | y | ... |z})\{\text{v}\}\)</span></p></li><li><p>规则三：设 <span class="math inline">\(\text{P} \rightarrow\text{Pv | a}\)</span>，可将其替换为 <span class="math inline">\(\text{P} \rightarrow \text{aP&#39;} \text{且P&#39;} \rightarrow \text{vP&#39; | }\epsilon\)</span>，即改成右递归</p><p><strong>注意</strong>：后两条规则都表示<strong>后接任意个串v</strong>的句子</p></li></ol></li><li><p>消除<strong>间接</strong>左递归：</p><ol type="1"><li><p>将文法各规则<u>重新排列</u>，使得<strong>后续规则产生式体</strong>中的非终结符仅来自<strong>其前规则的产生式头</strong></p><figure style="text-align:center"><p><img src="/2023/09/27/compiler/parser/重新排列.png"></p></figure></li><li><p>根据以下算法消除左递归</p></li></ol><p><span class="math display">\[\begin{array}{ll}\mathbf{for} \text{ i} \gets 1 \text{ to } n \\\qquad \mathbf{for } \text{ j} \gets 1 \text{ to } i-1 \\\qquad \qquad \text{将形如 }A_i \rightarrow A_j r\text{的单独产生式替换为} \\\qquad \qquad A_i \rightarrow \delta_1 r | \cdots | \delta_kr\text{，}其中A_j \rightarrow \delta_1 | \cdots | \delta_k ，即把\text{}A_j\textbf{ 代入}\text{ }A_i \\\qquad \qquad 其余产生式保持不变 \\\qquad \text{消除 }A_i \text{ 中的直接左递归}\end{array}\]</span></p><p><strong>注意</strong>：各非终结符的<strong>排列顺序不同</strong>，最后获得的文法在形式上也是不一样的，但各文法间是等价的</p></li></ul><hr><h3 id="五回溯问题">五、回溯问题</h3><ul><li>有关回溯：<u>自顶向下</u>语法分析中可能出现的问题<ul><li>造成回溯的条件：文法中某个非终结符号的规则右部有<strong>多个产生式体</strong>，选择错误可能导致回溯<br>如 <span class="math inline">\(\text{U} \rightarrow \alpha_1 \text{| } \alpha_2 \text{ | ... |}\alpha_n\)</span>，不确定要选择哪个产生式体进行推导</li><li>回溯的问题：需要重新分析，严重降低效率</li></ul></li><li>FIRST集合：设产生式体为 <span class="math inline">\(\alpha_i\)</span>，则 <span class="math inline">\(\text{FIRST(}\alpha_i\text{)} = \{a \text{ | }\alpha_i \overset{*}{\Rightarrow}a\dots, \text{ } a \in\text{V}_t\}\)</span>，即<span class="math inline">\(\alpha_i\)</span>所可能推出的句子的<strong>首单词集</strong><br><strong>注意</strong>：为了避免回溯，需要有 <span class="math inline">\(\text{FIRST(}\alpha_i\text{)} \cap\text{FIRST(}\alpha_j\text{)} = \varnothing\)</span>（i <span class="math inline">\(\ne\)</span>j），即需要有<u>确定的产生式选择</u></li><li>避免回溯：上述避免回溯的条件无法避免时采取的措施<ul><li>对原文法<strong>反复提取左因子</strong>，直至满足避免回溯的条件</li><li>超前扫描（偷看）：向前多预读几个字符</li></ul></li><li>如何实现不带回溯的自顶向下的语法分析？<ol type="1"><li>文法不是左递归的</li><li>满足 <span class="math inline">\(\text{FIRST(}\alpha_i\text{)} \cap\text{FIRST(}\alpha_j\text{)} = \varnothing\)</span>（i <span class="math inline">\(\ne\)</span> j）</li></ol></li></ul><hr><h3 id="六递归下降的语法分析">六、递归下降的语法分析</h3><ul><li><p>实现方法：为文法中的每个<strong>非终结符</strong>编写一个分析程序；根据当前输入符号调用正确的分析程序</p></li><li><p>调用约定：</p><ol type="1"><li>进入某个非终结符的分析程序时，当前语法成分的<strong>首字符已被读入</strong></li><li>分析程序结束前，需要<strong>预读下一个单词</strong>，以保证当前子程序退出时，已经预读好了下一个单词</li></ol><figure style="text-align:center"><p><img src="/2023/09/27/compiler/parser/递归下降.png"><figurecap>非终结符Z的分析流程</figurecap></p></figure><p><strong>注意</strong>：递归下降语法分析是<strong>最左推导</strong>的过程</p></li></ul><hr><h3 id="七ll1语法分析">七、LL(1)语法分析</h3><ul><li><p>FIRST集与FOLLOW集</p><ul><li><p>FIRST集：FIRST(<span class="math inline">\(\alpha\)</span>) =<span class="math inline">\(\{a \text{ | } \alpha\overset{*}{\Rightarrow} a\dots, a \in V_t\}\)</span>，表示串<span class="math inline">\(\alpha\)</span>可以推出的任意符号串的<strong>第一个终结符</strong><br><strong>注意</strong>：若<span class="math inline">\(\alpha\overset{*}{\Rightarrow} \epsilon\)</span>，则 $<span class="math inline">\(FIRST(\)</span><span class="math inline">\()，即FIRST集中可能包含\)</span>$</p></li><li><p>FIRST集合的构造方式：设X为某个文法符号</p><ol type="1"><li><p>若 <span class="math inline">\(X \in V_t\)</span>，则 FIRST(X) =<span class="math inline">\(\{\text{X}\}\)</span>，终结符本身的 FIRST集合即是自己</p></li><li><p>若 <span class="math inline">\(X \in\)</span> <span class="math inline">\(V_n\)</span>，且 <span class="math inline">\(X\rightarrow a \alpha\)</span>（<span class="math inline">\(a \inV_t\)</span>），则 <span class="math inline">\(a \in\)</span>FIRST(<span class="math inline">\(X\)</span>) <br>若 <span class="math inline">\(X \rightarrow \epsilon\)</span>，则 <span class="math inline">\(\epsilon \in\)</span> FIRST(<span class="math inline">\(X\)</span>)</p></li><li><p>若<span class="math inline">\(X \inV_n\)</span>，则对于X的产生式<span class="math inline">\(X \rightarrowY_1Y_2\dots Y_k\)</span></p><ol type="1"><li>先把FIRST(<span class="math inline">\(Y_1\)</span>) - <span class="math inline">\(\{\epsilon\}\)</span> 加入到 FIRST(<span class="math inline">\(X\)</span>)中</li><li>若 <span class="math inline">\(\epsilon \in\)</span> FIRST(<span class="math inline">\(Y_1\)</span>)、FIRST(<span class="math inline">\(Y_2\)</span>)、...、FIRST(<span class="math inline">\(Y_{i-1}\)</span>)（i <span class="math inline">\(\ge\)</span> 2），即 <span class="math inline">\(Y_1\dots Y_{i-1} \overset{*}{\Rightarrow}\epsilon\)</span> <br>则将 FIRST(<span class="math inline">\(Y_i\)</span>) - <span class="math inline">\(\{\epsilon\}\)</span> 加入到 FIRST(<span class="math inline">\(X\)</span>) 中；否则<u>不会继续</u>向 FIRST(<span class="math inline">\(X\)</span>) 中添加符号<br><strong>注意</strong>：若最终 <span class="math inline">\(\epsilon\in\)</span> FIRST(<span class="math inline">\(Y_1\)</span>)、...、FIRST(<span class="math inline">\(Y_k\)</span>)，则 <span class="math inline">\(\epsilon \in\)</span> FIRST(X)</li><li>若<span class="math inline">\(X \rightarrow \epsilon\)</span>，则有<span class="math inline">\(\epsilon \in\)</span> FIRST(<span class="math inline">\(X\)</span>)</li></ol><hr></li><li><p>X是<strong>符号串 </strong><span class="math inline">\(X_1X_2\dotsX_n\)</span>：根据以上三种情形求解任意符号串的FIRST集合</p><ol type="1"><li>先把FIRST(<span class="math inline">\(X_1\)</span>) - <span class="math inline">\(\{\epsilon\}\)</span> 加入到FIRST(<span class="math inline">\(X\)</span>)中</li><li>若 $$ FIRST(<span class="math inline">\(X_1\)</span>)、FIRST(<span class="math inline">\(X_2\)</span>)、...、FIRST(<span class="math inline">\(X_{i-1}\)</span>)（i <span class="math inline">\(\ge\)</span> 2） <br>则将 FIRST(<span class="math inline">\(X_i\)</span>) - <span class="math inline">\(\{\epsilon\}\)</span> 加入到 FIRST(X)中；否则<u>不会继续</u>向 FIRST(X) 中添加符号<br><strong>注意</strong>：若最终 $$ FIRST(<span class="math inline">\(X_1\)</span>)、...、FIRST(<span class="math inline">\(X_k\)</span>)，则 $$ FIRST(X)</li><li>若 <span class="math inline">\(X = \epsilon\)</span>，则 FIRST(<span class="math inline">\(X\)</span>) = <span class="math inline">\(\{\epsilon\}\)</span></li></ol></li></ol><hr></li><li><p>FOLLOW集：FOLLOW(A) = <span class="math inline">\(\{a \text{ | }Z \overset{*}{\Rightarrow} \dots Aa \dots, a \in V_t, A \inV_n\}\)</span>，其中 Z 是文法的开始符号</p></li><li><p>FOLLOW集的构造方式：设#表示输入右端的结束符号</p><ol type="1"><li>初始操作：先将#加入到 FOLLOW(Z) 中</li><li>迭代操作：直至<u>所有非终结符的FOLLOW集都<strong>不再变化</strong></u><ol type="1"><li>若<span class="math inline">\(A \rightarrow \alpha B\beta\)</span>，则将 FIRST(<span class="math inline">\(\beta\)</span>) -<span class="math inline">\(\{\epsilon\}\)</span> 加入到 FOLLOW(B)中</li><li>若 <span class="math inline">\(A \rightarrow \alpha B\)</span>，或<span class="math inline">\(A \rightarrow \alpha B \beta\)</span> 且<span class="math inline">\(\beta \overset{*}{\Rightarrow}\epsilon\)</span>，则将 FOLLOW(A) 加入到 FOLLOW(B) 中</li></ol></li></ol><p><strong>注意</strong>：FIRST集合可以有<span class="math inline">\(\epsilon\)</span>；FOLLOW集合中不能有<span class="math inline">\(\epsilon\)</span>（<strong>确定的终结符</strong>才能决定产生式选择），但可以有#</p></li></ul><hr></li><li><p>LL(1)文法：从<strong>左</strong>向右 + 最<strong>左</strong>推导+ 向前看k = 1个符号</p><ul><li>LL(1)文法的<strong>充要条件</strong>：无二义性 + 无左递归 +消除回溯；设 <span class="math inline">\(A \rightarrow \alpha \text{ | }\beta\)</span><ul><li>FIRST(<span class="math inline">\(\alpha\)</span>) <span class="math inline">\(\cap\)</span> FIRST(<span class="math inline">\(\beta\)</span>) = <span class="math inline">\(\varnothing\)</span></li><li>若 <span class="math inline">\(\beta \overset{*}{\Rightarrow}\epsilon\)</span>，则FIRST(<span class="math inline">\(\alpha\)</span>)<span class="math inline">\(\cap\)</span> FOLLOW(A) = <span class="math inline">\(\varnothing\)</span>，对 <span class="math inline">\(\alpha\)</span> 同理<br><strong>注意</strong>：由<u>LL分析表的构造方法</u>可知，若上式两者有交集，对于同一输入符号会产生<strong>选择冲突</strong></li></ul></li></ul></li><li><p>LL分析法：<strong>从左向右</strong>扫描、执行<strong>最左推导</strong></p><ul><li><p>LL分析程序的组成部分：分析表(A, a) + 总控程序 + 符号栈</p><ul><li>分析表(A, a)：一格表项只能填<strong>两种</strong>类值：<ol type="1"><li>M[A, a] = <span class="math inline">\(A \rightarrow\alpha_i\)</span>，表示用A匹配输入串中的当前字符a</li><li>M[A, a] = error，表示无法用A匹配输入串中的当前符号a</li></ol></li><li>符号栈：存放终结符和非终结符（栈底为#），维护当前推导过程中的信息</li></ul></li><li><p>分析表的构造方法：设 <span class="math inline">\(A \rightarrow\alpha\)</span>为文法中的任一规则，a为终结符或$</p><ul><li>对于 FIRST(<span class="math inline">\(\alpha\)</span>)中的每个终结符a，将 <span class="math inline">\(A \rightarrow\alpha\)</span> 写入M[A, a] <br><strong>注意</strong>：<strong><span class="math inline">\(\alpha\)</span>的首终结符</strong>确定了唯一的产生式选择</li><li>若 <span class="math inline">\(\alpha \overset{*}{\Rightarrow}\epsilon\)</span>，则对于 FOLLOW(A) 中的任意符号b，将<span class="math inline">\(A \rightarrow \epsilon\)</span> 写入M[A, b]<br><strong>注意</strong>：此时<strong>A后紧跟的终结符</strong>确定了唯一的产生式选择</li><li>将剩余未填写的分析表格标记为error</li></ul><p><strong>注意</strong>：对于二义性or左递归的文法，至少有一个M表项填有多条规则</p></li><li><p>执行程序：</p><ol type="1"><li>初始操作：先将#和开始符号Z<strong>依次推入</strong>符号栈</li><li>迭代操作：设<strong>当前</strong>栈顶符号为X，输入终结符为a<ul><li>若 X = a <strong>= #</strong>，则分析成功，即栈和输入序列均只剩#</li><li>若 X = a <span class="math inline">\(\ne\)</span>#，则匹配成功，将X弹出栈，并读入下一个输入符号</li><li>若 X <span class="math inline">\(\in V_n\)</span>，查分析表 M：<ul><li>M[X, a] = <span class="math inline">\(X \rightarrow\text{UVW}\)</span>，则先将X弹出栈，并将WVU<strong>依次</strong>压入栈<br><strong>注意</strong>：要将U暴露在栈顶，符合<strong>最左推导</strong></li><li>M[X, a] = <span class="math inline">\(X \rightarrow\epsilon\)</span>，则只将X弹出栈（不必将<span class="math inline">\(\epsilon\)</span>压栈，因为将<span class="math inline">\(\epsilon\)</span>压栈后又弹栈）</li><li>M[X, a] = error，则转入错误处理程序</li></ul></li></ul></li></ol></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>compiler</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>『database-2』SQL</title>
    <link href="/2023/09/26/database/SQL/"/>
    <url>/2023/09/26/database/SQL/</url>
    
    <content type="html"><![CDATA[<h2 id="关系数据库标准语言-sql">关系数据库标准语言 SQL</h2><h3 id="一有关sql">一、有关SQL</h3><ul><li><p>SQL的特点：</p><ul><li>综合统一：结合了 DDL、DML、DCL 三种关系数据库语言的功能</li><li>高度<strong>非过程化</strong>、易学易用</li><li>面向集合的操纵方式</li></ul><figure style="text-align:center"><p><img src="/2023/09/26/database/SQL/SQL功能.png"><figurecap>9个动词实现SQL核心功能</figurecap></p></figure></li><li><p>基本表与导出表：</p><ul><li>基本表：实际存在的表，真正存储在物理文件中</li><li>导出表：从<strong>基本表导出</strong>的表，是一个虚表，其真实数据不存在数据库中，只是在<u>数据字典</u>中存储其<strong>定义</strong><br><strong>注意</strong>：视图（View）经过定义（CreateView）就可以像基本表那样操作</li></ul></li><li><p>关系数据库的三级模式结构：SQL的关系数据库同样支持三级模式结构</p><figure style="text-align:center"><p><img src="/2023/09/26/database/SQL/三级模式.png"> <figurecap>三级模式结构</figurecap></p></figure><p><strong>注意</strong>：存储文件的<strong>逻辑结构</strong>组成了内模式；存储文件的物理存储结构对用户隐藏</p></li></ul><hr><h3 id="二sql数据查询功能">二、SQL数据查询功能</h3><ul><li><p>SQL查询语句块：SELECT-FROM-WHERE，其中：</p><ul><li>SELECT：选取<strong>目标列</strong>，表示目标检索项</li><li>FROM：指明<strong>基本表或视图</strong>，可以由<u>一个或多个表</u>组成</li><li>WHERE：选取符合检索条件的<strong>元组</strong></li></ul></li><li><p>SQL投影查询：<strong>SELECT</strong> A1, ..., An FROM S...，表示从关系S中抽取A1列、A2列 <br>SELECT <strong>DISTINCT</strong> AFROM S ... 表示从关系S中抽取A列后，<strong>去除重复行</strong></p></li><li><p>SQL选取检索：通过<strong>WHERE</strong>子句引出查询条件；检索条件由<u>属性名、常量、比较与布尔运算符</u>（AND等）组成</p></li><li><p>SQL排序检索：在<u>查询语句块<strong>最后</strong></u>接<strong>ORDER BY</strong> A1, ..., An (ASC orDESC)，将各行<strong>按指定列排序</strong><br><strong>注意</strong>：若不指定升序或降序，默认按升序排列；可以按照单列或多列（多关键字）排序</p></li><li><p>SQL连接操作：查询涉及两个以上表的信息，将多个由<strong>连接属性</strong>相关联的表按照一定条件连接起来</p><ol type="1"><li>SELECT：指出最终选取的所有<strong>列名</strong>（可来自多个表，必要时使用关系名修饰）</li><li>FROM：指出需要进行连接的<strong>各关系名称</strong></li><li>WHERE：指出<strong>元组连接谓词</strong>（表1.属性A <span class="math inline">\(\theta\)</span> 表2.属性B） +连接后的<strong>选取条件</strong></li></ol></li><li><p>自连接操作：给一张表<u>复制为两个非同名表</u>，对其进行连接操作</p></li><li><p>外连接操作：在连接谓词的某一端加一个<strong>星号*</strong>，表明为所在端的表增加一<strong>空行</strong><br>该空行可以与另一表中<u>不满足连接条件</u>（即被舍弃）的元组连接，从而<strong>可将悬浮元组输出</strong></p><hr></li><li><p>SQL子查询嵌套检索：查询间可以嵌套（<strong>结构化查询</strong>的体现）</p><ul><li><p>子查询的分类：普通子查询 + 相关子查询</p><ul><li>普通自查询：子查询的查询条件<strong>不依赖于父查询</strong></li><li>相关子查询：子查询的查询条件<strong>依赖于父查询</strong></li></ul><p><strong>注意</strong>：不相关子查询可以先直接求出子查询的返回值，再求解父查询；相关子查询中父子要交替进行</p></li><li><p>查询语句块：在父查询的<strong>WHERE后</strong>用括号包裹<strong>新的S-F-W查询块</strong></p></li><li><p>子查询的返回值：可以返回一个单值、也可以返回一组值</p><ul><li>返回单值：可在 WHERE 中直接使用比较运算符</li><li>返回集合：需使用 IN、ANY 等关键字</li></ul></li><li><p>嵌套 IN谓词：满足筛选条件的属性值存在于<strong>子查询的返回值集合</strong>中，如IN (child)</p></li><li><p>嵌套比较运算符：若能够确认子查询<strong>仅返回单值</strong>，则父查询的WHERE 中可以使用比较运算符</p><figure style="text-align:center"><p><img src="/2023/09/26/database/SQL/嵌套查询.png" height="75%" width="75%"></p></figure></li><li><p>嵌套 ANY（ALL）的子查询：子查询<u>返回多值</u>时使用<strong>比较运算符 + ANY（ALL）</strong>，如： <br>“&gt; ANY(child)”表示大于子查询child 返回的<strong>某个值</strong> <br>“<span class="math inline">\(\le\)</span> ALL(child)” 表示小于等于子查询child返回的<strong>全部值</strong> <br>“ = ANY(child)” 表示等于子查询child返回的<strong>某个值</strong> <br><strong>注意</strong>：=ANY 等价于 IN谓词；!= ALL 等价于 NOT IN 谓词</p></li><li><p>嵌套 EXISTS 的子查询：<strong>EXISTS(child) = true</strong> <span class="math inline">\(\Leftrightarrow\)</span> child查询结果<strong>非空</strong>；EXISTS 不返回查询数据</p><ul><li><p>EXISTS表示<strong>全称</strong>：p总是满足 <span class="math inline">\(\Rightarrow\)</span><strong>不存在</strong>p不满足的情况</p><figure style="text-align:center"><p><img src="/2023/09/26/database/SQL/存在表全称.png"><figurecap>全称常用于表示“全选”</figurecap></p></figure></li><li><p>EXISTS表示<strong>蕴含</strong>：若p满足则q满足 <span class="math inline">\(\Rightarrow\)</span>不存在p满足但q不满足的情况</p><figure style="text-align:center"><p><img src="/2023/09/26/database/SQL/存在表蕴含.png"><figurecap>蕴含常用于表示“条件全选”</figurecap></p></figure></li></ul></li></ul><hr></li><li><p>并、差、交检索</p><ul><li>并集：SELECT ... <strong>UNION</strong> SELECT ...</li><li>交集：SELECT ... <strong>INTERSECT</strong> SELECT ...</li><li>差集：SELECT ... <strong>MINUS</strong> SELECT ...</li></ul></li><li><p>库函数检索：聚集函数</p><ul><li>COUNT(A)：求出<u>属性值为A</u>的行数；COUNT(*)：求出<u>总</u>行数</li><li>SUM(A)：对数值列A求总和</li><li>AVG(A)：对数值列A求平均值</li><li>MAX(A)：在列A中找出最大值；MIN(A)：在列A中找出最小值</li></ul><p><strong>注意</strong>：库函数检索只能在 SELECT 或 HAVING子句中出现</p></li><li><p>分组检索：<strong>GROUP BY</strong> 若干列名[<strong>HAVING</strong> 条件表达式]</p><ul><li>GROUP BY若干列名：表示<strong>分组依据</strong>；同组元组聚在一起，同一组内的列值不可完全相同</li><li>HAVING 条件：将不满足条件的组筛除（可选项）</li></ul><p><strong>注意</strong>：分组后SELECT中的<strong>聚集函数</strong>会<u>为每个组都计算一个结果</u>，不分组则直接按整列计算<br>注意<strong>编写顺序</strong>：WHERE（先选出符合条件的行）<span class="math inline">\(\rightarrow\)</span> GROUP BY（确定分组列）<span class="math inline">\(\rightarrow\)</span> HAVING（最后筛选组）</p></li><li><p>算术表达式的检索：SELECT子句中可包含由<u>属性列 + 常量 + 库函数 +算术运算符</u>构成的<strong>算术表达式</strong></p></li><li><p>部分匹配查询：列名 <strong>LIKE</strong> / <strong>NOTLIKE</strong> 字符串常量（模糊查询）</p><ul><li>列名：必须为字符串型</li><li>字符串常量：可包含 %（匹配任意<strong>多个</strong>字符）和 _（匹配任意<strong>单个</strong>字符）</li></ul></li><li><p>基于派生表的查询：SELECT ... FROM <strong>(child) AS<u>child_table</u>(A1, ...,An)</strong>，即需要给派生表指定一个<strong>别名</strong><br><strong>注意</strong>：若子查询中<u>未使用聚集函数</u>，就不必为派生表指定列名，其列名默认为子查询SELECT的列名</p></li></ul><hr><h3 id="三sql数据定义功能">三、SQL数据定义功能</h3><ul><li><p>定义基本表：其基本格式为如下</p><figure style="text-align:center"><p><img src="/2023/09/26/database/SQL/定义表.png"> <figurecap>定义表的格式</figurecap></p></figure><p><strong>注意</strong>：新建立的表是空表，表的定义及有关约束存放在数据字典中</p><ul><li><p>SQL92的数据类型：</p><figure style="text-align:center"><p><img src="/2023/09/26/database/SQL/数据类型.png"> <figurecap>部分基本数据类型</figurecap></p></figure></li><li><p>完整性约束：</p><figure style="text-align:center"><p><img src="/2023/09/26/database/SQL/完整性约束.png"></p></figure></li></ul></li><li><p>删除基本表：<strong>DROP TABLE</strong> <表名> [RESTRICT |CASCADE]</表名></p><ul><li>RESTRICT：表示删除表<strong>有限制条件</strong>，默认RESTRICT有效</li><li>CASCADE：表示删除表<strong>没有限制条件</strong></li></ul></li><li><p>修改基本表：其基本格式如下</p><figure style="text-align:center"><p><img src="/2023/09/26/database/SQL/修改表.png"> <figurecap>修改表的格式</figurecap></p></figure><hr></li><li><p>定义索引：索引可以建立在<strong>一列</strong>或<strong>多列</strong>上，其基本格式如下</p><figure style="text-align:center"><p><img src="/2023/09/26/database/SQL/建立索引.png"></p></figure><ul><li>UNIQUE：表明该索引的<u>每个索引值</u>仅对应<u>唯一的数据记录</u></li><li>CLUSTER：表明要建立的索引是<strong>聚簇索引</strong></li><li>次序：可以选择为该列上的索引值设置<strong>排列次序</strong>，默认为ASC</li></ul><p><strong>注意</strong>：索引是<u>加快查询速度</u>的有效手段，属于内模式的范畴，无需用户干预</p></li><li><p>修改索引<strong>名</strong>：<strong>ALTER INDEX</strong><旧索引名> RENAME TO <新索引名></新索引名></旧索引名></p></li><li><p>删除索引：<strong>DROP INDEX</strong> <索引名><br><strong>注意</strong>：数据的增删改会导致<u>维护索引的开销</u>，可以考虑删除不必要的索引</索引名></p><hr></li><li><p>定义视图：视图是一个虚表，其数据存于原先的基本表中，<u>随基本表改变而变化</u></p><figure style="text-align:center"><p><img src="/2023/09/26/database/SQL/建立视图.png"></p></figure><ul><li>子查询：任意的 SELECT 语句</li><li>WITH CHECK OPTION：子查询中的谓词条件表达式</li></ul><p><strong>注意</strong>：视图的各列名可以省略（或全部指定），默认为SELECT 子句的各属性字段<br>不能省略的情况：目标列使用了<strong>聚集函数</strong>；多表连接中将<strong>各表同名列</strong>作为目标列；需要换列名称</p></li><li><p>删除视图：<strong>DROP VIEW</strong> <视图名> [CASCADE]</视图名></p></li><li><p>查询视图：使用<u>与基本表查询相同</u>的方式（SELECT-FROM-WHERE）对视图进行查询</p><ul><li><p>视图消解：从数据字典中取出<strong>视图定义</strong>，将<u>视图子查询</u>和<u>用户查询</u>结合，转化为<strong>等价的对基本表的查询</strong></p><figure style="text-align:center"><p><img src="/2023/09/26/database/SQL/视图查询.png"></p></figure></li><li><p>视图的作用：视图是数据库的“窗户”，可以观察用户感兴趣的数据及变化</p><ol type="1"><li>为同一数据赋予<strong>多种观察角度</strong></li><li>提供一定的<strong>逻辑独立性</strong></li><li>对数据提供<strong>安全保护</strong></li></ol></li></ul></li></ul><hr><h3 id="四sql数据更新功能">四、SQL数据更新功能</h3><ul><li><p>插入数据：可分为插入元组或插入子查询结果</p><ul><li>插入元组：<strong>INSERT INTO</strong> &lt;表名&gt; (若干属性列)VALUES (若干元组)</li><li>插入子查询结果：<strong>INSERT INTO</strong> &lt;表名&gt;（若干属性列）&lt;SELECT 子查询&gt;</li></ul></li><li><p>修改数据：<strong>UPDATE</strong> &lt;表名&gt;<strong>SET</strong> (若干 &lt;列名&gt; <strong>=</strong>&lt;表达式&gt;) [WHERE&lt;条件&gt;]，表示修改符合条件的<strong>行的属性值</strong><br><strong>注意</strong>：修改元组使用UPDATE，而修改整个表的特性使用ALTER</p></li><li><p>删除数据：<strong>DELETE FROM</strong> &lt;表名&gt; [WHERE&lt;条件&gt;]，即<strong>删除符合条件的行</strong></p></li></ul><hr><h3 id="五sql数据控制功能">五、SQL数据控制功能</h3><ul><li>授权与回收权限：安全控制<ul><li>授权：<strong>GRANT</strong> &lt;权限&gt; [ON <对象类型>&lt;对象名&gt;] <strong>TO</strong> &lt;用户&gt;</对象类型></li><li>回收权限：<strong>REVOKE</strong> &lt;权限&gt; [ON &lt;对象类型&gt;&lt;对象名&gt;] <strong>FROM</strong> &lt;用户&gt;</li></ul></li></ul><hr><h3 id="六空值运算">六、空值运算</h3><ul><li><p>空值（NULL）的含义：不知道（如漏填）、数据缺失（如缺席）、不便填写（如隐私信息）</p></li><li><p>判断空值：WHERE 中使用条件语句 IS NULL 或 IS NOT NULL</p></li><li><p>空值的计算：空值 ArithmaticOp 任意值 = 空值、空值 CompareOp任意值 = Unknown</p></li><li><p>空值的逻辑运算：T AND U = U、F OR U = U、NOT U = U</p><p><strong>注意</strong>：含 NOT NULL、UNIQUE <strong>约束</strong> 或<strong>主码属性</strong>都不能取 NULL</p></li></ul><hr><h3 id="七嵌入式sql">七、嵌入式SQL</h3><ul><li><p>SQL的实际应用：内嵌在高级语言（如C语言）中，将<u>SQL的特性</u>与<u>程序设计语言的特性</u>相结合</p></li><li><p>内嵌SQL：将SQL<strong>预编译</strong>为高级语言源码，再按诸语言方式进行编译</p><ul><li>区分SQL与宿主语言：在SQL语句前<strong>增加前缀EXEC SQL</strong></li><li>SQL与宿主语言通信：<strong>SQL通信区</strong>负责向宿主语言传递执行状态；宿主语言设置<strong>主变量</strong>与SQL交换数据</li><li>SQL与宿主语言的协调：通过<strong>游标</strong>缓存SQL的执行结果</li></ul></li><li><p>ODBC与JDBC：基于X/Open和ISO/IEC的SQL调用级接口规范</p><ul><li><p>功能：建立与数据库的连接；发送SQL语句；处理结果</p><p><strong>注意</strong>：JDBC在设计思想上沿袭了ODBC</p></li></ul><figure style="text-align:center"><p><img src="/2023/09/26/database/SQL/JDBC.png"> <figurecap>JDBC四大组件</figurecap></p></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>『database-1』relational database</title>
    <link href="/2023/09/14/database/relational-database/"/>
    <url>/2023/09/14/database/relational-database/</url>
    
    <content type="html"><![CDATA[<h2 id="关系数据库">关系数据库</h2><h3 id="一关系的数学定义">一、关系的数学定义</h3><ul><li><p>域：一组具有<strong>相同数据类型</strong>的值的<strong>集合</strong>，如整数、实数、布尔值等</p></li><li><p>元组和分量：设一组域为 <span class="math inline">\(D_1\)</span>,..., <span class="math inline">\(D_n\)</span>，这些域中可存在相同的<br>这些域的<u><strong>笛卡尔积</strong></u>为 <span class="math inline">\(D_1 \times \dots \times D_n = \{(d_1, \dots d_n) |d_i \in D_i, i = 1, \dots n\}\)</span></p><ul><li>元组：<span class="math inline">\(D_1 \times \dots \timesD_n\)</span>中的一个<strong>元素</strong> <span class="math inline">\((d_1, \dots d_n)\)</span> 为一个元组</li><li>分量：n元组中的每一个值 <span class="math inline">\(d_i\)</span>称为分量</li></ul></li><li><p>笛卡尔积与二维表：表头代表各个域 <span class="math inline">\(D_i\)</span>，表头下方每一<strong>行</strong>是一个元组</p></li><li><p>基数：一个域允许的<strong>不同取值的个数</strong>；<span class="math inline">\(D_1 \times \dots \times D_n\)</span> 的基数为<span class="math inline">\(\prod_{i=1}^n m_i\)</span>，其中 <span class="math inline">\(m_i\)</span> 是域 <span class="math inline">\(D_i\)</span> 的基数</p><hr></li><li><p>关系：笛卡尔积 <span class="math inline">\(D_1 \times \dots\times D_n\)</span> 的<strong>子集</strong>称为各域上的关系，记作 <span class="math inline">\(R(D_1, \dots, D_n)\)</span>，表示 n元关系</p></li><li><p>关系与二维表：表头由各个 <span class="math inline">\(D_i\)</span>组成；每一列对应一个域，并附加一个属性名，将该列作为<strong>属性</strong><br><strong>注意</strong>：每一列必须拥有<strong>不同的属性名</strong>；属性<span class="math inline">\(A_i\)</span> 的取值范围为 <span class="math inline">\(D_i\)</span>，称为<strong>值域</strong></p></li><li><p>关系的性质：</p><ul><li>各列是同质的，即每一列的分量<strong>来自同一个域</strong></li><li>行的顺序无所谓，可以调换；列的顺序也无所谓，可以调换</li><li>每一分量必须是不可再分的数据，这被称为满足<strong>第一范式</strong>（1NF）</li><li>任意两个元组不能完全相同；不同的列可以出自同一个域</li></ul><p><strong>注意</strong>：由于集合中<u>不能包含<strong>重复元素</strong></u>，关系的任意两个元组不可完全相同，做投影运算后也必须对行去重</p></li></ul><hr><h3 id="二关系数据模型">二、关系数据模型</h3><ul><li><p>关系模型的数据结构：实体间的<strong>联系</strong>均采用<u>单一的数据结构</u>“关系”表示0</p><ul><li><p>码（key）：又被称作键</p><ul><li>候选码：可<strong>唯一标识</strong>一个元组，且具有<strong>最小性</strong>（不关心多余的属性）的属性组</li><li>主码（码）：选定关系中<strong>其中一个候选码</strong>为主码</li></ul></li><li><p>主属性：<strong>主码中</strong>的各属性称为主属性</p></li><li><p>非主属性：不包含在任何候选码中的属性</p><hr></li><li><p>关系模式：关系的描述，表示为 R(U, D, dom, F)</p><ul><li>R：表示<strong>关系名</strong></li><li>U：表示组成该关系的<strong>属性名的集合</strong></li><li>D：表示 U 中<u>属性所来自</u>的<strong>域</strong></li><li>dom：表示<u>属性</u>向<u>域</u>的<strong>映像集合</strong></li><li>F：表示属性间<u>依赖关系</u>的<strong>集合</strong></li></ul><p>关系模式可以简记为 R(<span class="math inline">\(A_1\)</span>, ...,<span class="math inline">\(A_n\)</span>)，其中R为关系名、<span class="math inline">\(A_i\)</span> 为属性名</p><p><strong>注意</strong>：关系模式是<strong>相对稳定</strong>的；关系则是<strong>动态</strong>的，可随时间变化</p></li><li><p>关系数据库的“型”和“值”：</p><ul><li>型：<u>关系模式</u>的集合；关系模式可以理解为数据库逻辑设计的“<strong>类型</strong>”（schema）</li><li>值：<u>关系</u>的集合；关系可以看作给定时刻数据模式中数据的一个“<strong>快照</strong>”（instance）</li></ul></li></ul><hr></li><li><p>关系模型的语义约束</p><ul><li><p>实体完整性：若属性组A是关系R的<strong>主属性</strong>，则属性组A中的各属性均<strong>不能取空值</strong>（不存在or 不完整）</p></li><li><p>参照完整性：描述<strong>关系之间</strong>属性的相互引用：设R是参照关系、S是被参照关系</p><ul><li>外部码：设F是关系R的一个 or 一组属性，<u>但不是R的码</u>若F与关系S的<u>主码Ks</u>定义在<strong>同一个域</strong>，则称F为R的<strong>外部码</strong>（而不是本关系的主码）</li><li>参照完整性：若R的外部码F 与 S的主码P相对应则R中的任意元组的F中的各属性值或等于<strong>S中某个元组的P值</strong>，或者全取<strong>空值</strong></li></ul><p><strong>注意</strong>：由于P是关系S的主码，<u>P可以取遍<strong>所有合法值</strong></u>，故关系R中的非空F必须取自S中某个元组的P值</p></li><li><p>用户定义完整性：用户针对<strong>具体的应用环境</strong>定义的完整性约束条件</p></li></ul></li><li><p>关系模型的数据操作：以<strong>关系运算</strong>为基础，操作的<u>对象</u>和<u>结果</u>都是<strong>集合</strong></p><ul><li>关系代数：通过<strong>代数方式</strong>操纵数据</li><li>关系演算：其中包括元组关系演算 +域关系演算，通过<strong>逻辑方式</strong>操纵数据</li></ul><hr></li><li><p>关系模型的优点和缺点：</p><ul><li>优点：<ol type="1"><li>建立在严格的数学基础上</li><li>使用单一的概念（<strong>关系</strong>）描述</li><li>数据结构简单直观、易于理解</li><li>存取路径对用户<strong>透明</strong>，数据独立性高，简化了DB开发工作</li></ol></li><li>缺点：<ol type="1"><li>由于存取路径对用户透明，查询效率不如层次模型与网状模型</li><li>提高性能需要查询优化，增加DBMS的开发难度</li></ol></li></ul></li></ul><hr><h3 id="三关系代数">三、关系代数</h3><ul><li><p>关系代数的分类：</p><ul><li><p><strong>基本</strong>关系代数：并、差、广义笛卡尔积、选择、投影</p></li><li><p><strong>扩展</strong>关系代数：交、连接、除法</p></li></ul></li><li><p>常规集合运算：二元运算，两个关系必须是<strong>同类关系</strong>（<strong>度</strong>相同、对应属性值需来自<strong>同一个域</strong>）<br>设 R 和 S 分别表示两个同类关系，其度分别为 n 和 m，其分别包含 <span class="math inline">\(k_1\)</span> 和 <span class="math inline">\(k_2\)</span> 个元组：</p><ul><li>并：<span class="math inline">\(R \cup S = \{t | t \in R \lor t \inS\}\)</span>，即将两个关系的<strong>所有元组</strong>合并成新的关系</li><li>交：<span class="math inline">\(R \cap S = \{t|t \in R \land t \inS\}\)</span>，即将两个关系的<strong>相同元组</strong>组建成新的关系</li><li>差：<span class="math inline">\(R - S = \{t | t \in R \land t \notinS\}\)</span>，即<strong>属于R但不属于S的元组</strong>构成的新的关系</li><li>广义笛卡尔积：<span class="math inline">\(R \times S = \{(r,s)\text{ | }r \in R \land s \inS\}\)</span>，即将R中各元组和S中各元组<strong><u>拼接</u>为新的元组</strong><br><strong>注意</strong>：<span class="math inline">\(R \timesS\)</span> 的度为 n + m（即拼接两个关系的各属性）；<span class="math inline">\(R \times S\)</span> 中共包含 <span class="math inline">\(k_1 \times k_2\)</span> 个元组 <br><span class="math inline">\(R \times S\)</span> 中的元组的前 n 个分量来自 <u>R中的元组</u>，后 m 个分量来自 <u>S 中的元组</u></li></ul></li><li><p>特有关系运算：</p><ul><li><p>选取：<span class="math inline">\(\sigma_F(R) = \{t|t \in R,F(t)=\text{true}\}\)</span>，即将关系R中<strong>符合条件 F的元组</strong>筛选出来 <br>其中 F是<strong>选择条件</strong>，基本形式为 <span class="math inline">\(x\theta y\)</span>，x 和y表示<u>属性名</u>或常数、<span class="math inline">\(\theta\)</span>表示算数 or 逻辑<u>运算符</u></p></li><li><p>投影：<span class="math inline">\(\Pi_A(R) = \{t[A] \text{ }|\text{ }t \in R, A \subseteqU\}\)</span>，即从关系R(U)中抽取若干<strong>属性列 </strong>并<strong>删去重复行</strong> 其中 A是若干属性名构成的集合，指向各待选列（元组的分量）</p><p><strong>注意</strong>：“选择”是从<strong>行</strong>的角度做筛选，“投影”是从<strong>列</strong>的角度做筛选</p><hr></li><li><p><span class="math inline">\(\theta\)</span> 连接：<span class="math inline">\(R \underset{X \theta Y}{\Join} S = \{(r, s) \text{| }r \in R \land s \in S \land r[X] \text{ } \theta \text{}s[Y]\}\)</span>，即从<span class="math inline">\(R \timesS\)</span>中选择满足 <span class="math inline">\(\theta\)</span>的元组对 <br><span class="math inline">\(r[X] \text{ } \theta \text{ }s[Y] = \text{true} \Leftrightarrow\)</span>元组r在<u>属性组X</u>上的取值 与元组s在<u>属性组Y</u>上的取值满足<strong>比较关系</strong> <span class="math inline">\(\theta\)</span> <br><strong>注意</strong>：<span class="math inline">\(\theta\)</span>连接中不要求属性组X和Y相同，只需<strong>可比较</strong>就行；自然连接要求属性组X和Y必须相同</p></li><li><p>自然连接：<span class="math inline">\(R \Join S = \{(r, s)[U-X]\text{ | } r \in R \land s \in S \land r[X] =s[X]\}\)</span>，其中U为R和S的全体属性集合<br><strong>注意</strong>：自然连接是<u>比较属性组<strong>同名</strong></u>，且最终<u>去除重复公共列</u>的<strong>等值连接</strong></p></li><li><p>计算连接：找出R和S中分别在X和Y上满足 <span class="math inline">\(\theta\)</span>关系的<strong>元组对</strong>，将这些元组对<strong>拼接</strong>构成新的关系<br>计算自然连接：找出R和S在<u>公共属性X</u>上<strong>等值</strong>的<strong>元组对</strong>，将这些元组对<strong>拼接</strong>并 <strong>对列去重</strong>构成新的关系</p><figure style="text-align:center"><p><img src="/2023/09/14/database/relational-database/连接运算.png"> <figurecap>常见的连接运算</figurecap></p></figure><p><strong>注意</strong>：若R和S具有<strong>同名属性A</strong>，<u>笛卡尔积</u>或<u>连接</u>后应使用<strong>各自关系名修饰属性A</strong>，如R.A、S.A以做区分</p><hr></li><li><p>除法：设R(X, Y)和S(Y, ...)，<span class="math inline">\(R➗S =\{t \text{ | } t \in \Pi_X(R) \land s \in S \land (t, s) \inR\}\)</span><br><strong>注意</strong>：<u>被除关系的属性</u>有且仅有<strong>两种</strong>：属性组X和 属性组Y</p></li><li><p>计算除法：先求出<span class="math inline">\(\Pi_X(R)\)</span>，再分别计算<span class="math inline">\(\Pi_X(R)\)</span>中各元素的<strong>象集<span class="math inline">\(Y_x\)</span></strong>，找出所有满足 <span class="math inline">\(\Pi_Y(S) \subseteq Y_x\)</span>的<strong>X值</strong></p><figure style="text-align:center"><p><img src="/2023/09/14/database/relational-database/除法运算.png"> <figurecap>除法运算</figurecap></p></figure></li><li><p>关系代数的适用场景：各运算之间常常<strong>组合使用</strong></p><ul><li>选择：选出表中<strong>所有满足某条件</strong>的条目</li><li>投影：获得表中<strong><u>需要</u>的属性</strong>信息</li><li>自然连接：根据已有的表一信息，借助连接属性 <strong><u>引入组装</u>表二</strong>的信息（表一信息还不够）</li><li>除法：从表一中获得<strong>包含表二<u>某属性组下全部信息</u></strong>的属性信息，一般先投影后做除法</li></ul></li></ul></li></ul><hr><h3 id="四关系演算">四、关系演算</h3><ul><li><p>元组关系演算：以<strong>元组</strong>为变量</p><ul><li>元组演算表达式：<span class="math inline">\(\{t \text{ |}\Phi(t)\}\)</span>，表示所有<strong>使谓词<span class="math inline">\(\Phi\)</span>为真</strong>的元组集合，由<u>原子公式</u>+ <u>运算符</u>组成</li><li>原子公式：主要分为以下三类：<ol type="1"><li>R(t)：断言元组 t 是关系 R 中的元组</li><li>t[i] <span class="math inline">\(\theta\)</span> u[j]：断言<u>元组 t的第i个分量</u> 与 <u>元组 u 的第j个分量</u>满足比较关系<span class="math inline">\(\theta\)</span></li><li>t[i] <span class="math inline">\(\theta\)</span> c 或 c <span class="math inline">\(\theta\)</span> t[i]：断言<u>元组 t的第i个分量</u> 和 <u>常量 c</u> 满足比较关系<span class="math inline">\(\theta\)</span></li></ol></li><li>元组演算公式的递归定义：<ol type="1"><li>每个原子公式是公式</li><li>若 <span class="math inline">\(\Phi\)</span> 是公式，则 <span class="math inline">\(\forall t(\Phi)\)</span>、<span class="math inline">\(\exist t(\Phi)\)</span>都是公式，其中t是<strong>约束元组变量</strong></li><li>若<span class="math inline">\(\Phi_1\)</span>和<span class="math inline">\(\Phi_2\)</span>都是公式，则<span class="math inline">\(\Phi_1 \land \Phi_2\)</span>、<span class="math inline">\(\Phi_1 \lor \Phi_2\)</span> 以及 <span class="math inline">\(\urcorner \Phi_1\)</span> 都是公式</li></ol></li></ul></li><li><p>域关系演算：以<strong>元组各分量</strong>为变量</p><ul><li><p>域演算表达式：<span class="math inline">\(\{(x_1, \dots x_k)\text{ | }\Phi(x_1, \dots x_k)\}\)</span></p></li><li><p>原子公式：主要分为以下三类：</p><ol type="1"><li>R(<span class="math inline">\(x_1, \dots x_k\)</span>)，表示 <span class="math inline">\((x_1, \dots x_k)\)</span> 是关系R的一个元组</li><li><span class="math inline">\(x_i \theta y_j\)</span>，表示域变量<span class="math inline">\(x_i\)</span> 和 <span class="math inline">\(y_j\)</span> 之间满足比较关系<span class="math inline">\(\theta\)</span></li><li><span class="math inline">\(x_i \theta c\)</span> 或 <span class="math inline">\(c \theta x_i\)</span>，表示域变量 <span class="math inline">\(x_i\)</span> 和 常量 c 之间满足比较关系<span class="math inline">\(\theta\)</span></li></ol><p><strong>注意</strong>：域演算与元组关系演算具有<strong>相同的运算符</strong>、以及<strong>相同的公式递归定义</strong></p></li></ul></li><li><p>关系运算的安全约束：</p><ul><li>安全表达式：<strong>不产生无限关系</strong>的表达式，不安全的表达式如<span class="math inline">\(\{t \text{ | } \urcornerR(t)\}\)</span></li><li><span class="math inline">\(\text{dom}(\Phi)\)</span>：<strong>有限</strong>符号集，包含谓词公式<span class="math inline">\(\Phi\)</span>中的<u>所有<strong>显式常量</strong></u>+ <u>所有<strong>关系中元组</strong>的所有分量值</u><br><strong>注意</strong>：公式 <span class="math inline">\(\Phi\)</span>运算得到的最终关系、中间关系的<strong>所有元组各分量</strong>都必须属于<span class="math inline">\(\text{dom} (\Phi)\)</span></li></ul></li><li><p>三类关系运算的等价性：经过安全约束的关系演算和关系代数的<strong>表达能力是等价的</strong>，可以相互转换</p><figure style="text-align:center"><p><img src="/2023/09/14/database/relational-database/三类关系运算.png" width="75%" height="75%"></p><figcaption><p>三类关系运算</p></figcaption></figure><p><strong>注意</strong>：基本关系代数是<strong>过程化语言</strong>，元组关系演算和域关系演算是<strong>非过程化语言</strong></p></li></ul><hr><h3 id="五关系数据语言">五、关系数据语言</h3><ul><li><p>数据库数据语言：从功能上分为以下三种</p><ul><li>数据定义语言（DDL）：包括模式DDL、外模式DDL、内模式DDL<br><strong>注意</strong>：DDL用于定义数据库的<strong>三级模式</strong>，包括数据库的<u>存储结构</u>与<u>访问方式</u></li><li>数据操纵语言（DML）：支持数据库的<u>检索、插入、删除、修改操作</u><br><strong>注意</strong>：DML语句被翻译为由<strong>低级指令</strong>构成的执行方案，由查询执行引擎执行</li><li>数据控制语言（DCL）：完成数据库的<u>安全性控制、完整性控制、并发控制</u>等</li></ul></li><li><p>关系数据语言的特点：</p><ul><li>一体化；将 Definition 和 Manipulation融为一体，只给用户提供一种<strong>查询语言</strong></li><li>非过程化：只需用户指定需要什么数据，不用指明如何获得数据（声明式DML）</li><li>面向集合的存取方式：操作对象是一个or多个关系、操作结果也是一个新的关系</li></ul></li><li><p>查询语言：关系数据语言的<strong>核心是<u>查询</u></strong>，<u>关系运算</u>是设计<u>关系数据语言</u>的基础</p><figure style="text-align:center"><p><img src="/2023/09/14/database/relational-database/关系数据语言.png"><figurecap>关系运算的分类决定查询语言的分类</figurecap></p></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>『compiler-2』lexer</title>
    <link href="/2023/09/13/compiler/lexer/"/>
    <url>/2023/09/13/compiler/lexer/</url>
    
    <content type="html"><![CDATA[<h2 id="词法分析">词法分析</h2><h3 id="一词法分析的功能">一、词法分析的功能</h3><ul><li><p>词法分析程序的功能：</p><ul><li>对词法进行分析：根据词法规则<strong>识别（组合）</strong>单词，并进行<strong>词法检查</strong></li><li>对常数值实现<u>数字字符串</u>到<u>二进制数值</u>的转变</li><li>删除空格符 + 注释</li></ul></li><li><p>单词：语言的基本语法单位，一般有四类单词：</p><ul><li>保留字：由源程序语言定义，如 BEGIN、IF 等</li><li>标识符：<strong>由程序员定义的</strong>，表示各种名字的符号串</li><li>常数：无符号数、布尔常数、字符串常数等</li><li>分界符：如 + 、-、*、(、) 、&lt; 等</li></ul></li><li><p>单词的内部形式：单词类别 + 单词的值</p><ul><li>单词类别：按<strong>单词种类</strong>分类；保留字和分界符均采用<strong>一符一类</strong></li><li>单词值：标识符和常数自身的值（指针值）</li></ul></li></ul><hr><h3 id="二文法与状态图">二、文法与状态图</h3><ul><li><p>根据文法画出状态图：文法必须是<u><strong>左线性文法</strong></u>，即3型文法</p><ol type="1"><li>设 G 的每一个<strong>非终结符</strong>都是一个状态</li><li>设一个<strong>开始状态</strong> S</li><li>若 <span class="math inline">\(\text{Q} \rightarrow\text{t}\)</span> ，其中 <span class="math inline">\(\text{Q} \in\text{V}_n\)</span>、<span class="math inline">\(\text{t} \in\text{V}_t\)</span>，则连接从 <strong>S</strong> 到 Q 的有向边，边上写t</li><li>若 <span class="math inline">\(\text{Q} \rightarrow\text{Rt}\)</span>，其中 <span class="math inline">\(\text{Q} \in\text{V}_n\)</span>、<span class="math inline">\(\text{t} \in\text{V}_t\)</span>，则连接从 <strong>R</strong> 到 Q 的有向边，边上写t</li><li>连接好所有有向边之后，将<u>开始符号对应的状态</u>标记为<strong>终结状态</strong></li></ol><p><strong>注意</strong>：给定左（右）线性文法，可以将其改造为<strong>等价</strong>的右（左）线性文法</p></li></ul><hr><h3 id="三词法分析程序-getsymbol">三、词法分析程序 getSymbol()</h3><ul><li><p><u>单遍扫描</u>的词法分析程序：以<strong>词法分析</strong>为核心</p><figure style="text-align:center"><p><img src="/2023/09/13/compiler/lexer/单遍结构.png" width="75%" height="75%"></p></figure></li><li><p>词法规则：规定了<u>四类<strong>单词</strong></u>的构造方式</p></li><li><p>词法状态图：根据<strong>词法规则</strong>构造<br><strong>注意</strong>：小的单词集合可被简单构造为无环转移图；<u>无限</u>的词类（如标识符、无符号整数）需要构造<strong><u>有环</u>转移图</strong></p><figure style="text-align:center"><p><img src="/2023/09/13/compiler/lexer/状态图.png" width="75%" height="75%"></p></figure></li><li><p>词法分析程序：设计<u>单词分类</u>、分析程序所需的<u>全局变量</u>、<u>词法分析程序算法</u></p></li></ul><hr><h3 id="四有穷自动机">四、有穷自动机</h3><ul><li><p>DFA五元式：<span class="math inline">\(\text{M = } \{S, \Sigma,\delta, s_0, Z\}\)</span></p><ul><li>S：表示确定自动机的<u>有穷</u><strong>状态集合</strong></li><li><span class="math inline">\(\Sigma\)</span>：表示<strong>输入</strong>字母表</li><li><span class="math inline">\(\delta\)</span>：映射函数，定义状态转移函数 <span class="math inline">\(\delta: S \times \Sigma \rightarrow S\)</span> 若<span class="math inline">\(\delta(s,a) = s&#39;\)</span>， 则 <span class="math inline">\(s, s&#39; \in S\)</span>，<span class="math inline">\(a \in \Sigma\)</span></li><li><span class="math inline">\(s_0\)</span>：初始状态，有 <span class="math inline">\(s_0 \in S\)</span></li><li>Z：终止状态集合，有 Z <span class="math inline">\(\subseteqS\)</span></li></ul><p><strong>注意</strong>：对于确定的状态机，其<u>确定性</u>在于 <span class="math inline">\(\delta\)</span>是<strong>单值函数</strong>，且不允许 <span class="math inline">\(\epsilon\)</span> 转移</p></li><li><p>DFA与符号串：令 <span class="math inline">\(\alpha = \alpha_1\alpha_2 \dots \alpha_n\)</span>，其中 <span class="math inline">\(\alpha \in\sum^*\)</span>，反复将<u>当前迭代状态</u>和<u>当前输入字符</u>一起送入<span class="math inline">\(\delta\)</span> <br>若 <span class="math inline">\(\delta(\delta(\dots \delta(s_0, a_1), a_2), \dots,a_{n-1}), a_n) = s_n\)</span>，且 <span class="math inline">\(s_n \inZ\)</span>，则可以写成 <span class="math inline">\(\delta(s_0, \alpha) =s_n\)</span>，即串<span class="math inline">\(\alpha\)</span>被自动机所<strong>接受</strong><br><strong>注意</strong>：若存在一条从<strong>初始状态</strong>到某<strong>终止状态</strong>的路径，且该<strong>路径上</strong><u>各符号可连接成串<span class="math inline">\(\alpha\)</span></u>，则称串<span class="math inline">\(\alpha\)</span>可被自动机<strong>接受</strong></p></li><li><p>DFA接受的语言：L(M) = <span class="math inline">\(\{\alpha |\delta(s_0, \alpha) = s_n, s_n \in Z\}\)</span><br><strong>注意</strong>：由于DFA的 <span class="math inline">\(\delta\)</span>是一个单值函数，因此DFA在同一时刻只能有一个激活状态</p><hr></li><li><p>NFA五元式：M = <span class="math inline">\(\{S, \Sigma \cup\{\epsilon\}, \delta, s_0, Z\}\)</span></p><ul><li>S：表示非确定自动机的<u>有穷</u><strong>状态集合</strong></li><li><span class="math inline">\(\Sigma \cup\{\epsilon\}\)</span>：表示输入符号集合与空串<span class="math inline">\(\epsilon\)</span></li><li><span class="math inline">\(\delta\)</span>：映射函数，定义状态转移函数 <span class="math inline">\(\delta: S \times \Sigma \cup \{\epsilon\}\rightarrow 2^{S}\)</span>，其中 <span class="math inline">\(2^S\)</span> 是 S 的幂集</li><li><span class="math inline">\(s_0\)</span>：初始状态，有 <span class="math inline">\(s_0 \in S\)</span></li><li>Z：终止状态集合，有 Z <span class="math inline">\(\subseteqS\)</span></li></ul><p><strong>注意</strong>：对于不确定的状态机，其<u>不确定性</u>在于<span class="math inline">\(\delta\)</span>是一个<strong>多值函数</strong>（状态对<u>同一输入符号</u>可能有<u>多个后继状态</u>），且<strong>允许特殊输入为<span class="math inline">\(\epsilon\)</span></strong>（可以在<u>无任何输入字符</u>的情况下<u>直接转移</u>）</p><figure style="text-align:center"><p><img src="/2023/09/13/compiler/lexer/NFA.png" width="75%" height="75%"></p><figcaption><p>NFA的状态转移</p></figcaption></figure></li><li><p>NFA接受的语言：L(M') = <span class="math inline">\(\{\alpha |\delta(s_0, \alpha) = S&#39;, S&#39; \cap Z \ne \varnothing\}\)</span><br><strong>注意</strong>：相较于DFA，NFA的同一时刻可以有<strong>多个激活状态</strong>，这些激活状态共同组成了<strong>集合</strong><span class="math inline">\(S&#39;\)</span></p></li></ul><hr><h3 id="五正则表达式">五、正则表达式</h3><ul><li><p>正则表达式的递归定义：设字母表为 <span class="math inline">\(\Sigma\)</span>，有定义在 <span class="math inline">\(\Sigma\)</span>上的<u>正则表达式</u>和<u>正则语言</u>如下</p><ol type="1"><li><span class="math inline">\(\epsilon\)</span> 和 <span class="math inline">\(\varnothing\)</span> 都是 <span class="math inline">\(\Sigma\)</span>上的正则表达式，其表示的正则语言分别为 <span class="math inline">\(\{\epsilon\}\)</span> 和 <span class="math inline">\(\{\}\)</span>（<strong>归纳基础</strong>）</li><li>对任意的 a <span class="math inline">\(\in \Sigma\)</span>，a是<span class="math inline">\(\Sigma\)</span>上的正则表达式，其表示的正则语言为 <span class="math inline">\(\{a\}\)</span></li><li>设 U 和 V均为 <span class="math inline">\(\Sigma\)</span>上的正则表达式，其表示的正则语言分别为 L(U) 和 L(V) <br>则 U | V，UV 和U* 均为 <span class="math inline">\(\Sigma\)</span>上的正则表达式，其对应的正则语言分别为 L(U) <span class="math inline">\(\cup\)</span> L(V)，L(U) L(V) 和 L(U)*</li><li>任何 <span class="math inline">\(\Sigma\)</span>上的正则表达式与正则语言均由前三个步骤产生</li></ol><p><strong>注意</strong>：正则表达式相同 <span class="math inline">\(\Leftrightarrow\)</span>两个正则表达式代表的正则语言相同</p></li><li><p>正则表达式和语言：设<span class="math inline">\(e_1\)</span>和<span class="math inline">\(e_2\)</span>为<strong>任意正则表达式</strong>，其产生的语言分别为<span class="math inline">\(L_1\)</span>和<span class="math inline">\(L_2\)</span>：</p><ol type="1"><li><p><span class="math inline">\(e_1e_2 = \{xy \text{ | } x \in L_1\land y \in L_2\}\)</span></p></li><li><p><span class="math inline">\(e_1 \text{ | } e_2 = \{x \text{ | }x\in L_1 \lor x \in L_2\}\)</span></p></li><li><p><span class="math inline">\(e_1^* = \{x \text{ | } x \in L_1^*\text{, }L_1^* = \bigcup_{i=0}^\infty L_1^i\}\)</span></p></li></ol></li><li><p>正则表达式的运算符：重复 {n} 或 * <span class="math inline">\(\gt\)</span> 连接 <strong><span class="math inline">\(\cdot\)</span></strong> <span class="math inline">\(\gt\)</span> 选择 | ，以及括号 ( )<br><strong>注意</strong>：正则运算符中的<strong>重复</strong>符号也可以用星号* 表示，表示<strong>任意个</strong>符号连接的串</p></li><li><p>正则表达式的性质：设 <span class="math inline">\(e_1\)</span>、<span class="math inline">\(e_2\)</span>、<span class="math inline">\(e_3\)</span> 均为字母表上的正则表达式</p><ul><li>单位正则表达式：即空串 <span class="math inline">\(\epsilon\)</span>，且有 <span class="math inline">\(\epsilon e = e\epsilon = e\)</span></li><li>选择交换律：<span class="math inline">\(e_1 | e_2 = e_2 |e_1\)</span></li><li>结合律：对<u>选择运算</u>和<u>连接运算</u>分别有:<ol type="1"><li>选择运算：<span class="math inline">\(e_1 | (e_2 | e_3) = (e_1|e_2)| e_3\)</span></li><li><span class="math inline">\(e_1(e_2e_3) = (e_1e_2)e_3\)</span></li></ol></li><li>分配律：只有<u>连接</u>对<u>选择</u>的分配律<ol type="1"><li><span class="math inline">\(e_1(e_2|e_3) =e_1e_2|e_1e_3\)</span></li><li><span class="math inline">\((e_1|e_2)e_3 = e_1e_3 |e_2e_3\)</span></li></ol></li><li>其它：r* = (r | <span class="math inline">\(\epsilon\)</span>)*（星号表示可以为<strong>空串</strong>），r**= r*（重复<strong>幂等律</strong>），(r | s)* = (r*s*)*</li></ul></li><li><p>根据正则表达式构造NFA：设 <span class="math inline">\(R_1\)</span> 和 <span class="math inline">\(R_2\)</span> 均为字母表<span class="math inline">\(\Sigma\)</span>上的正则表达式，根据<u>模板</u>构造NFA</p><ul><li><p>基本规则：对于正则表达式的两条<strong>归纳基础</strong>：</p><figure style="text-align:center;"><p><img src="/2023/09/13/compiler/lexer/基本归纳1.png" width="50%" height="50%"></p><figcaption><p>空串规则</p></figcaption></figure><figure style="text-align:center;"><p><img src="/2023/09/13/compiler/lexer/基本归纳2.png" width="50%" height="50%"></p><figcaption><p>字符规则</p></figcaption></figure><hr></li><li><p>归纳规则：对于正则表达式的三种<strong>归纳步骤</strong>：</p><figure style="text-align:center;"><p><img src="/2023/09/13/compiler/lexer/并归纳.png" width="50%" height="50%"></p><figcaption><p>并归纳</p></figcaption></figure><p>合并后，原先的两个有穷自动机<strong>共享</strong>一个初始状态和接受状态</p><hr><figure style="text-align:center;"><p><img src="/2023/09/13/compiler/lexer/连接归纳.png" width="75%" height="75%"></p><figcaption><p>连接归纳</p></figcaption></figure><p>合并后，<span class="math inline">\(R_1\)</span> 的结束状态和 <span class="math inline">\(R_2\)</span>的初始状态<strong>合并</strong>成一个中间状态</p><hr><figure style="text-align:center"><p><img src="/2023/09/13/compiler/lexer/闭包归纳.png" width="75%" height="75%"></p><figcaption><p>闭包归纳</p></figcaption></figure><p>可以直接绕过 <span class="math inline">\(R_1\)</span>到达接收状态，也可以<strong>循环</strong>经过 <span class="math inline">\(R_1\)</span> 任意次再到达接收状态</p></li></ul></li></ul><hr><h3 id="六nfa的确定化">六、NFA的确定化</h3><ul><li><p>状态集的 <span class="math inline">\(\epsilon\)</span>-closure：<span class="math inline">\(\epsilon-\)</span>closure(I)表示从<u>状态合I</u>中的状态出发，经过<strong>任意次<span class="math inline">\(\epsilon\)</span>边</strong>所能到达的状态集合</p></li><li><p><span class="math inline">\(I_a\)</span> 的定义：<span class="math inline">\(I_a = \epsilon-\)</span>closure(J)，其中 J = <span class="math inline">\(\bigcup_{s \in I} \delta(s,a)\)</span>，即从<u>状态集I</u>中的<strong>所有状态</strong>经过<strong>一次a转换</strong>得到的状态集合</p></li><li><p>NFA转化为DFA：设NFA初始状态为<span class="math inline">\(s_0\)</span>，DFA的初始状态<span class="math inline">\(I_0\)</span>为 <span class="math inline">\(\epsilon-\)</span>closure({<span class="math inline">\(s_0\)</span>})，将<span class="math inline">\(I_0\)</span>压入<strong>队尾</strong>：</p><ol type="1"><li>将队首<span class="math inline">\(I\)</span><strong>移入DFA状态集合中</strong>，再将各<span class="math inline">\(I_a = \epsilon-\)</span>closure(<span class="math inline">\(\bigcup_{s \in I}\delta(s, a)\)</span>)压入队尾，其中 a 为输入字符<br><strong>注意</strong>：这一步只将尚不处在DFA状态集合的 <span class="math inline">\(I_a\)</span>压入队尾，<strong>避免重复入队</strong></li><li>循环执行上一步操作，直至没有<strong>新的状态</strong>加入到队列中<br><strong>注意</strong>：扩展新状态是一个<strong>不动点计算</strong>的例子：到达某一时刻后后续迭代只能获得已经算出的状态</li><li>将DFA中<u>包含原NFA中终止状态</u>的状态<strong>全部</strong>标记为终止状态</li><li>对DFA的各状态<strong>重新标记</strong>（DFA的每个状态都是原NFA状态的<strong>集合</strong>）；确定新的转移函数</li></ol><figure style="text-align:center"><p><img src="/2023/09/13/compiler/lexer/NFA转化为DFA.png" width="80%" height="80%"></p><figcaption><p>DFA的每一个状态都是NFA状态集合的子集</p></figcaption></figure><p><strong>注意</strong>：DFA的状态数量最高可膨胀到<span class="math inline">\(2^{\abs{N}}\)</span>，其中<span class="math inline">\(\abs{N}\)</span>表示原NFA的状态数量</p></li></ul><hr><h3 id="七dfa的最小化">七、DFA的最小化</h3><ul><li><p>对于任何一个DFA，存在一个<strong>唯一</strong>的、<strong>状态最少</strong>的<strong>等价</strong>的DFA</p></li><li><p>DFA的极小化：消除多余状态 + 合并等价状态</p><ul><li>多余状态：从DFA的开始状态出发，经过任何输入串也<strong>达不到的状态</strong></li><li>等价状态：状态s和t等价的充要条件，需同时满足<strong>一致性条件</strong>+ <strong>蔓延性条件</strong><ol type="1"><li>一致性条件：s和t同时为接收状态 or 不接受状态</li><li>蔓延性条件：对于<strong>任意</strong>的输入符号，s和t必须转换到<strong>等价的状态</strong>中</li></ol></li></ul></li><li><p>分割法求解极小化DFA：通过<strong>划分DFA状态集合 <span class="math inline">\((s_0, ..., s_N)\)</span></strong> 求解</p><ol type="1"><li>初始化：将DFA中的<strong>接收状态</strong>和<strong>非接受状态</strong>分别划入两个区（<u><strong>一致性</strong></u>）</li><li>反复划分：设已将DFA的各状态划入<u>若干个<strong>互不等价</strong>的分区</u>，每划分一次都重新检查各个分区：</li><li>若存在某个分区，其中有两个状态在<strong>同一输入</strong>下<strong>转移到不同的分区</strong>，则将该分区一分为二（<u><strong>蔓延性</strong></u>）</li><li>反复执行以上第 b c 步直至<strong>分区数量不再增加</strong><strong>注意</strong>：迭代分区也是一个<strong>不动点计算</strong>的例子：到达某一时刻后无法继续拆分分区</li><li>将<u>包含原DFA接收状态</u>的分区全部标记为<strong>接收状态</strong>；将<u>包含原DFA初始状态</u>的分区标记为<strong>初始状态</strong></li><li>对化简后的DFA各分区<strong>重新标记</strong>（每个分区都是原DFA的<strong>状态集合</strong>）；确定新的转移函数</li></ol><figure style="text-align:center"><p><img src="/2023/09/13/compiler/lexer/最小化.png"></p><figcaption><p>总是将DFA的分区一分为二</p></figcaption></figure><p>观察<strong>分区前</strong>的图片，获得分区的规律：对于任意分区，考察<strong><u>所有</u>的输入符号</strong></p><ul><li>无论输入字符是a还是b，状态1和2均转入了<strong><u>当前相同</u>的分区</strong>，说明1和2<u>当前</u>不可再分；状态3和4同理</li><li>对于输入字符a，状态1和2均转至<u>分区2</u>，而状态3和4均转至<u>分区1</u>，说明两者可被输入a分割（蔓延性）</li></ul></li></ul><hr><h3 id="八词法分析程序的最小化">八、词法分析程序的最小化</h3><ul><li>LEX源程序：主要包含辅助定义式、识别规则、用户子程序<ul><li>辅助定义式：利用正则表达式描述各词类</li><li>识别规则：根据识别到的单词，做出相应的行为（如 return Token）</li></ul></li><li>词法分析自动生成器（LEX）：将<u>LEX源程序</u>转化为<u>词法分析程序</u><ul><li>扫描每一条识别规则，<strong>分别构造</strong>对应的NFA</li><li>将各NFA<strong>合并</strong>为一个完整的NFA</li><li>将NFA转化为<strong>DFA</strong></li><li>生成DFA对应的<u>状态转移矩阵</u>和<u>控制执行程序</u></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>compiler</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>『compiler-1』grammar</title>
    <link href="/2023/09/06/compiler/grammar/"/>
    <url>/2023/09/06/compiler/grammar/</url>
    
    <content type="html"><![CDATA[<h2 id="文法和语言">文法和语言</h2><h3 id="一字母表与字符串">一、字母表与字符串</h3><ul><li><p>字母表：符号的<strong>非空有限</strong>集合，记作 <span class="math inline">\(\Sigma\)</span></p></li><li><p>符号：字母表<span class="math inline">\(\Sigma\)</span>中的元素</p></li><li><p>符号串：符号的<strong>有穷</strong>序列，设字母表为<span class="math inline">\(\Sigma\)</span></p><ol type="1"><li><span class="math inline">\(\epsilon\)</span> 是<span class="math inline">\(\Sigma\)</span>上的符号串（归纳基础）</li><li>若 x 是<span class="math inline">\(\Sigma\)</span>上的符号串，且a<span class="math inline">\(\in \Sigma\)</span>，则 ax 或 xa 是<span class="math inline">\(\Sigma\)</span>上的符号串</li><li>y 是<span class="math inline">\(\Sigma\)</span>上的符号串 <span class="math inline">\(\Leftrightarrow\)</span> y 可由规则 a 或规则 b产生</li></ol><hr></li><li><p>符号串的运算：设 x 和 y 是字母表<span class="math inline">\(\Sigma\)</span>上的符号串</p><ul><li>符号串相等：字符串 x = y <span class="math inline">\(\Leftrightarrow\)</span>组成x的每个符号和组成y的每个符号<strong>依次相等</strong></li><li>符号串长度：字符串 x 的长度 |x|为该符号串中<strong>符号的个数</strong></li><li>符号串的连接：符号串 x 和 y的连接 <strong>xy</strong> 也是<span class="math inline">\(\Sigma\)</span>上的符号串<br><strong>注意</strong>：一般 xy <span class="math inline">\(\ne\)</span> yx，但是 <span class="math inline">\(\epsilon x\)</span> = <span class="math inline">\(x\epsilon\)</span></li></ul></li><li><p>符号串集合的乘积运算：设 A 和 B 是<u>符号串集合</u>，则 AB =<span class="math inline">\(\{\text{xy } | \text{ x} \in A, \text{ y}\in B\}\)</span><br><strong>注意</strong>：符号串集合的<strong>乘积</strong>本质上也是符号串的<strong>连接</strong>运算；<span class="math inline">\(\{\epsilon\}\text{A}\)</span> = <span class="math inline">\(\text{A} \{\epsilon\}\)</span>，<span class="math inline">\(\varnothing \text{A}\)</span> = <span class="math inline">\(\text{A}\varnothing\)</span> = <span class="math inline">\(\varnothing\)</span></p></li><li><p>符号集合的幂运算：成绩运算的推广；设 A 是符号串集合，则有：</p><ol type="1"><li><span class="math inline">\(\text{A}^0\)</span> = <span class="math inline">\(\{\epsilon\}\)</span></li><li><span class="math inline">\(\text{A}^1\)</span> = <span class="math inline">\(\text{A}\)</span>, <span class="math inline">\(\text{A}^2\)</span> = <span class="math inline">\(\text{A}\text{A}\)</span>, ...</li><li><span class="math inline">\(\text{A}^n\)</span> = <span class="math inline">\(\text{A}^{n-1} * \text{A}\)</span> = <span class="math inline">\(\text{A} * \text{A}^{n-1}\)</span> (n &gt; 0)</li></ol></li><li><p>符号集合的闭包运算：分为正闭包和闭包，设 A 是符号串集合</p><ul><li>正闭包：<span class="math inline">\(\text{A}^+\)</span> = <span class="math inline">\(\text{A}^1\)</span> <span class="math inline">\(\cup\)</span> <span class="math inline">\(\text{A}^2\)</span> <span class="math inline">\(\cup\)</span> <span class="math inline">\(\text{A}^3\)</span> <span class="math inline">\(\cup\)</span> ... <span class="math inline">\(\cup\)</span> <span class="math inline">\(\text{A}^n\)</span> <span class="math inline">\(\cup\)</span> ... ，<span class="math inline">\(\text{A}^+ = \text{AA}^*\)</span></li><li>闭包（Kleene闭包）：<span class="math inline">\(\text{A}^*\)</span>= <span class="math inline">\(\text{A}^0\)</span> <span class="math inline">\(\cup\)</span> <span class="math inline">\(\text{A}^+\)</span>（即正闭包中多了个<span class="math inline">\(\text{A}_0\)</span>）</li></ul></li></ul><hr><h3 id="二文法和语言的形式定义">二、文法和语言的形式定义</h3><ul><li><p>文法的定义：文法G[Z] = <span class="math inline">\(\{\text{V}_n,\text{V}_t, \text{P}, \text{Z}\)</span><span class="math inline">\(\}\)</span>，其中：</p><ul><li><span class="math inline">\(\text{V}_n\)</span>：<strong>非终结符号</strong>集合</li><li><span class="math inline">\(\text{V}_t\)</span>：<strong>终结符号</strong>集合</li><li><span class="math inline">\(\text{P}\)</span>：<strong>产生式</strong>或<strong>规则</strong>的集合</li><li><span class="math inline">\(\text{Z}\)</span>：开始符号，$ $<span class="math inline">\(\text{V}_n\)</span></li></ul></li><li><p>规则：一个有序对 (U, x)，记作 <span class="math inline">\(\text{U} \rightarrow \text{x}\)</span>，其中 <span class="math inline">\(\text{U} \in \text{V}_n\)</span>, <span class="math inline">\(\text{x} \in \text{V}^*\)</span>，<strong>| U | =1，| x | <span class="math inline">\(\ge\)</span> 0</strong><br><strong>注意</strong>：<span class="math inline">\(\text{V}\)</span>= <span class="math inline">\(\text{V}_n\)</span> <span class="math inline">\(\cup\)</span> <span class="math inline">\(\text{V}_t\)</span>；规则的左侧必须是非终结符，右侧是终结符或非终结符组成的串</p></li><li><p>文法的 BNF 表示：</p><ul><li>使用 ::= 表示“定义为”，使用 &lt;&gt; 把“非终结符号”括起来，</li><li>将拥有<strong>相同左部</strong>的产生式体用“或运算符|”连接在一起</li></ul><hr></li><li><p>推导的定义：设 v = xUy，w = xuy，其中 x、y <span class="math inline">\(\in\)</span> <span class="math inline">\(\text{V}^*\)</span>，U <span class="math inline">\(\in\)</span> <span class="math inline">\(\text{V}_n\)</span>，u <span class="math inline">\(\in\)</span> <span class="math inline">\(\text{V}^*\)</span> 若 U <span class="math inline">\(\rightarrow\)</span> u，则 v <span class="math inline">\(\overset{G}{\Rightarrow}\)</span>w，即将推导式的<u>左侧非终结符</u>替换为<u>右侧符号串</u></p><ul><li>最左推导：每次优先替换掉符号串中<strong>最左侧</strong>的非终结符</li><li>最右推导：每次优先替换掉符号串中<strong>最右侧</strong>的非终结符<br><strong>注意</strong>：最右推导又叫<strong>规范推导</strong>，用<u>带斜划线</u>的右箭头表示</li></ul></li><li><p>多步推导：设文法<span class="math inline">\(\text{G}\)</span>，<span class="math inline">\(\text{u}_0\)</span>，<span class="math inline">\(\text{u}_1\)</span>，...，<span class="math inline">\(\text{u}_n\)</span> <span class="math inline">\(\in\)</span> <span class="math inline">\(\text{V}^+\)</span></p><ul><li>若 <span class="math inline">\(\text{v} = \text{u}_0\underset{G}{\Rightarrow}... \underset{G}{\Rightarrow} \text{u}_n =\text{w}\)</span>，则记<span class="math inline">\(\text{v}\underset{G}{\overset{+}{\Rightarrow}}w\)</span>（间接推导，至少1步推导）</li><li>若 <span class="math inline">\(\text{v} \overset{+}{\Rightarrow}\text{w}\)</span> 或 <span class="math inline">\(\text{v} =\text{w}\)</span>，则 <span class="math inline">\(\text{v}\underset{G}{\overset{+}{\Rightarrow}}\text{w}\)</span>（任意步推导，可以是0步）</li></ul><p><strong>注意</strong>：当符号串中没有非终结符号时，推导就必须终止，因为只有规则左侧才有非终结符</p><hr></li><li><p>语言的定义：设文法为 G[Z]</p><ul><li>句型：设 <span class="math inline">\(\text{x}\)</span> 是句型，则<span class="math inline">\(\text{Z} \overset{*}{\Rightarrow}\text{x}\)</span>，且 <span class="math inline">\(\text{x} \in\text{V}^*\)</span>（即<strong>推导过程中</strong>的任意结果）</li><li>句子：设 <span class="math inline">\(\text{x}\)</span> 是句子，则<span class="math inline">\(\text{Z} \overset{+}{\Rightarrow}\text{x}\)</span>，且 <span class="math inline">\(\text{x} \in\text{V}_t^*\)</span>（即仅由<strong>终结符</strong>构成的符号串）</li><li>语言：<span class="math inline">\(\text{L(G[Z])}\)</span> = <span class="math inline">\(\{\text{x } | \text{ x} \in \text{V}_t^*, \text{Z} \overset{+}{\Rightarrow}\text{x}\}\)</span>，即文法中<strong>句子的集合</strong></li></ul><p><strong>注意</strong>：已知文法G，可以确定唯一的语言L；已知语言L，可能构造出多种文法<span class="math inline">\(\text{G}_i\)</span></p></li></ul><hr><h3 id="三文法构造">三、文法构造</h3><ul><li><p>等价文法：设 G 和 G' 是两个不同的文法，若<strong>L(G) =L(G')</strong>，则称 G 和 G' 是等价文法</p></li><li><p>递归规则：即规则右部有与左部<u>相同的<strong>非终结符号</strong></u>；设<span class="math inline">\(\text{U} \rightarrow \text{xUy}\)</span></p><ul><li>若 x = <span class="math inline">\(\epsilon\)</span>，即 <span class="math inline">\(\text{U} \rightarrow\text{Uy}\)</span>，则称<strong>左递归</strong></li><li>若 y = <span class="math inline">\(\epsilon\)</span>，即 <span class="math inline">\(\text{U} \rightarrow\text{xU}\)</span>，则称<strong>右递归</strong></li><li>若 x, y <span class="math inline">\(\ne\epsilon\)</span>，则称<strong>自嵌入递归</strong></li></ul></li><li><p>递归文法：设文法G中<strong><u>存在</u>非终结符</strong> <span class="math inline">\(\text{U} \in \text{V}_n\)</span>：</p><ul><li>若 <span class="math inline">\(\text{U} \overset{+}{\Rightarrow}\dots \text{U} \dots\)</span>，则称G为递归文法</li><li>若 <span class="math inline">\(\text{U} \overset{+}{\Rightarrow}\text{U}\dots\)</span>，则称G为左递归文法</li><li>若 <span class="math inline">\(\text{U} \overset{+}{\Rightarrow}\dots \text{U}\)</span>，则称G为右递归文法</li></ul><p><strong>注意</strong>：递归文法可以通过<strong>有穷条规则</strong>，定义无穷语言；但<u>左递归文法</u><strong>不能使用自顶向下</strong>的方法语法分析</p></li><li><p>如何构造一个文法：先从<strong>最简单的句子</strong>出发做扩展</p><ul><li>重复生成：从每一步扩展的句子中找出<strong>上一步重复出现的符号串</strong>，构造递归定义（如<span class="math inline">\(\text{A} \rightarrow \text{a |Aa}\)</span>）</li><li>对称生成：若某一步扩展得到的句子是回文的，则在其<strong>左右两侧增加相同的符号</strong>得到的句子也是回文的</li></ul></li></ul><hr><h3 id="四短语和句柄">四、短语和句柄</h3><ul><li><p>短语和简单短语：设文法G[Z]，w = xuy <span class="math inline">\(\in\)</span> <span class="math inline">\(\text{V}^+\)</span>是该文法的<strong>句型</strong>，<span class="math inline">\(\text{x, y} \in \text{V*}\)</span></p><ul><li>短语：若 <span class="math inline">\(\text{Z}\overset{*}{\Rightarrow} \text{xUy}\)</span>，且 <span class="math inline">\(\text{U} \overset{+}{\Rightarrow}\text{u}\)</span>，则u是相对于U的<u>句型w</u>的短语（任何句型都是相对于Z的短语）</li><li>简单短语：若 <span class="math inline">\(\text{Z}\overset{*}{\Rightarrow} \text{xUy}\)</span>，且 <span class="math inline">\(\text{U} \Rightarrow\text{u}\)</span>，则u是相对于U的<u>句型w</u>的简单短语（必须存在一步推导）</li></ul><p><strong>注意</strong>：<strong>“短语一定是某个句型的部分或全部”</strong>，且是可由某个<strong>非终结符</strong>推导得到的符号串</p></li><li><p>句柄：任意句型的<strong>位于最左边的<u>简单短语</u></strong>称为该句型的句柄；一个句型只能有一个句柄</p><ul><li>如何查找某句型的句柄？先找出该句型所有的<strong>简单短语</strong>，再选出<strong>最左边</strong>的</li></ul></li></ul><hr><h3 id="五语法树">五、语法树</h3><ul><li><p>语法树（推导树）：句子 or 句型的<strong>图表示</strong></p><ul><li>结点：表示符号；其中<strong>根节点</strong>是开始符号、<strong>中间节点</strong>是非终结符、<strong>叶节点</strong>是终结符或非终结符</li><li>有向边：表示结点之间的<strong>推导派生</strong>关系</li></ul></li><li><p>语法树的生成（自顶向下）：设文法为G[Z]，句型为w</p><ol type="1"><li>建立推导序列，<span class="math inline">\(\text{Z}\overset{*}{\Rightarrow} \text{w}\)</span></li><li>根据序列建立语法树：以Z为根节点，每步推导生成一个<strong>枝</strong><br>“枝”是一组<u><strong>线</strong></u>连同<strong>线下面的<u>若干结点</u></strong>，各结点取代该分支名称的符号串</li></ol><p><strong>注意</strong>：无论使用哪种推导方式，建立的语法树<strong>形状都是相同</strong>的（无二义性），但生长次序不同</p></li><li><p>子树与短语的关系：短语必由某个祖先节点推导；简单短语必由某个祖先节点直接推导<br><strong>注意</strong>：这个定理说明可通过<u><strong>语法树</strong></u>的方式求出任意句型的短语、简单短语以及句柄</p></li><li><p>规约：<strong>自下而上</strong>地剪掉子树的末端节点（即短语），每剪一次对应一次规约</p></li><li><p>规范规约与规范推导：互为<strong>逆过程</strong></p><ul><li>规范规约：每次剪掉当前句型中的<strong>句柄</strong></li><li>规范推导：每次优先替换当前句型中<strong>最右侧</strong>的非终结符号</li><li>规范句型：通过<u>规范规约</u>或<u>规范推导</u>得到的句型</li></ul><hr></li><li><p>二义性文法：对于文法中的某一句子（或句型），存在两棵<strong>不同的语法树</strong>，则是二义性文法</p><ul><li>若文法的一个句子存在两个<strong>不同的规范推导</strong>，则该文法是二义性的（会产生不同的语法树）</li><li>若文法中某些规范句型的<strong>句柄不唯一</strong>，则该文法是二义性的（不同语法树的句柄不一定相同）</li></ul><p><strong>注意</strong>：<u>无二义性文法</u>的句子可以有不同的推导过程，但只有<strong>一棵语法树</strong>；文法的二义性不可判定</p></li><li><p>有害规则：文法中存在形如 <span class="math inline">\(\text{U}\rightarrow \text{U}\)</span>的规则，会在推导时产生<strong>各种高度的语法树</strong>（二义性）</p></li><li><p>多余规则：包括不可达符号 + 不活动符号</p><ul><li><p>不可达：<strong>始终用不到的规则</strong>，即该规则左侧的非终结符不出现在任何句型中（到不了）</p></li><li><p>不活动：含有<strong>推不出任何句子</strong>的非终结符（用不了）</p><hr></li><li><p>被压缩的文法：不含有害规则和多余规则的文法</p></li></ul><hr></li><li><p>形式语言：用<u>文法</u>和<u>自动机</u>描述的没有语义的语言</p></li><li><p>文法定义：即文法的四元组，由乔姆斯基定义；语言即文法中<strong>所有句子</strong>组成的集合</p></li><li><p>文法和语言的分类：3型 <span class="math inline">\(\subseteq\)</span> 2型 <span class="math inline">\(\subseteq\)</span> 1型 <span class="math inline">\(\subseteq\)</span> 0型</p><ul><li>0型：<span class="math inline">\(\text{P: } \text{u} \rightarrow\text{v}\)</span>，其中<span class="math inline">\(\text{u} \in\text{V}^+\)</span>（<strong>| u | <span class="math inline">\(\ge\)</span> 1</strong>），<span class="math inline">\(\text{v} \in \text{V}^*\)</span><br>0型文法又称<strong>短语</strong>结构文法，其规则的左右两侧都可以是<strong>符号串</strong><br>0型语言可由图灵机接受</li><li>1型：<span class="math inline">\(\text{P: } \text{xUy} \rightarrow\text{xuy}\)</span>，其中<span class="math inline">\(\text{U} \in\text{V}_n\)</span>，<span class="math inline">\(\text{x, y, u} \in\text{V}^*\)</span><br>1型文法是<strong>上下文有关</strong>的，即只有在<strong>前x后y的上下文</strong>中才能把U改写为u<br>1型文法可被线性界限自动机接受</li><li>2型：<span class="math inline">\(\text{P: U} \rightarrow\text{u}\)</span>，其中<span class="math inline">\(\text{U} \in\text{V}_n\)</span>，<span class="math inline">\(\text{u} \in\text{V}^*\)</span>，即将U改写为u时<strong>不必考虑上下文</strong><br>2型文法与<strong>BNF</strong>表示等价；1型文法中 <span class="math inline">\(\text{x = y} = \epsilon\)</span> 即为 2型文法<br>2型文法可由下推自动机接受（总控程序 + 分析表 + 读写头 +<strong>栈</strong>，可以保存状态）</li><li>3型：<span class="math inline">\(\text{P: U} \rightarrow \text{t |}\text{Wt}\)</span> （左线性）或 <span class="math inline">\(\text{P: U}\rightarrow \text{t | tW}\)</span>（右线性），其中 <span class="math inline">\(\text{U, W} \in \text{V}_n\)</span>，<span class="math inline">\(\text{t} \in \text{V}_t\)</span><br>3型文法又称<strong>正则文法</strong>，即为2型文法的进一步限制<br>3型语言可由<strong>有穷自动机</strong>接受（总控程序 + 分析表 +读写头，无法保存状态）</li></ul><p><strong>注意</strong>：0型文法可以产生 <span class="math inline">\(\text{L}_0\)</span> ~ <span class="math inline">\(\text{L}_3\)</span>；2型文法只能产生<span class="math inline">\(\text{L}_2\)</span>；3型文法只能产生<span class="math inline">\(\text{L}_3\)</span><br>1型文法比0型文法指定了上下文约束；2型文法要求上下文必须是 <span class="math inline">\(\epsilon\)</span>；3型文法约束了产生式必须是线性的</p></li></ul><hr><h3 id="六句子的分析">六、句子的分析</h3><ul><li><p>自顶向下分析：从待识别的符号串 <span class="math inline">\(\text{s} \in \text{V}_t^*\)</span>开始，根据规则建立<strong>推导序列</strong>，使得<span class="math inline">\(\text{Z} \overset{+}{\Rightarrow}\text{s}\)</span>，则符号串s得到了识别 <br>s是文法G的合法句子 <span class="math inline">\(\Leftrightarrow\)</span>语法树的<strong>末端节点</strong>从左到右连接起来构成s<br><strong>注意</strong>：推导句子前应先找出文法中<strong>唯一出现的终结符号</strong></p></li><li><p>自底向上分析：从符号串 <span class="math inline">\(\text{s} \in\text{V}_t^*\)</span> 开始将 s规约为开始符Z；每次规约总会规约<u>当前句型</u>的<strong>句柄</strong></p><p><strong>注意</strong>：自顶向下一般采用最左推导；自底向上一般找当前句型的句柄</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>compiler</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>『system programming-1』C system programming</title>
    <link href="/2023/09/04/system_programming/C-system-programming/"/>
    <url>/2023/09/04/system_programming/C-system-programming/</url>
    
    <content type="html"><![CDATA[<h2 id="c语言系统级编程">C语言系统级编程</h2><hr><h3 id="一内存的基本概念">一、内存的基本概念</h3><ul><li>字节：内存的基本单位，由8个0/1比特位组成</li><li>机器位宽：表示内存中byte的编号，如32位机表示共可以<strong>访问<span class="math inline">\(2^{32}\)</span>个字节</strong>（0 ~ <span class="math inline">\(2^{32} - 1\)</span>）</li></ul><hr><h3 id="二非数组与数组变量的声明">二、非数组与数组变量的声明</h3><ul><li><p>内存的相关操作：分配内存、内存赋值、读取内存、释放内存</p></li><li><p>分配内存：C语言中主要有两种方式，即“变量声明”（无需手动free）与“使用malloc”（需要手动free）</p></li><li><p>变量要素：变量类型（约定了<u>内存类型与大小</u>） +变量名称（标记<u>内存的别名</u>）</p><ul><li><p>非数组变量类型：包括int、char、结构体等</p></li><li><p>数组变量类型：由多个<strong>相同变量类型</strong>（可以是非数组or 数组类型）组成的<u><strong>一维</strong></u>构造类型<br>如int[2]表示由2个int类型构成的数组；double[2][3][4]表示由2个double[3][4]类型构成的数组</p><p><strong>注意</strong>：可以使用 <strong>sizeof</strong>关键字获取某个变量类型的占用内存大小</p></li><li><p>指针变量类型：实质上是一种<strong>非数组变量类型</strong>，任意一种类型都有指向其的指针类型：</p><ol type="1"><li>指向<u>非数组变量类型</u>变量的指针：Var_T <span class="math inline">\(\rightarrow\)</span> Var_T*</li><li>指向<u>数组变量类型</u>的指针：Var_T[10] <span class="math inline">\(\rightarrow\)</span> Var_T(*)[10]，注意加<strong>括号</strong><br><strong>注意</strong>：指针类型也是一种普通的变量类型，要将Var_T*看作一个<strong>整体</strong>PTYPE <br>如int* [2]对应的指针变量为int*(*)[2]，其中int* 可看作一个整体PINT</li><li>指向<u>指针变量类型</u>的指针：Var_T* <span class="math inline">\(\rightarrow\)</span> Var_T**，Var_T(*) [10] <span class="math inline">\(\rightarrow\)</span> Var_T(**) [10]</li></ol><p><strong>注意</strong>：使用sizeof计算任意指针的大小都是4字节，这与机器位宽有关</p></li></ul></li></ul><hr><h3 id="三内存的变量类型和表示值类型">三、<strong>内存</strong>的变量类型和表示值类型</h3><ul><li>值（Value）：包括值本身 + 表示值类型 &lt;V, V_T&gt;<br><strong>注意</strong>：C语言中<strong>任何表达式都是有值的</strong>，如10对应值&lt;10, int&gt;，(10 &gt; 20) 对应值&lt;0, int&gt;</li><li>变量类型（Var_T）与表示值（V_T）类型：<ul><li>变量类型：包括<strong>非数组</strong>和<strong>数组</strong>变量类型，是系统分配内存的依据（物理视角）</li><li>表示值类型：从系统<strong>外部观察</strong>内存得到的值的类型，<strong>由变量类型Var_T决定</strong>：<ol type="1"><li>Var_T为非数组类型：V_T = Var_T，V表示通过 Var_T<strong>解释内存</strong>比特串代表的值</li><li>Var_T为数组类型：V_T表示<u>数组元素</u>对应的<strong>指针变量类型</strong>，V表示数组在内存中<strong>首字节的编号</strong>如变量类型为char [2][3][4] 对应的表示值类型为 char(*)[3][4]</li></ol></li></ul></li><li>“内存六元组”模型：M = {Address, Var_T, Name, Size, Value, V_T }<ul><li>Address：该段内存的首字节编号，由系统分配，一旦确定直至回收都无法更改</li><li>Var_T：分配内存的<strong>变量类型</strong>，在<u>变量声明语句</u>中确定</li><li>Name：分配内存的<strong>变量名称</strong>，在<u>变量声明语句</u>中确定</li><li>Size：该段内存的<strong>大小</strong>（字节数量）</li><li>Value：该段内存的<strong>表示值</strong>，取值由<u>Var_T</u>确定<br><strong>注意</strong>：对于结构体或联合体变量，由于其内存块可能包含多个成员变量，故无法获取内存块的具体值</li><li>V_T：分配内存的<strong>表示值类型</strong>，类型由<u>Var_T</u>确定</li></ul></li><li>malloc()：分配<strong>指定大小</strong>的连续内存，其变量类型与表示值类型均不确定</li></ul><hr><h3 id="四声明与赋值">四、声明与赋值</h3><ul><li><p>变量声明：利用声明语句，在内存中某处（<strong>Address</strong>）分配<strong>特定字节的Size</strong>，并为其标记<strong>Name</strong>，设置<strong>两个类型T</strong><br><strong>注意</strong>：仅声明不赋值，内存中的表示值<strong>Value</strong>是随机的（undefined）</p></li><li><p>变量赋值：对一块内存进行赋值</p><ul><li>赋值表达式：包括左值（用于定位待赋值内存块）与右值（用于为内存块赋值）<ul><li>左值：通过<strong>变量名称或*运算符</strong>（V_T为指针类型）定位特定的内存</li><li>右值：一个<strong>有效表达式</strong>，可求出对应的值</li></ul></li><li>赋值流程：<ol type="1"><li>根据左值定位待赋值内存</li><li>计算右值表达式的值&lt;V, V_T&gt;</li><li>检查<strong>内存表示值类型</strong>与<strong>右值表示值类型</strong>是否一致，若不一致则warning/error<br>如 <code>int a; a = "123";</code> 会报错</li><li>将右值V按V_T类型<strong>转化为比特串</strong>放入待赋值内存中</li></ol></li></ul><p><strong>注意</strong>：无法直接向数组类型变量赋值（<strong>数组类型变量</strong>的<u>表示值Value</u>总是等于其<u>首地址Address</u>，改不了）</p></li></ul><hr><h3 id="五观察内存的三种视角">五、观察内存的三种视角</h3><ul><li><p>&amp;：对于变量类型为Var_T的变量a，表达式&amp;a的返回值为&lt;Address,Var_T*&gt;；故有赋值语句<code>int* p = &amp;a;</code></p></li><li><p>sizeof：对于内存大小为Size的变量a，表达式sizeof(a)的返回值为&lt;Size,size_t&gt;；故有赋值语句<code>size_t n = sizeof(a);</code><br><strong>注意</strong>：size_t是C语言中表示<strong>内存大小</strong>的类型</p></li><li><p>变量名：对于变量类型为Var_T，表示值为V的变量a，表达式a的返回值为&lt;V,V_T&gt;，即<strong>直接取其表示值</strong>；故有赋值语句<code>int b = a;</code></p><p><strong>注意</strong>：与变量有关的三种表达式依次代表了<strong>内存</strong>地址、<strong>内存</strong>大小以及<strong>内存</strong>表示值</p><figure style="text-align:center;"><p><img src="/2023/09/04/system_programming/C-system-programming/内存六元组.png" width="50%" height="50%"></p><figcaption><p>内存六元组模型图示</p></figcaption></figure></li></ul><hr><h3 id="六左值与右值">六、左值与右值</h3><ul><li>表达式：一般由变量、常量、操作符构成</li><li>左值：能够定位内存的表达式<br><strong>注意</strong>：等号左侧识别出的内存符号，一旦<u>与任何<strong>操作符</strong>结合</u>，就会变成对表达式的<strong>取值操作</strong>，即不再能够定位一块内存，<strong>会报错</strong></li><li>右值：一个表达式的返回值&lt;V, V_T&gt;</li></ul><hr><h3 id="七sizeof-操作符">七、sizeof 操作符</h3><ul><li>sizeof(Var_T)：计算变量类型Vat_T的空间大小</li><li>sizeof(Name)：计算变量Name占用的空间大小</li><li>sizeof(exp)：计算表达式exp<strong>返回值的类型</strong>的大小<br><strong>注意</strong>：对于表达式exp的情形，并不需要先计算exp的返回值&lt;V,V_T&gt;再求出sizeof(V_T)<br>这是因为sizeof是<strong>编译时关键字</strong>，exp的返回值类型早在<strong>编译时</strong>（而非运行时）就已经确定了</li><li>有关字面量的问题：由于'a'、'b'等字符在C语言中被视为<strong>Integer</strong>Character Constant，故sizeof('a') = 4 != 1<br><strong>注意</strong>：在C++中 sizeof('a') =1，故需要在移植C/C++程序时考虑这个问题</li></ul><hr><h3 id="八-操作符">八、 * 操作符</h3><ul><li><p>定位内存的两种方式：变量名称 or *操作符</p></li><li><p>*操作符：用于<strong>定位</strong>指针变量指向的<strong>内存</strong>，定位流程如下：设<code>int* p; *p = 10;</code></p><ol type="1"><li><p>p不与&amp;和sizeof结合，故定位p的内存并仅<strong>取其值</strong>（即某块内存的始址，表示值类型为指针）</p></li><li><p>p与*操作符结合，定位指针变量p指向的内存</p></li><li><p><span class="math display">\[\text{对变量内存 (*p) 的操作}\begin{cases}\text{左值操作：对内存赋值，注意会检查类型是否匹配} \\\text{右值操作：包括取地址\&amp;、求大小sizeof、或与其它操作符结合}\end{cases}\]</span></p></li></ol><p><strong>注意</strong>：*操作符与指针变量结合<strong>获得该指针变量指向的类型</strong>；若不与指针变量结合就会报错</p></li></ul><hr><h3 id="九指针加减法">九、指针加减法</h3><ul><li><p>对任意<strong>表达式exp</strong>，若exp的返回值类型是一个<strong>有效的指针类型</strong>，则有：<span class="math display">\[*(\text{exp+n}) \Leftrightarrow \text{exp[n]}\]</span>故任何一个返回值为<u>指针类型</u>的表达式，都蕴含着位于对应内存的<strong>数组</strong>（<u>大小未知</u>），其元素类型为指针变量类型指向的类型（ReferenceType）</p><p><br>如 (p + 1)[2] <span class="math inline">\(\Leftrightarrow\)</span> *(p+1<strong>+2</strong>)<span class="math inline">\(\Leftrightarrow\)</span> *(p + 3) <span class="math inline">\(\Leftrightarrow\)</span> p[3]</p><hr></li><li><p>指针加常数：设 p : &lt;Value, Value_T &gt;，则 p+n : &lt;Value +n <span class="math inline">\(\times\)</span> sizeof(*p), Value_T&gt;</p></li><li><p>指针相减：设 p : &lt;Value1, int*&gt;，q : &lt;Value2,int*&gt;，则 p-q : &lt; (Value1 - Value2) / sizeof(*p),<strong>ptrdiff_t</strong> &gt;<br><strong>注意</strong>：相减的指针类型必须<strong>相同</strong>；相减得到的表示值是<strong>两个地址之间的变量个数</strong></p></li></ul><hr><h3 id="十数组的内存访问">十、数组的内存访问</h3><ul><li>设数组变量g为int g[2][3]，则有：<ul><li>&amp;g：&lt;address of g, int(*)[2][3]&gt;</li><li>sizeof(g)：&lt;size of g, size_t&gt;</li><li>g + 1：&lt;(<strong>address of g</strong>) + 1 <span class="math inline">\(\times\)</span> sizeof(*g),int(*)[3]&gt;，注意V_T为数组元素的<strong>指针类型</strong>保持不变</li></ul></li><li>数组名：是一个<strong>标识符</strong>，一个<strong>左值表达式</strong>（可以定位一块内存）</li></ul><hr><h3 id="十一参数传递">十一、参数传递</h3><ul><li>实参与形参：先获取实参表达式exp的<strong>返回值</strong>，再用该返回值初始化函数<strong>形参名对应的内存中</strong>（PassBy Value）<br><strong>注意</strong>：<u>实参表示值类型</u>与<u>形参类型</u>必须一致</li><li>非数组变量传参：将实参返回值写入形参的内存块中</li><li>数组变量传参：可以省略形参的第一维大小，即省略数组大小信息<br><strong>注意</strong>：由于函数<u>形参</u>与<u>实参</u>的表示值类型都是<strong>元素的指针变量类型</strong>，故数组的大小信息可以被省略</li></ul><hr><h3 id="十二malloc">十二、malloc</h3><ul><li><p>使用malloc分配堆内存的特点：</p><ol type="1"><li>内存<strong>没有名称Name</strong></li><li>malloc返回值类型为void*，指向分配内存的首字节，需要先强转类型如<code>Var_T* p = (Var_T*)malloc(sizeof(Var_T)*N);</code></li><li>malloc分配的内存空间未初始化</li><li>需要用 <strong>free(p)</strong>释放内存，有多少次malloc就有多少次free（避免memory leak）</li></ol><p><strong>注意</strong>：一般使用 malloc(sizeof(Var_T) * N)分配内存空间，表示申请了一个 Var_T[N]类型的空间，其表示值类型为Var_T*</p></li></ul><hr><h3 id="十三typedef">十三、typedef</h3><ul><li>为非数组类型提供别名：<code>typedef char INT1;</code>，即将char重定义为INT1类型</li><li>为数组类型提供别名：<code>typedef int AINT[2];</code>，即将int[2]重定义为AINT类型</li></ul><hr><h3 id="十四const限定符">十四、const限定符</h3><ul><li><p>限定<u>非数组</u>变量类型：<code>Var_T const a;</code>，Var_Tconst是一个<u><strong>整体</strong></u>，表示Var_T指向的内存是<strong>只读的</strong><br><strong>注意</strong>：由const修饰的变量类型，其表示值类型为对应的<strong>非限定变量类型</strong>；如int* const 的表示值类型为 int*</p></li><li><p>限定<u>数组</u>变量类型：Var_T const[2][3]，其对应的表示值类型为Var_Tconst(*)[3]，表示其元素类型是<strong>只读的</strong><br><strong>注意</strong>：此时应把 Var_T const看作一个<u><strong>整体</strong></u></p><hr></li><li><p>Var_T const对应的<strong>指针</strong>变量类型：Var_Tconst*，其表示值类型也是Var_T const*<br><strong>注意</strong>：只有最后一个“干净”的const修饰只读变量，如：<br>由 Var_T const*定义的变量是可以修改的，但指向的内存是<strong>只读的</strong>（其V_T为Var_Tconst*，解引用后为Var_T const） <br>由 Var_T const* const定义的变量是不可被修改的（const修饰），其指向的内存也是<strong>只读的</strong>（其V_T为Var_Tconst*，解引用后为Var_T const）</p></li><li><p>Var_T const VS. constVar_T：推荐使用前者，避免解读歧义；C语言中对const的位置无明确语义规范<br><strong>注意</strong>：指针变量 const Var_T*会存在解读歧义：不确定*是与整个 const Var_T 结合还是只跟 Var_T结合</p></li></ul><hr><h3 id="十五字符串">十五、字符串</h3><ul><li>字符数组：变量类型为char[N]，表示值类型为char*，与其它数组变量类型类似</li><li>字符串初始化：使用<strong>双引号括起来</strong>的字符串常量，其末尾包含一个隐藏的'\0'<br><strong>注意</strong>：字符串"hello"被放置在<strong>静态区</strong>，其元素无法被修改，如<code>"hello"[0] = 'e'</code>会运行崩溃</li><li>String Literal <strong>VS.</strong>String：前者字符串内部可以包含任何字符（包括'\0'），后者只是在最后有'\0'<br><strong>注意</strong>：两者使用 sizeof 得到的大小是相同的，但使用strlen 得到的长度是不同的</li><li>访问字符串：字符数组<strong>本身</strong>可以定位一块内存，如&amp;"hello"，sizeof("hello")，"hello"[0]等</li></ul><hr><h3 id="十六左值与表达式">十六、左值与表达式</h3><ul><li><p>表达式：C语言中由一系列<strong>操作符</strong>和<strong>操作对象</strong>组成的序列</p></li><li><p>左值（<strong>lvalue</strong>）：一种可以<u>定位一个<strong>对象</strong></u>的<strong>表达式</strong><br><strong>注意</strong>：C语言中Type分为Object Type和Function Type</p><ol type="1"><li>变量标识符：int <strong>a</strong></li><li>字符串："hello"</li><li>解引用 *exp：*(p + 1)</li><li>数组取值 exp1[exp2]：e[1] <strong>注意</strong>：E1[E2] <span class="math inline">\(\Leftrightarrow\)</span> *(E1 +E2)，要求其中一个表达式返回<strong>指针类型</strong>、另一个E返回<strong>整数类型</strong></li><li>复合字面量 (type-name){ initializer }：如(int){1}，(int[3]) {1, 2,3}</li><li>成员变量引用：h.name，p-&gt;name</li></ol></li><li><p>可被放在等号左边的左值（<strong>modifiablelvalue</strong>）：需同时满足以下条件：</p><ul><li>非数组变量类型：表示值总是等于内存首地址，无法被修改</li><li>不是不完全类型：如extern int<strong>a</strong>[]，其中不完全类型是指除函数类型外<strong>大小无法确定</strong>的类型</li><li>不能被 const 修饰；对于结构体类型变量，其各成员变量不能被 const修饰</li></ul><p><strong>注意</strong>：若对非modifiablelvalue赋值，则会报编译错误</p></li><li><p>右值（rvalue）：即表达式的值&lt;V,V_T&gt;，表达式之间通过<strong>表示值</strong>计算返回值</p></li></ul><hr><h3 id="十七函数指针">十七、函数指针</h3><ul><li>函数类型（FunctionType）：规定了<strong>函数返回值类型</strong>与<strong>参数数量及类型</strong>，如int(char,int)<br><strong>注意</strong>：区别于对象类型，函数类型不是lvalue，故函数类型变量不能被赋值</li><li>函数类型对应的<strong>指针类型</strong>：如int(*)(char, int)</li><li>函数类型六元组：仿照<u>对象类型六元组</u>提出<ol type="1"><li>Address：函数入口的地址</li><li>Var_T：函数类型，如int(int, int)</li><li>Name：函数标识符</li><li>Size ：N/A，函数类型无大小，不能与 sizeof 结合</li><li>V：表示值与Address的值相同</li><li>V_T：表示值类型是<strong>函数类型对应的指针类型</strong>，如int(*)(int,int)</li></ol></li><li>函数调用：函数标识符 + 参数列表，其中函数标识符即为函数名称<br><strong>注意</strong>：函数标识符func属于基础<strong>表达式</strong>，其返回值为&lt;函数<strong>入口地址</strong>,函数对应的<strong>指针类型</strong>&gt;</li><li>&amp;func与*pfunc：<ul><li>&amp;func：由&amp;操作符的性质，&amp;func返回<strong>函数指针变量</strong>，其表示值即为address由此可见<u>&amp;func</u>与<u>func</u>表达式的返回值是完全相同的</li><li>*pfunc：由解引用操作的性质，*pfunc返回<strong>函数类型变量</strong>，其表示值类型为函数指针由此可见<u>*pfunc</u>与<u>pfunc</u>表达式的返回值是完全相同的</li></ul></li></ul><hr><h3 id="十八compound-literal">十八、Compound Literal</h3><ul><li><p>复合字面量：<strong>匿名</strong>对象类型，其定义为 (type-name){initializer-list }</p><ul><li>type-name：该对象的<strong>变量类型</strong></li><li>initializer-list：对该对象进行<strong>初始化</strong>的列表</li></ul><p><strong>注意</strong>：符合字面量即<strong>匿名的变量</strong>，除了不含Name外与非数组/数组变量类型类似</p></li><li><p>赋值问题：复合字面量本身是合法的<strong>左值</strong>，但其是否为modifiable lvalue 取决于存储位置：</p><ul><li>位于函数内部：生命周期为 automatic storage duration，是 modifiablelvalue</li><li>作为全局变量：生命周期为 static storage duration，不是 modifiablelvalue，<u><strong>只能初始化</strong></u></li></ul><p><strong>注意</strong>：复合字面量是合法的左值，可以<u>定位一块内存</u>，并能够与&amp;、sizeof 结合</p></li><li><p>空间分配规则：<u>同一作用域内</u>，各 Compound Literal在内存中<strong>仅保持一份</strong><br><strong>注意</strong>：由上述特点可知，在循环中反复声明<strong>同值</strong>复合字面量，实际获得的是<strong>同一内存块中的数据</strong></p></li><li><p>使用<strong>同一个</strong>复合字面量：使用对应的<strong>指针类型存储</strong>变量地址，通过指针解引用操作访问</p></li></ul><hr><h3 id="十九type">十九、Type</h3><ul><li><p>ObjectType：定位一个<strong>内存块</strong>，可通过变量类型解析出一个值</p><ul><li><p>Integer Related：主要包括以下类型：</p><ol type="1"><li>Signed Integer Type：标准有符号整型（signed）+ 扩展有符号整型</li><li>Unsigned Integer Type：布尔型（_Bool）+ 对应无符号整型（unsigned）+扩展无符号类型</li></ol></li><li><p>Floating Type：主要包括以下类型：</p><ol type="1"><li>Real Floating Type：标准浮点类型（float、double）+高精度浮点类型（_Decimal32等）</li><li>Complex Type：复数浮点类型（float_complex、double_complex）<br><strong>注意</strong>：C语言中并未规定必须支持复数类型</li></ol></li><li><p>Character Related：字符类型（char）+ 有符号字符类型（signed）+无符号字符类型（unsigned）<br><strong>注意</strong>：对于平时使用的char，其是否为有符号类型取决于平台，一般只用于存储ASCII码（0~127）</p></li><li><p>EnumeratedType：定义一系列<u>文字表述的<strong>整数</strong></u></p><hr></li><li><p>Basic Type ：char + Signed Integer Type + Unsigned Integer Type +Floating Type，均为<strong>完全对象类型</strong></p></li><li><p>Integer Type ：char + Signed Integer Type + Unsigned Integer Type+ Enumerated Type</p></li><li><p>Arithmetic Type ：Integer Type + Floating Type</p></li></ul><hr></li><li><p>DerivedType：可由其它类型<strong>递归</strong>地构造出来，包括数组类型、结构体类型、<strong>函数类型</strong>、指针类型等</p><ul><li><p>Array Type：给定任何一个ObjectType，都可以其为元素类型构造对应的<strong>一维数组</strong>类型<br><strong>注意</strong>：对于“高维数组”类型，均可通过“低维数组”类型递归地构造</p></li><li><p>Function Type：其定义包括返回值类型 + 参数数量及类型</p></li><li><p>Pointer Type：给定任何一个Type（ReferenceType），都有对应的<strong>指针类型</strong>（Pointer Type）<br><strong>注意</strong>：任何指针类型都是一个普通的Object Type</p><hr></li><li><p>Scalar Type ：Arithmetic Type + PointerType（可进行标量加减操作）</p></li><li><p>Aggregate Type ：Array Type + Struct Type<br><strong>注意</strong>：Union Type不是聚合类型</p></li><li><p>Incomplete ObjectType：缺少确定object大小的信息，如数组缺少元素个数、void类型、包含不完全类型的结构体或联合体等</p></li></ul></li></ul><hr><h3 id="二十赋值表达式">二十、赋值表达式</h3><ul><li><p>赋值操作符：包括 =、+=、&gt;&gt;= 等赋值操作符</p></li><li><p>赋值表达式：定义为 exp1 assignment_operatorexp2，其中exp1一定是modifiable lvalue</p><ul><li>C：上面表达式不是lvalue，其返回值为exp1更新过的值</li><li>C++：上面表达式是lvalue，指向exp1定位的、已被更新的对象</li></ul></li><li><p>后缀加减 or 前缀加减：exp++ or ++exp</p><ul><li>exp++：<u><strong>返回值为exp的值</strong></u>，<strong>副作用</strong>是让exp对应对象的值+1；exp++不是lvalue</li><li>++exp：等价于<code>exp += 1</code>，返回值是<strong>exp更新后的值</strong>，故其在C语言中是lvalue、而在C++中不是lvalue</li></ul><p><strong>注意</strong>：为了维护程序的<strong>可读性</strong>，<u>GJB中规定禁止使用++、-- 操作符</u></p><hr></li><li><p>Evaluation of Expression：主要包括两个步骤</p><ul><li>Value Computation：计算表达式的返回值&lt;V, V_T&gt;</li><li>Initiation of SideEffect：确定表达式的副作用，即执行状态的变化，如<u>改变内存值</u><br><strong>注意</strong>：副作用利用<u>等号右侧<strong>表达式的返回值</strong></u>，改变等号左侧的<strong>内存值</strong></li></ul><p><strong>注意</strong>：a++ 和 ++a这两个表达式都有各自的返回值，但什么时候真的+1（即副作用的出现顺序）则是<strong>不确定</strong>的</p></li><li><p>Sequenced Before：描述两个表达式之间 evaluation 的先后顺序<br>exp1 Sequenced Before exp2表示exp1的<strong>求值与副作用</strong>全部发生在exp2的<strong>求值与副作用</strong>之前</p></li><li><p>Sequence Point ：exp1 Sequenced Point exp2 <span class="math inline">\(\Leftrightarrow\)</span> exp1 Sequenced Beforeexp2 <br>常见的SequencePoint：<u>实参求值与函数调用</u>之间、<u>两个独立分隔的表达式</u>之间 等<br><strong>注意</strong>：两个Sequence Point内部的表达式之间没有约定evaluation 的先后顺序</p></li><li><p>有关自增/自减的undefined behavior：对于一个scalarobject，如果满足其中一种条件：</p><ul><li>产生<strong>两次副作用</strong>，且两次副作用之间没有先后顺序的约定，如<code>int i = 1; i = ++i + 1;</code><br>若 ++i 副作用先执行，则最后将 i 赋值为表达式 ++i + 1 的返回值3<br>若 i = ++i + 1 副作用先执行，则先将 i 赋值为 ++i + 1 的返回值3，最后i 自增得到4</li><li>产生的<strong>副作用</strong>与<strong>对其取值</strong>之间没有先后顺序的约定，如<code>int i = 1; a[i++] = i;</code><br>若 i++ 的副作用发生在等号右侧对 i 求值之前，则 i 先自增为2，再将<strong>a[1] 赋值为2</strong> <br>若 i++ 的副作用发生在等号右侧对 i求值之后，则先将 <strong>a[1] 赋值为1</strong>，i 再自增为2<br><strong>注意</strong>：表达式 i++ 的返回值始终为1，故均是对 a[1]赋值</li></ul><p>则最终内存结果不确定，取决于编译器的优化方法等行为</p></li></ul><hr><h3 id="二十一volatile限定符">二十一、volatile限定符</h3><ul><li>变量声明：<code>Var_T volatile N;</code>，其中变量N的表示值类型为Var_T<br>volatile限定符表示这块内存的值可能<strong>以未知的方式变化</strong></li><li>Volatile 在 MMIO 中的应用：<ul><li>MMIO：内存和I/O共享同一个地址空间</li><li>定义外设映射内存：<code>#define NUM (*(int volatile*)0x12340000)</code><br>这样变量NUM的内存值可能被<strong>硬件</strong>而非程序改变，表现为NUM值不可控</li></ul></li><li>abstract machine 和 volatile：“抽象机”是一种<u>不考虑优化</u>的模型；volatile修饰的变量遵循“抽象机”模型 <br>每次访问 volatile修饰的变量都会严格从<strong>内存</strong>中获取值，而不是直接从<strong>寄存器等缓存</strong>中获取值</li><li>volatile的使用注意事项：由于每次都只从内存中读数据，而数据又可能被硬件改变，所以每次值都不确定<ul><li>编译器优化：如果从<u>寄存器等缓存</u>中读值，结果就是<strong>正确</strong>的；如果只从<u>内存</u>中读值，结果就是<strong>不确定</strong>的</li><li>volatile access：获取被 volatile修饰的值的行为是<strong>副作用</strong></li></ul></li><li>Var_T volatile 对应的指针类型：变量类型 和 表示值类型 都是Var_Tvolatile*（Var_T volatile是一个<strong>整体</strong>）</li><li>Var_T constvolatile：从<u>程序代码角度</u>看是<strong>只读</strong>的，但从<u>硬件角度</u>看是会被<strong>随机修改</strong>的</li></ul><hr><h3 id="二十二literal">二十二、Literal</h3><ul><li><p>Literal的含义：仅从<strong>字面义</strong>去理解，不做任何演绎</p></li><li><p>StringLiteral：按<strong>字面意思</strong>理解的字符串（不包含转义），其内存值无法修改（编译警告、运行出错）</p></li><li><p>Compound Literal：按<strong>字面意思</strong>理解 (type-name){initializer-list } 这种组合形式，其内存值可以修改</p><hr></li><li><p>C语言常量（constant）：整数常量 + 浮点常量 + 枚举常量 + 字符常量<br><strong>注意</strong>：常量不是左值，不能像 Literal 和const修饰变量一样<strong>定位一块内存</strong></p></li><li><p>C++中的Literal：主要包括integer-literal、floating-literal、character-literal和string-literal</p><ul><li>string-literal：在C++中，其返回值类型为<strong>const</strong>char*；若尝试修改string-literal的值则会直接编译出错<br><strong>注意</strong>：C语言中string-literal的返回值类型为char*；<strong>const</strong>char* 体现literal在C++中具有<strong>常量</strong>的含义</li><li>compound-literal：C++中没有compound-literal，程序移植时要特别注意</li></ul><p><strong>注意</strong>：C++中的literal，对应C中的constant</p></li></ul><hr><h3 id="二十三padding">二十三、padding</h3><ul><li><p>字节大小：C语言中规定一个Byte含有 <strong>CHAR_BIT</strong>个二进制位，其中 <strong>CHAR_BIT</strong> 规定要 <span class="math inline">\(\ge\)</span> 8 <br><strong>注意</strong>：“1Byte =8bits”是长期发展形成的工业标准，部分平台的字节大小大于8</p></li><li><p>padding：<strong>填充</strong>类型中剩余的二进制位；设某类型的size 为 n <span class="math inline">\(\times\)</span> CHAR_BIT个比特，即 n 个字节：</p><ul><li><p>无符号整数类型：包含 value bits 和 padding bits <br>设 value bits共有N位（宽度为N），则该类型的表示值范围是 0 ~ <span class="math inline">\(2^N - 1\)</span></p></li><li><p>有符号整数类型：包含 sign bit，value bits 和 padding bits <br>设sign bit 和 value bits 共有N位（宽度为N），则该类型的表示值范围是 <span class="math inline">\(-(2^{N-1})\)</span> ~ <span class="math inline">\(2^{N-1} - 1\)</span></p><p><strong>注意</strong>：其中C语言规定 unsigned char 和 signed char类型均不允许有 padding bits</p></li></ul></li><li><p>整型变量 int / unsignedint：规定宽度N必须$$16，具体<strong>宽度不确定</strong></p></li><li><p>intN_t 和 uintN_t：表示无padding，且宽度<strong>确定为N</strong>的整型变量<br><strong>注意</strong>：若某平台提供了无padding，且宽度为32位的int类型，则应该<code>typedef int int32_t;</code></p></li><li><p>int_leastN_t 和uint_leastN_t：表示宽度<strong>至少为N</strong>的整型变量<br><strong>注意</strong>：C语言规定编译器必须定义含 least的整数类型；若编译器定义了intN_t，则 int_leastN_t 和 intN_t相同</p></li><li><p>int_fastN_t 和uint_fastN_t：表示<strong>宽度至少为N</strong>，且处理速度最快的整型变量（最快最小）<br><strong>注意</strong>：C语言规定编译器必须定义含 fast的整数类型；fast不代表总是最快，而是代表<strong>尽可能满足速度要求</strong></p></li></ul><hr><h3 id="二十四alignment">二十四、alignment</h3><ul><li><p>地址对齐：规定对象内存的<strong>首地址</strong>的限制；对齐值必须是2的n次方<br><strong>注意</strong>：“对象对齐”是指 <u>对象首地址 %对象的alignment == 0</u>，一般char的对齐数为1、int的对齐数为4</p></li><li><p>_Alignof ：对于类型为T的对象O，_Alignof(T)表示类型T的对齐数，_Alignof(O) 表示对象O的对齐数<br><strong>注意</strong>：对象O的对齐数默认为<strong>其类型T的对齐数</strong>，且可被修改</p></li><li><p>_Alignas：为类型为T的对象O设置<strong>更大的对齐数</strong>，声明句<code>_Alignas(N) T O;</code>表示将对象O的对齐数<strong>调大到N</strong></p><ul><li>修改<u>非数组类型</u>的对齐数：_Alignas(64) int a; <span class="math inline">\(\Rightarrow\)</span> _Alignof(a) ==64；且int的<strong>大小和类型对齐数均不变</strong></li><li>修改<u>数组类型</u>的对齐数：数组类型的对齐数 ==其<strong>元素类型</strong>的对齐数（<strong>递归定义</strong>）_Alignas(64) int a[N]; <span class="math inline">\(\Rightarrow\)</span>_Alignof(a) ==64；且int[N]的<strong>大小和类型对齐数均不变</strong></li></ul><p><strong>注意</strong>：通过 _Alignas改变对象的对齐数，并不会改变该对象的size，也不会改变其类型的对齐数</p></li><li><p>结构体的对齐要求：对于类型T为为结构体类型的对象O，_Alignof(T) ==max(_Alignof(<span class="math inline">\(\text{E}_i\)</span>))<br>其中<span class="math inline">\(\text{E}_i\)</span>表示结构体中第 i个<strong>成员对象的对齐数</strong></p><ul><li>通过 _Alignas(<span class="math inline">\(\text{E}_i\)</span>)调整<u>结构体成员对象</u>的对齐数，会改变该结构体类型的对齐数</li><li>通过 _Alignas(stru)调整<u>结构体对象</u>的对齐数，会使该对象的对齐数 &gt;结构体类型对齐数</li></ul></li></ul><hr><h3 id="二十五结构体类型的size">二十五、结构体类型的size</h3><ul><li><p>计算结构体类型的大小：遍历所有成员对象，确定各成员对象的 offset和 padding；对于每个成员对象：</p><ol type="1"><li>根据<u>该<strong>对象</strong>的对齐数</u>，找到满足其<strong>对齐要求</strong>的<strong>最小offset</strong>该对象与上一个成员对象间的空白距离称为 <strong>internalpadding</strong></li><li>将该成员对象O填充在 offset 处，其占据了sizeof(O) 的内存空间</li></ol><p>填写了所有成员变量后，根据<u>该结构体<strong>类型</strong>的对齐数</u>，在末尾留出<strong>最小trailingpadding</strong></p><p><span class="math inline">\(\Rightarrow\)</span> sizeof(T) = <span class="math inline">\(\sum\)</span> sizeof(<span class="math inline">\(\text{O}_i\)</span>) + <span class="math inline">\(\sum\)</span> internal padding + trailingpadding</p><p><strong>注意</strong>：由上述过程可知，结构体类型的size是其对齐数的<strong>整数倍</strong></p></li><li><p>#pragma pack(n) ：调整结构体<strong>内部</strong>对象的对齐要求<br>对于结构体类型T，设其第 i 个成员对象为<span class="math inline">\(\text{E}_i\)</span>，则 _Alignof(<span class="math inline">\(\text{E}_i\)</span>) = min(_Alignof(<span class="math inline">\(\text{E}_i\)</span>), n)<br><strong>注意</strong>：对于结构体类型T，_Alignof(T) =max(_Alignof(<span class="math inline">\(\text{E}_i\)</span>))，该规则保持不变，用于最后计算trailing padding</p></li><li><p>申请<strong>指定对齐要求</strong>的空间：<code>void* aligned_alloc(size_t alignment, size_t size);</code></p></li><li><p>指针类型强转的对齐问题：对指针表达式的类型强制转换后需要保持<strong>地址对齐</strong><br>如 char* 类型的内存对齐数为1，int*类型的内存对齐数是4，则<code>char* p; (int*)(p + 1);</code>会不对齐，属于ub</p></li></ul><hr><h3 id="二十六restrict限定符">二十六、restrict限定符</h3><ul><li><strong>指针</strong>变量声明：<code>Var_T* restrict p;</code><br><strong>注意</strong>：restrict 只能修饰指针变量类型</li><li>restrict 的使用：设 p 为 restrict修饰的指针变量，则程序员需要保证<u>在指针 p的生命周期内</u>，其指向的对象不会被其它指针<strong>同时引用</strong></li><li>restrict与编译器优化：对于两个位于<u>同一作用域</u>的指针变量，若其指向了不同的内存块，编译器可以采用<strong>载入立即数</strong>等方式修改两个内存块数据，以达到<strong>优化代码</strong>的目的（减少访存次数）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>system programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>『machine learning-3』Bayes</title>
    <link href="/2023/08/16/machine_learning/Bayes/"/>
    <url>/2023/08/16/machine_learning/Bayes/</url>
    
    <content type="html"><![CDATA[<h2 id="贝叶斯决策">贝叶斯决策</h2><h3 id="一贝叶斯公式">一、贝叶斯公式</h3><ul><li><p>相关术语：</p><ul><li>样本：<span class="math inline">\(x \in\text{R}^d\)</span>，表示共有d个属性的样本</li><li>类别（状态）：<span class="math inline">\(\omega_i\)</span>，表示第i 个标签</li><li>先验概率：<span class="math inline">\(P(\omega_i)\)</span>，表示类别为 <span class="math inline">\(\omega_i\)</span> 的样本的分布</li><li>类条件概率：<span class="math inline">\(P(x \text{ | }\omega_i)\)</span>，表示<strong>类别 <span class="math inline">\(\omega_i\)</span></strong>中样本<span class="math inline">\(x\)</span>的比例</li><li>后验概率：<span class="math inline">\(P(\omega_i \text{ |}x)\)</span>，表示给定<strong>任意样本</strong><span class="math inline">\(x\)</span>，判断其属于类别 <span class="math inline">\(\omega_i\)</span> 的概率</li></ul></li><li><p>贝叶斯公式：已知<u>先验概率</u> <span class="math inline">\(P(\omega_i)\)</span> 和<u>条件概率</u><span class="math inline">\(P(x \text{ |}\omega_i)\)</span>，计算<strong>后验概率</strong> <span class="math inline">\(P(\omega_i \text{ | }x)\)</span> <span class="math display">\[\begin{align}P(\omega_i \text{ | }x) &amp;= \frac{P(x \text{, }\omega_i)}{P(x)} \\&amp;= \frac{P(x \text{ | }\omega_i)P(\omega_i)}{\sum_{i=1}^c P(x \text{| }\omega_i)P(\omega_i)}\end{align}\]</span><strong>注意</strong>：贝叶斯公式中，分子使用<strong>乘法公式</strong>，分母使用<strong>全概率公式</strong></p></li></ul><hr><h3 id="二贝叶斯决策论">二、贝叶斯决策论</h3><ul><li><p>条件风险：设共有N种类别 <span class="math inline">\(C =\{\omega_1, \dots \omega_N\}\)</span>，将真实类别为 <span class="math inline">\(\omega_j\)</span> 的样本<span class="math inline">\(x\)</span><u>误分类</u>为 <span class="math inline">\(\omega_i\)</span> 的<strong>损失</strong>为<span class="math inline">\(\lambda_{ij}\)</span> 则进行 <span class="math inline">\(\omega_i\)</span> 分类的条件风险 <span class="math inline">\(R(\omega_i \text{ | }x)\)</span> 为： <span class="math display">\[R(\omega_i \text{ | }x) = \sum_{j=1}^N \lambda_{ij}P(\omega_j \text{ |}x)\]</span> <strong>注意</strong>：<span class="math inline">\(\lambda_{ii} =0\)</span>，即<strong>没有误分类</strong>的损失为0；否则为对应的误分类损失值</p></li><li><p><strong>最小风险</strong>贝叶斯决策：已知先验概率<span class="math inline">\(P(\omega_i)\)</span>，类条件概率<span class="math inline">\(P(x \text{ | }\omega_i)\)</span>（i = 1, 2, ...,N），待分类样本为 <span class="math inline">\(x\)</span></p><ol type="1"><li>后验概率：根据<u><strong>贝叶斯公式</strong></u>计算各后验概率 <span class="math inline">\(P(\omega_i \text{ | }x)\)</span>（i = 1, 2, ...,N）</li><li>考虑风险：根据所求<u>后验概率</u>和<u>损失函数</u><span class="math inline">\(\lambda\)</span>，计算各条件风险 <span class="math inline">\(R(\omega_i \text{ | }x)\)</span>（i = 1, 2, ...,N）</li><li>做出决策：<span class="math inline">\(\omega =\underset{i}{\text{argmin } }R(\omega_i \text{ |}x)\)</span>，即选出使<strong>决策风险最小</strong>的类别</li></ol></li><li><p><strong>最小错误率</strong>贝叶斯决策：已知先验概率<span class="math inline">\(P(\omega_i)\)</span>，类条件概率<span class="math inline">\(P(x \text{ | }\omega_i)\)</span>（i = 1, 2, ...,N），待分类样本为 <span class="math inline">\(x\)</span></p><ol type="1"><li>后验概率：根据<u><strong>贝叶斯公式</strong></u>计算各后验概率 <span class="math inline">\(P(\omega_i\text{ | }x)\)</span>（i = 1, 2, ...,N）</li><li>做出决策：<span class="math inline">\(\omega =\underset{i}{\text{argmax }}{P(\omega_i \text{ |}x)}\)</span>，即选出使<strong>错误率最小</strong>的类别</li></ol><p><strong>注意</strong>：最小错误率贝叶斯决策即为<u>损失函数<span class="math inline">\(\lambda\)</span>为 0 - <strong>1</strong>条件下</u>的最小风险贝叶斯决策</p></li><li><p><strong>朴素</strong>贝叶斯决策：</p><ul><li><p>贝叶斯决策的问题：类条件概率<span class="math inline">\(P(x\text{ | }\omega_i)\)</span> 是样本<span class="math inline">\(x\)</span>在<strong>所有属性上的联合概率</strong>，难以从<u>有限样本</u>中获取</p></li><li><p>属性条件<u>独立性</u>假设：假设样本<span class="math inline">\(x\)</span>的各个属性<span class="math inline">\(x_i\)</span>之间<strong>相互独立</strong>，则类条件概率可做<strong>拆分</strong>：<span class="math display">\[\begin{align}P(x \text{ | }\omega_i) &amp;= P(x_1x_2\dots x_d \text{ | }\omega) \\&amp;= \Pi_{i=1}^d P(x_i \text{ | }\omega)\end{align}\]</span><strong>注意</strong>：独立性假设有助于<strong>降低对样本集的大小需求</strong>，从而降低复杂度</p></li><li><p>贝叶斯公式 + 属性独立性条件：朴素贝叶斯公式可以写为： <span class="math display">\[\begin{align}P(\omega \text{ | }x) &amp;= \frac{P(\omega)P(x\text{ | }\omega)}{P(x)}\\&amp;= \frac{P(\omega)}{P(x)} \Pi_{i=1}^d P(x_i \text{ | }\omega)\end{align}\]</span> 相应的决策转变为：<span class="math inline">\(\omega_k =\underset{j}{\text{argmin }}{P(\omega_j)\Pi_{i=1}^dP(x_i \text{ |}\omega_j)}\)</span>（假设对各类别 <span class="math inline">\(P(x)\)</span> 均相等）</p></li><li><p>基于训练样本的估计：</p><ul><li>先验概率估计：<span class="math inline">\(P(\omega_i) =\dfrac{|D_{\omega_j}| + 1}{|D| + N}\)</span> <br>其中 <span class="math inline">\(|D_{\omega_j}|\)</span>表示样本集D中类别为<span class="math inline">\(\omega_j\)</span>的样本数量，N表示样本集D中可能的类别数</li><li>类条件概率估计：<span class="math inline">\(P(x_i \text{ |}\omega_j) = \dfrac{|D_{\omega_j, x_i}| + 1}{|D_{\omega_j}| +N_i}\)</span> <br>其中 <span class="math inline">\(|D_{\omega_j,x_i}|\)</span>表示样本<span class="math inline">\(D_{\omega_j}\)</span>中样本第i个属性取值为<span class="math inline">\(x_i\)</span>的数量，<span class="math inline">\(N_i\)</span>表示第i个属性可能的取值个数</li></ul></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>machine learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>『link and load-3』runtime library</title>
    <link href="/2023/08/01/link_and_load/runtime-library/"/>
    <url>/2023/08/01/link_and_load/runtime-library/</url>
    
    <content type="html"><![CDATA[<h2 id="库与运行库">库与运行库</h2><h3 id="一程序的内存布局">一、程序的内存布局</h3><ul><li><p>应用程序的内存空间：从上往下依次是：</p><ul><li>栈：维护<strong>函数</strong>调用的上下文，从高地址向下扩展</li><li>动态链接库映射区：装载依赖的<strong>动态链接库</strong></li><li>堆：容纳应用程序<strong>动态分配</strong>的内存区域（malloc ornew），从低地址向上扩展</li><li>可执行文件映像：<strong>可执行文件</strong>的可读可写区、只读区等段</li><li>保留区：被<strong>禁止访问</strong>的低地址区域</li></ul><p><strong>注意</strong>：“segment fault”常发生在<strong>非法指针解引用</strong>，如<u>试图写0地址，随机地址</u>等</p><hr></li><li><p>栈：遵循<strong>先入先出</strong>（FIFO）的<strong>动态</strong>内存区域</p><ul><li><p>栈帧：保存函数调用所需要维护的信息，又称活动记录，主要包括以下内容：</p><ul><li>函数<strong>接收的参数与返回地址</strong></li><li>临时变量：函数内的<strong>非静态局部变量</strong>，或编译器自动生成的<strong>其它临时变量</strong></li><li>保存上下文：函数调用前后需要<strong>保持不变的寄存器</strong></li></ul></li><li><p>“烫”与“屯”：Debug模式下，分配的栈空间（未初始化的局部变量）被初始化为0xCC或0xCD</p></li><li><p>与栈相关的两个寄存器：esp和ebp</p><ul><li>esp：始终指向栈顶，其位置随函数执行而不断变化</li><li>ebp：又称“帧指针”，其位置固定不变，指向栈中<u>调用函数前的ebp旧值</u></li></ul></li><li><p>i386标准函数调用流程：2、3两步由call指令一起执行</p><ol type="1"><li><p>把所有或部分<strong>参数压栈</strong>，或使用特定寄存器传参</p></li><li><p>将当前调用指令的<strong>下一条指令的地址</strong>（即返回地址）压入栈中</p></li><li><p>保存好<u>参数</u>和<u>返回地址</u>后，跳转到函数体：</p></li></ol><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 将ebp寄存器的 旧值 保存在栈上 */</span><br>push ebp<br><span class="hljs-comment">/* 将ebp固定在当前栈顶位置 */</span><br>mov ebp, esp<br><span class="hljs-comment">/* 开辟x字节的栈空间 */</span><br>sub esp, x<br><span class="hljs-comment">/* 保存n个寄存器（可选） */</span><br>push reg_1<br>...<br>push reg_n<br><span class="hljs-comment">/* ... FUNCTION BODY ... */</span><br><span class="hljs-comment">/* 恢复n个寄存器（可选） */</span><br>pop reg_n<br>...<br>pop reg_1<br><span class="hljs-comment">/* 回收开辟的栈空间 */</span><br>mov esp, ebp<br><span class="hljs-comment">/* 恢复ebp寄存器的旧值 */</span><br>pop ebp<br><span class="hljs-comment">/* 调用ret指令返回 */</span><br>ret<br></code></pre></td></tr></table></figure></p><p><strong>注意</strong>：对于声明为static（或仅在本编译单元被调用）的函数，可能不会按照上面的标准流程执行</p><hr></li><li><p>调用惯例：函数的<u>调用方</u>和<u>被调用方</u>之间的约定</p><ul><li>函数参数的传递顺序和方式：规定参数的<strong>压栈顺序</strong>，<strong>传参寄存器</strong>等</li><li>栈的维护方式：约定<strong>负责弹栈的一方</strong>，保持栈在函数调用前后保持一致</li><li>名字修饰策略：通过<strong>对函数本身的名字进行修饰</strong>，以区分不同的调用惯例</li></ul></li><li><p>常见的调用惯例：</p><ul><li>cdecl：默认调用惯例<ul><li>压栈顺序：<strong>从右向左</strong>将参数列表压栈</li><li>负责出栈方：函数<strong>调用方</strong></li><li>名字修饰：下划线 + 函数名，如_foo</li></ul></li><li>stdcall：<ul><li>压栈顺序：<strong>从右向左</strong>将参数列表压栈</li><li>负责出栈方：函数<strong>本身</strong></li><li>名字修饰：下划线 + 函数名 + @ + 参数列表的总字节数，如_foo@12</li></ul></li><li>fastcall：通过寄存器传参优化性能<ul><li>压栈顺序：头两个4字节（或更少）的参数通过寄存器传参，其余参数<strong>从右向左</strong>压栈</li><li>负责出栈方：函数<strong>本身</strong></li><li>@ + 函数名 + @ + 参数列表的总字节数，如@foo<span class="citation" data-cites="12">@12</span></li></ul></li></ul></li><li><p>函数返回值的传递：</p><ul><li>返回值 <span class="math inline">\(\le\)</span>4字节：使用eax寄存器传值；4字节 <span class="math inline">\(\lt\)</span>返回值 <span class="math inline">\(\le\)</span>8字节：eax存低四字节、edx存高位</li><li>返回值 <span class="math inline">\(\gt\)</span>8字节：在<strong>栈上</strong>开辟空间保存返回值对象，并将<strong>返回值的地址</strong>通过eax寄存器传出</li></ul></li></ul><hr></li><li><p>堆：占据绝大部分的虚拟空间</p><ul><li><p>Linux 进程堆管理：两个<strong>系统调用</strong>，分别是brk()和mmap( )</p><ul><li>brk: 设置进程数据段的<strong>结束地址</strong>，其C函数原型为 intbrk(void* end_data_segment);</li><li>mmap: C函数原型为 void* mmap(void* start, size_t length, int prot,int flags, int fd, ...);<ul><li>start与length：指定需要申请的<strong>空间始址</strong>和<strong>长度</strong></li><li>prot：指定申请空间的<strong>权限</strong>（可读 or 可写 or可执行）</li><li>flags：指定申请空间的<strong>映射类型</strong>（文件映射 or<strong>匿名空间</strong>）</li><li>fd：若为文件映射，则指定<strong>被映射文件的描述符</strong></li></ul></li></ul></li><li><p>Windows 进程堆管理：</p><ul><li>Windows 进程地址空间：</li></ul><figure style="text-align:center;"><p><img src="/2023/08/01/link_and_load/runtime-library/Windows进程地址空间.png" width="35%" height="35%"></p><figcaption><p>Windows进程地址空间</p></figcaption></figure><ul><li><p>EXE一般位于地址 0x00400000；运行库DLL一般位于地址0x10000000</p></li><li><p>VirtualAlloc: Windows提供的API，用于向系统申请虚拟空间</p></li><li><p>堆管理器：Windows中提供与堆相关的一套API</p><ul><li>HeapCreate：创建一个堆（通过VirtualAlloc实现）</li><li>HeapAlloc：在一个堆里分配一块较小的内存</li><li>HeapFree：释放已经分配的内存</li><li>HeapDestroy：销毁一个堆</li></ul><p><strong>注意</strong>：Windows中，当一个堆空间不够时，会创建更多的堆，故进程中可能存在多个堆</p></li></ul><hr></li><li><p>堆分配算法：用于管理堆空间，做到按需分配与回收释放</p><ul><li>空闲链表：将堆中各空闲的块按链表串起来<ul><li>header：每个空闲块的开头有一个头结构，记录上一个和下一个空闲块的地址</li><li>prev与next：分别指向上一个空闲块地址和下一个空闲块地址</li><li>分配方案：在空闲链表中查找足够大的空闲块，并将其中一部分分配出去</li></ul></li><li>位图：将堆均分为大量的块，并使用数组管理块<ul><li>分配方案：每次分配整数个块，第一个块为Head，其余块为Body</li><li>块状态：Head or Body or Free</li></ul></li></ul></li></ul></li></ul><hr><h3 id="二运行库">二、运行库</h3><ul><li><p>入口函数（EntryPoint）：一个程序<u>初始化</u>或<u>结束</u>的部分</p><ul><li><p>GLIBC入口函数：</p><ul><li><p>调用_start函数前：装载器依次将<strong>环境变量</strong>和<strong>用户参数</strong>压入栈中</p></li><li><p>调用_start函数：_start入口由ld链接器的链接脚本决定</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c">libc\sysdeps\i386\elf\Start.S<br>_start:<br><span class="hljs-comment">/* 将ebp寄存器置0 */</span><br>xorl %ebp, %ebp<br>    <span class="hljs-comment">/* esi寄存器指向argc */</span><br>    popl %esi<br>    <span class="hljs-comment">/* ecx寄存器指向argv */</span><br>    movl %esp, %ecx<br>    <br>    <span class="hljs-comment">/* 下面向 __libc_start_main 函数传参 */</span><br>    <span class="hljs-comment">/* 将 栈顶地址 压栈 */</span><br>    pushl %esp<br>    <span class="hljs-comment">/* 将 rtld_fini函数地址 压栈 */</span><br>    pushl %edx<br>    <span class="hljs-comment">/* 将 __libc_csu_fini函数地址 压栈 */</span><br>    pushl $__libc_csu_fini<br>    <span class="hljs-comment">/* 将 __libc_csu_init函数地址 压栈 */</span><br>    pushl $__libc_csu_init<br>    <span class="hljs-comment">/* 将 用户命令 压栈 */</span><br>    pushl %esi<br>    <span class="hljs-comment">/* 将 main函数地址 压栈 */</span><br>    pushl main<br>    <span class="hljs-comment">/* 跳转到 __libc_start_main 函数*/</span><br>    call __libc_start_main<br>    <span class="hljs-comment">/* 若函数调用失败，hlt会强行把程序停下来 */</span><br>    hlt<br></code></pre></td></tr></table></figure><ul><li>__libc_start_main：包括全局对象的构造与析构、main函数的调用与退出</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __libc_start_main(<br>    <span class="hljs-type">int</span> (*main) (<span class="hljs-type">int</span>, <span class="hljs-type">char</span>**, <span class="hljs-type">char</span>**),<br>    <span class="hljs-type">int</span> argc,<br>    <span class="hljs-comment">/* 用户命令，即argv */</span><br>    <span class="hljs-type">char</span>** ubp_av,<br>    <span class="hljs-comment">/* init 负责 main 调用前的初始化工作 */</span><br>    __typeof (main) init,<br>    <span class="hljs-comment">/* fini 负责 main 结束后的收尾工作 */</span><br>    <span class="hljs-type">void</span> (*fini) (<span class="hljs-type">void</span>),<br>    <span class="hljs-comment">/* rtld_fini 负责和动态加载相关的收尾工作 */</span><br>    <span class="hljs-type">void</span> (*rtld_fini) (<span class="hljs-type">void</span>),<br>    <span class="hljs-type">void</span>* stack_end<br>) &#123;<br>    <span class="hljs-comment">/* 取出环境变量 */</span><br>    <span class="hljs-type">char</span>** ubp_ev = &amp;ubp_av[argc + <span class="hljs-number">1</span>];<br>    __environ = ubp_ev, __libc_stact_end = stack_end;<br>    ...<br>    <span class="hljs-comment">/* 若干初始化操作 */</span><br>    <span class="hljs-comment">/* ⬇ 通过 __cxa_atexit 函数注册退出函数 ⬇ */</span><br>    <span class="hljs-comment">/* __cxa_atexit(rtld_fini, NULL. NULL); */</span><br>    <span class="hljs-comment">/* __cxa_atexit(fini, NULL, NULL); */</span><br>    ...<br>    <span class="hljs-type">int</span> result = main(argc, argv, __environ);<br>    <span class="hljs-built_in">exit</span>(result);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>exit与_exit：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">int</span> status)</span> &#123;<br>    <span class="hljs-comment">/* 遍历 __exit_funcs函数链表，依次调用由 __cxa_atexit 注册的函数 */</span><br>    <span class="hljs-keyword">while</span> (__exit_funcs != <span class="hljs-literal">NULL</span>) &#123;<br>        ...<br>        __exit_funcs = __exit_funcs -&gt; next;<br>    &#125;<br>    ...<br>    _exit(status);<br>&#125;<br><br>_exit:<br>movl <span class="hljs-number">4</span>(%esp), %ebx<br>    movl $__NR_exit, %eax<br>    <span class="hljs-comment">/* 执行exit系统调用，结束程序 */</span><br>    <span class="hljs-type">int</span> $<span class="hljs-number">0x80</span><br>    <span class="hljs-comment">/* 若程序终止失败，hlt会强行把程序停下来 */</span><br>    hlt<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：程序可以在main函数返回后调用exit退出，也可以直接调用exit退出</p><hr></li><li><p>MSVC CRT 入口函数：</p><ul><li>mainCRTStartup：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">mainCRTStartup</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    ...<br>    <span class="hljs-comment">/* 在堆初始化之前只能使用 _alloca 分配空间 */</span><br>    posvi = (OSVERSIONINFO *)_alloca(<span class="hljs-keyword">sizeof</span>(OSVERSIONINFO));<br>    posvi -&gt; dwOSVersionInfoSize = <span class="hljs-keyword">sizeof</span>(OSVERSIONINFOA);<br>    <span class="hljs-comment">/* 获取当前操作系统的版本信息，初始化系统全局变量 */</span><br>    GetVersionExA(posvi);<br>    <span class="hljs-comment">/* 填写平台信息 */</span><br>    _osplatform = posvi -&gt; dwPlatformId;<br>    <span class="hljs-comment">/* 填写主版本号 */</span><br>    _winmajor = posvi -&gt; dwMajorVersion;<br>    _winminor = posvi -&gt; dwMinorVersion;<br>    <span class="hljs-comment">/* 填写操作系统版本 */</span><br>    _osver = (posvi -&gt; dwBuildNumber) &amp; <span class="hljs-number">0x07fff</span>;<br>    ...<br>    <span class="hljs-comment">/* 先通过_heap_init初始化堆 */</span><br>    <span class="hljs-keyword">if</span> (!_heap_init(<span class="hljs-number">0</span>)) &#123;<br>        fast_error_exit(_RT_HEAPINIT);<br>    &#125;<br>    <br>    __try &#123;<br>        <span class="hljs-comment">/* 通过_ioinit初始化IO */</span><br>        <span class="hljs-keyword">if</span> (_ioinit() &lt; <span class="hljs-number">0</span>) &#123;<br>            _amsg_exit(_RT_LOWIOINIT);<br>        &#125;<br>        <span class="hljs-comment">/* 获取命令行与环境变量 */</span><br>        _acmdln = (<span class="hljs-type">char</span>*)GetCommandLineA();<br>        _aenvptr = (<span class="hljs-type">char</span>*)__crtGetEnvironmentStringA();<br>        <span class="hljs-keyword">if</span> (_setargv() &lt; <span class="hljs-number">0</span>) &#123;<br>            _amsg_exit(_RT_SPACEARG);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (_setenvp() &lt; <span class="hljs-number">0</span>) &#123;<br>            _amsg_exit(_RT_SPACEENV);<br>        &#125;<br>        <span class="hljs-comment">/* 设置其它C语言库 */</span><br>        initret = _cinit(TRUE);<br>        <span class="hljs-keyword">if</span> (initret != <span class="hljs-number">0</span>) &#123;<br>            _amsg_exit(initret);<br>        &#125;<br>        _initenv = _environ;<br>        <span class="hljs-comment">/* 调用 main 并退出 */</span><br>        mainert = main(__argc, __argv, _environ);<br>        _cexit();<br>    &#125;<br>    __except &#123;<br>        ...<br>        <span class="hljs-comment">/* 异常处理 */</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：try-except块是Windows结构化<strong>异常处理机制</strong>SEH的一部分</p><hr></li><li><p>运行库（CRT）与I/O：</p><ul><li><p>I/O：操作系统中代指<strong>程序与外界的交互</strong>，如文件、管道、网络，命令行等</p></li><li><p>文件：操作系统中具有<strong>输入输出</strong>概念的设备实体</p><ul><li>文件操作：借助FILE结构体指针实现</li><li>文件管理：在Linux中使用<strong>文件描述符</strong>（fd）；在Windows中使用<strong>句柄</strong></li></ul></li><li><p>打开文件表：<u>指针数组</u>，其中每个元素指向<strong>内核的打开文件对象</strong></p><figure style="text-align:center;"><p><img src="/2023/08/01/link_and_load/runtime-library/FILE.png"></p><figcaption><p>操作系统中的文件</p></figcaption></figure><p><strong>注意</strong>：FILE结构与fd是<strong>一一对应</strong>的</p></li></ul></li><li><p>MSVC CRT 的入口函数初始化：</p><ul><li>堆初始化：_heap_init()通过调用<strong>HeapCreate</strong>创建系统堆</li><li>I/O初始化：_ioinit( )<ol type="1"><li>建立<strong>打开文件表</strong></li><li>从父进程获取继承的<strong>文件句柄</strong></li><li>初始化<strong>标准输入输出</strong></li></ol></li></ul></li></ul><hr></li><li><p>C/C++ 运行库：</p><ul><li><p>C语言运行库：主要包括启动与退出函数、标准库函数、I/O功能函数等<strong>运行时依赖</strong></p><p><strong>注意</strong>：世界上第一个C语言标准由ANSI于1989年制定（即C89）</p></li><li><p>C语言标准库：主要包括文件操作、字符串处理、数学函数等C头文件，是<strong>运行库的主要部分</strong></p><ul><li><p>变长参数：C语言中特殊参数形式，通过省略号追加<u>任意数量、任意类型</u>的参数</p><ol type="1"><li>头文件：stdarg.h</li><li>实现方式：cdecl调用惯例，即<strong>从右向左压栈</strong>，且调用方负责弹栈</li><li>va_list：指向各不定参数的<strong>指针</strong>类型，一般为 char*类型</li><li>va_start：将va_list定义的指针指向<strong>第一个不定参数</strong></li><li>va_arg：获取当前不定参数的值，并将va_list<strong>移向下一个参数</strong></li><li>va_end：将va_list指针<strong>清0</strong></li></ol><p><strong>注意</strong>：GCC和MSVC均支持<u>定义宏</u>时使用变长参数</p></li><li><p>非局部跳转：</p><ul><li>头文件：setjmp.h</li><li>实现方式：调用 longjmp( ) 跳转至 <strong>setjmp( )函数返回的时刻</strong>，并重新指定其返回值</li></ul></li></ul></li></ul><hr><ul><li><p>glibc与MSVC CRT：C语言程序与操作系统平台之间的<strong>抽象层</strong></p><ul><li><p>glibc ：GNU C Library，即Linux平台下的C标准库</p><ul><li><p>主要组成：标准头文件 + 库的二进制文件部分</p></li><li><p>glibc启动文件：包括crt1.o、crti.o、crtn.o等</p><ul><li>crt1.o：包含入口函数_start</li><li>crti.o：包含_init( )和 _fini( )函数的<strong>开头代码</strong></li><li>crtn.o：包含_init( )和_fini( )函数的<strong>结尾代码</strong></li></ul><p>最终输出文件的“.init”段只包含函数_init( )，“.fini”段只包含函数 _fini()</p><p><strong>注意</strong>：链接时实际顺序为 <u>crti.o -&gt; crtbegin.o-&gt; someobjs.o -&gt; crtend.o -&gt; crtn.o</u></p></li><li><p>GCC平台相关目标文件：包括crtbegin.o、crtend.o等</p><ul><li>crtbegin.o：实现C++的全局对象构造</li><li>crtend.o：实现C++的全局对象析构</li><li>libgcc.a：执行不同硬件平台下的数学运算函数</li><li>libgcc_eh.a：支持C++异常处理的相关函数</li></ul><p><strong>注意</strong>：.init和.fini仅在main()执行<strong>前后</strong>运行，实际上与全局对象的构造析构无关</p></li></ul><hr></li><li><p>MSVC CRT ：Microsoft Visual C++ CRuntime，即Windows平台下的C标准库</p><ul><li><p>主要组成：不同分类指标下的多种<strong>子版本</strong>，如静态/动态链接版、单线程/多线程版等不同属性之间可以互相组合 编译器cl根据传入参数选择对应的CRT，如选项 /MDd对应选择msvcrtd.lib</p></li><li><p>静态运行库的命名规则：libc [p] [mt] [d] .lib，其中：</p><ul><li>p表示CPlusplus，即<strong>C++标准库</strong></li><li>mt表示Multi-Thread，即表示<strong>支持多线程</strong></li><li>d表示Debug，即表示<strong>调试版本</strong></li></ul></li><li><p>动态运行库：含有用于链接的.lib文件、以及运行时使用的.dll动态链接库</p><p>动态链接库的命名规则中增加了<strong>版本号</strong>，如多线程 +<strong>动态链接</strong>的 msvcr<strong>90</strong>.dll</p></li></ul><p><strong>注意</strong>：若DLL分别使用<u>不同版本的CRT</u>，则各DLL间难以传递共享资源（如堆空间、文件等）</p></li></ul><hr></li><li><p>运行库与多线程</p><ul><li><p>线程的访问权限：线程可以访问以下数据</p><ul><li><strong>进程</strong>内存中的所有<strong>公共数据</strong>，如全局变量、堆、静态变量</li><li>线程的私有数据，如栈、寄存器、线程局部存储（TLS）</li></ul></li><li><p>多线程运行库：提供<u>多线程操作</u>的接口，并支持<u>多线程环境</u>下的正确运行</p><ul><li>多线程操作接口：用于线程的<strong>创建与退出</strong></li><li>多线程环境运行：确保使用运行库接口时的<strong>线程安全</strong></li></ul></li><li><p>多线程安全问题的解决措施：</p><ul><li>使用TLS：将变量存储在各线程的私有环境中</li><li>加锁：在线程不安全的函数中加锁（如malloc、printf 等）</li><li>改进函数调用：如 strtok( ) <span class="math inline">\(\rightarrow\)</span> strtok_s( )（C11引入）<strong>注意</strong>：strtok()通过在函数内部设置<strong>静态指针</strong>跟踪字符串地址，多线程调用会有冲突strtok_s()通过保存<u>上次调用时</u><strong>静态指针的地址</strong>，保证了线程安全</li></ul><hr></li><li><p>线程局部存储（TLS）</p><ul><li><p>TLS的隐式定义：Linux使用关键字_thread、Windows使用_declspec(thread)</p><p><strong>注意</strong>：被定义为TLS的全局变量在每个线程中保存有<strong>独立的副本</strong></p></li><li><p>Windows中TLS的实现：</p><ul><li><p>.tls段：专门负责存放被声明为TLS的全局变量</p></li><li><p>TLS表：保存所有TLS变量的构造函数和析构函数的<strong>地址</strong></p><p><strong>注意</strong>：TLS表的信息存于PE数据目录中的IMAGE_DIRECT_ENTRY_TLS项中</p></li><li><p>线程环境块（TEB）：保存线程ID、堆栈地址、TLS数组等信息</p><p><strong>注意</strong>：TLS数组在TEB中的偏移是0x20，可以通过该偏移量找到TLS数组</p></li><li><p>TLS数组：用于查找TLS变量在线程中的地址，其首元素存放.tls段的地址</p></li></ul></li><li><p>TLS的显式定义：需借助库函数API<u>手动申请与释放</u>，不便使用（不推荐）</p><ul><li>实现方式：借助<strong>TLS数组</strong>保存TLS数据</li><li>二级TLS数组：需额外申请，用于存放更多的TLS数据</li></ul></li></ul></li></ul><hr></li><li><p>C++全局构造与析构</p><ul><li><p>glibc全局构造与析构</p><ul><li><p>GLOBAL__I_Hw：负责<u>本编译单元</u>所有的全局与静态对象的<strong>构造与析构</strong></p></li><li><p>.ctor段：每个目标文件含有一个.ctor段，存放指向本目标文件<strong>全局构造函数的指针</strong></p><p><strong>注意</strong>：各目标文件的.ctor段合并成最终输出文件的.ctor段，形成<u>构造函数指针数组</u></p><ul><li>.crtbegin.o：其.ctor段定义符号__CTOR_LIST__，指向<strong>合并后.ctor段的始址</strong></li><li>目标文件：其.ctor段中存放一个全局构造函数的<strong>指针</strong></li><li>crtend.o：其.ctor段定义符号__CTOR_END__，指向<strong>合并后.ctor段的末尾</strong></li></ul></li><li><p>__do_global_ctors_aux：由GCC提供（不属于glibc），在**__libc_csu_init**中被调用</p><ul><li>__CTOR_LIST__：全局构造函数的<strong>指针数组</strong>，由.crtbegin.o 定义</li><li>初始化过程：依次执行__CTOR_LIST__列表中记录的各全局构造函数</li></ul><figure style="text-align:center;"><p><img src="/2023/08/01/link_and_load/runtime-library/.ctor段.png"></p><figcaption><p>.ctor段的形成</p></figcaption></figure><hr></li><li><p>__tcf_1：由GLOBAL__I_Hw中的<strong>_atexit</strong>注册，在最后的exit()中负责<strong>全局对象的析构</strong></p><p><strong>注意</strong>：全局对象的构造与析构的<u>流程是类似的</u>，<u>顺序是相反的</u></p></li></ul><hr></li><li><p>MSVC CRT的全局构造与析构</p><ul><li><p>_initterm：由mainCRTStartup函数调用借助全局指针__xc_a和__xc_c，依次遍历执行所有的全局构造函数</p><ul><li>.__xc_a：被分配在段.CRT$XCA中，指向首个构造函数（类似__CTOR_LIST__）</li><li>.__xc_c：被分配在段.CRT$XCZ中，指向构造函数的结束地址（类似__CTOR_END__）</li></ul><p><strong>注意</strong>：各.CRT$XC*段合并后被分配在.rdata段（只读），且按照<u>字母*的字典序</u>链接</p><hr></li><li><p>dynamic atexit destructor *：由<strong>atexit()</strong>注册，退出时负责<u>全局对象*的析构</u></p></li></ul></li></ul></li></ul><hr><h3 id="三系统调用与api">三、系统调用与API</h3><ul><li><p>系统调用：由<strong>操作系统提供</strong>的，用于访问<strong>临界资源</strong>的一套接口如创建（退出）进程、访问系统资源（如文件、网络等）</p></li><li><p>Linux系统调用：由0x80中断完成，由各通用寄存器<u>传递系统调用参数</u></p></li><li><p>运行库与系统调用：运行库作为“中间层”，解决了系统调用<strong>跨平台</strong>不兼容的问题，<strong>简化</strong>了系统调用</p><p><strong>注意</strong>：运行库只能为各平台<strong>功能的交集</strong>提供中间层，无法完全维持各平台间的兼容性</p></li><li><p>特权级与中断：</p><ul><li><p>CPU的两种特权级：“用户模式”与“内核模式”，限制代码操作的权力</p></li><li><p>中断：由<u>用户态</u>切换到<u>内核态</u>的桥梁</p><ul><li><p>终端类型：硬件中断（如外设）与软件中断（如执行异常）</p></li><li><p>中断号：不同的中断拥有不同的中断号，用于查找对应的<strong>中断处理程序</strong></p></li><li><p>中断处理程序：由中断号索引，程序指针存于<strong>中断向量表</strong>中</p></li></ul><p><strong>注意</strong>：Linux下借助中断号0x80触发<strong>所有<u>系统调用</u></strong>，并通过<strong>寄存器eax</strong>获取对应系统调用号</p></li></ul><hr></li><li><p>Linux下基于int指令的系统调用：</p><ol type="1"><li><p>触发中断：执行内嵌汇编代码<code>int $0x80</code>保存现场，并切换到内核态，查找0x80号中断</p></li><li><p>切换堆栈：调用<strong>0x80</strong>中断，从用户栈切换至内核栈，再将esp等用户态的寄存器压入内核栈</p></li><li><p>执行中断处理程序：根据<strong>eax寄存器</strong>的值，在sys_call_table中查找对应的内核函数sys_*</p><figure style="text-align:center;"><p><img src="/2023/08/01/link_and_load/runtime-library/Linux系统调用流程.png"></p><figcaption><p>Linux系统调用流程图解</p></figcaption></figure><p><strong>注意</strong>：内核函数sys_*从<strong>内核栈</strong>上获取参数，其中各参数寄存器由<strong>宏SAVE_ALL</strong>压入内核栈中</p></li></ol><hr></li><li><p>Linux的新型系统调用</p><ul><li>系统调用的改进：<ul><li>改进前：基于int指令的系统调用在Pentium IV上表现不佳</li><li>改进后：PentiumII开始使用专门针对系统调用的指令<strong>sysenter</strong>和<strong>sysexit</strong></li></ul></li><li>虚拟动态共享库（VDSO）：用于<strong>支持新型系统调用</strong>，总是被加载到0xffffe000 上<ul><li>__kernel_vsyscall：位于VDSO中，负责新型系统调用，其地址为0xffffe400</li><li>sysenter：新型系统调用指令，位于函数 __kernel_vsyscall 中<ol type="1"><li>可直接跳转到<u>寄存器指定的函数</u>并执行</li><li>可自动实现<u>特权级切换</u>与<u>堆栈切换</u>等功能</li></ol></li></ul></li></ul><hr></li><li><p>Windows API：Windows系统提供的<strong>应用程序编程接口</strong></p><ul><li><p>系统服务与API：程序员无法像使用Linux那样直接使用系统调用，只能使用上层API<strong>注意</strong>：系统调用的一般流程为 <u>Application -&gt; CRT-&gt; (API) -&gt; Kernel</u></p></li><li><p>SDK ：Windows APIDLL导出函数声明的头文件、导出库、相关文件与工具的集合头文件windows.h中包含了Windows API中的核心部分</p></li><li><p>使用API的优势：</p><ul><li>屏蔽了不同平台下硬件结构的差异，确保了<strong>系统调用的正常执行</strong></li><li>为Windows各版本使用互不相同的内核提供了可能，极大程度实现了<strong>向后兼容</strong></li></ul><hr></li><li><p>Windows API的版本演进：Win16 -&gt; <strong>Win32</strong> -&gt;Win64，其中数字表示位数 Win32是应用最广泛最成熟的版本</p></li><li><p>Win32的主要功能类别：WindowsAPI是以<strong>DLL导出函数</strong>的形式暴露给开发者的</p><ol type="1"><li>基本服务（kernel32.dll）：包括文件系统、进程与内存管理等Windows的<strong>基本功能</strong></li><li>图形设备接口（gdi32.dll）：包括绘图、打印等<strong>与图形设备相关</strong>的功能</li><li>用户接口（user32.dll）：包括滚动条、按钮等<strong>与Windows窗口交互</strong>的操作</li><li>高级服务（advapi32.dll）：包括注册表、系统关闭重启、账号管理等额外功能</li><li>通用对话框（comdlg32.dll）：包括打印窗口、选择字体与颜色等功能</li><li>网络服务（ws2_32.dll）：包括Winsock、NetDDE等<strong>网络相关服务</strong><strong>...</strong></li></ol><p><strong>注意</strong>：在WindowsNT系列平台上，上述DLL还会依赖更底层的NTDLL.DLL</p></li><li><p>“银弹”：通过在软件体系结构中增加中间层以解决<strong>兼容性问题</strong>，如WindowsAPI</p></li></ul><hr></li><li><p>子系统：WindowsNT提供了<u>其它操作系统</u>的执行环境，以<strong>兼容它们的应用程序</strong>，如Win32子系统<br><strong>注意</strong>：API是架设在<u>应用层和内核</u>之间的中间层；子系统是架设在<u>应用层和API</u>之间的另一个中间层</p></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>link and load</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>『link and load-2』dynamic link</title>
    <link href="/2023/07/25/link_and_load/dynamic-link/"/>
    <url>/2023/07/25/link_and_load/dynamic-link/</url>
    
    <content type="html"><![CDATA[<h2 id="装载与动态链接">装载与动态链接</h2><h3 id="一可执行文件的装载与进程">一、可执行文件的装载与进程</h3><ul><li><p>进程虚拟地址空间：每个运行的程序拥有自己<strong>独立的虚拟地址空间</strong></p><p>在32位平台下：</p><ul><li>Linux：高1GB分给操作系统，低3GB分给用户程序</li><li>Windows：高2GB分给操作系统，低2GB分给用户程序</li></ul><p><strong>注意</strong>：<u>硬件位数</u>决定了<u>寻址空间的上限</u>：如32位的硬件平台决定了虚拟地址空间为0 ~ <span class="math inline">\(2^{32} - 1\)</span></p></li><li><p>PAE（Physical AddressExtension）：<strong>扩充硬件地址线</strong>，以扩展32位平台的物理寻址能力</p><ul><li>窗口映射：用某段虚拟空间作为<strong>窗口</strong>映射<strong>高于4GB</strong>的额外物理块<ul><li>Windows ：AWE机制（Address Windowing Extensions）</li><li>Linux ：采用<strong>系统调用</strong>mmap( )</li></ul></li></ul><hr></li><li><p>装载的方式：利用<strong>局部性原理</strong>，将程序<u>最常用的部分</u>驻留在物理内存中，其余的留在磁盘（动态装载）</p><ul><li><p>覆盖装入：通过<strong>覆盖管理器</strong>将程序切分为若干模块，使新调入的模块<strong>覆盖</strong>已在内存的模块</p><ul><li><p>覆盖规则：若模块A和模块B<strong>不会相互调用</strong>，两者就可能<strong>互相覆盖</strong></p></li><li><p>调用树：程序员将各模块按调用关系组织成<u>树结构</u>：</p><p><img src="/2023/07/25/link_and_load/dynamic-link/调用树.png" width="50%" height="50%"></p><p>当一个模块被调用时，务必保证从<strong>该模块到树根</strong>的所有模块都在内存中</p></li></ul><p><strong>禁止跨树调用</strong>，如模块C不可调用D、B、E、F</p><hr></li><li><p>页映射：虚拟存储机制的一部分，通过<strong>物理页映射与页调换</strong>解决物理内存不足的问题</p><ul><li>页面调换算法：如FIFO、LRU等</li></ul></li></ul><hr></li><li><p>可执行文件的装载：</p><ul><li><p>进程的建立：每个进程拥有<strong>独立的虚拟地址空间</strong></p><ol type="1"><li><p>创建独立的虚拟地址空间：建立<strong>页映射</strong>的数据结构（如页目录）</p><p><strong>注意</strong>：此时暂时不填写页映射关系，可以等到之后<strong>缺页</strong>时再逐步设置</p></li><li><p>建立<u>虚拟空间</u>与<u>可执行文件</u>的映射关系：设置<strong>VMA</strong>，即进程地址空间中的段空间VMA表示<u>虚拟地址</u>与<u>ELF中指定段的位置</u>间的关系（段表记录）</p><p><strong>注意</strong>：可执行文件需要被映射到虚拟空间，所以又称作<strong>映像文件</strong></p></li><li><p>CPU跳转到可执行文件的<strong>入口地址</strong>，启动运行</p></li></ol></li><li><p>页错误：进程建立完毕后，执行任务时出现<strong>缺页</strong>异常，页错误处理程序如下：</p><ol type="1"><li>查询<u>虚拟空间</u>与<u>可执行文件</u>之间的地址映射，找到<strong>空页面对应的VMA</strong></li><li>将对应的ELF文件数据<strong>调入物理内存</strong>，并建立虚拟页与新物理页之间的映射关系</li></ol></li></ul><hr></li><li><p>进程虚拟空间分布</p><ul><li><p>ELF文件的链接与执行视图：</p><p>“链接”视图：将ELF文件划分为多个段（Section）</p><p>“执行”视图：将ELF文件划分为多个程序头（Segment），每个<u>Segment</u>被映射到同一个<u>VMA</u></p></li><li><p>程序头表：可执行文件中保存装载信息，本质上是 Elf32_Phdr结构体数组</p></li><li><p>程序头（Elf32_Phdr）：将可执行文件中<strong>相同权限的Section</strong><u>合并至</u><strong>同一个Segment</strong>装载映射</p><ul><li>段类型（p_type）：共包含LOAD、DYNAMIC、INTERP等</li><li>段偏移（p_offset）：Segment在可执行文件中的<strong>偏移</strong></li><li>段虚拟地址（p_vaddr）：Segment在进程虚拟地址空间中的<strong>始址</strong></li><li>段物理地址（p_paddr）：一般与p_vaddr相同</li><li>段文件长度（p_filesz）：Segment<strong>在ELF文件</strong>中的长度（可能为0）</li><li>段长度（p_memse）：Segment<strong>在进程虚拟地址空间</strong>中的长度（可能为0）</li><li>段权限（p_flags）：Segment内共同的<strong>权限属性</strong>，如可读、可写、可执行</li><li>段对齐属性（p_align）：Segment 对齐字节为 2 ^ p_align</li></ul><p><strong>注意</strong>：p_memse可能大于p_filesz，多余的部分留给<strong>被合并的.bss段</strong>，初始化为全0</p><hr></li><li><p>堆与栈：堆一般是向上扩展的，栈是向下扩展的</p><ul><li><p>进程地址空间中的各VMA区域：</p><ol type="1"><li>代码 VMA：权限只读、可执行；含映像文件</li><li>数据 VMA：权限可读写、可执行；含映像文件</li><li>堆 VMA：权限可读写、可执行；无映像文件（匿名）</li><li>栈 VMA：权限可读写、不可执行；无映像文件（匿名）</li></ol><p><img src="/2023/07/25/link_and_load/dynamic-link/VMA.png" width="80%" height="80%"></p></li></ul><hr></li><li><p>段地址对齐（Segment）：段长往往不是页大小的整数倍，段地址往往不是页对齐的</p><ul><li><p>装载：通过<strong>虚拟内存页映射机制</strong>将可执行文件加载到进程地址空间</p></li><li><p>段合并：将ELF文件中各Segment间<strong>接壤</strong>的部分<strong>合并共享</strong>同一个物理页</p><p>装载时，将<strong>共享物理页</strong>分别映射到<strong><u>两个</u>虚拟页</strong>，其余物理页正常映射</p><p><strong>注意</strong>：段合并在逻辑上将可执行文件划分为<strong>以页为单位</strong>的若干个物理块，可以消去物理页碎片</p><p>一个物理页可能包含多个Segment的信息</p></li></ul><hr></li><li><p>进程栈的初始化</p><ul><li><p>栈空间布局：由esp指针指向栈顶</p><figure style="text-align:center;"><p><img src="/2023/07/25/link_and_load/dynamic-link/栈.png" width="80%" height="80%"></p><figcaption><p>栈空间图示</p></figcaption></figure><p>其中环境变量指PATH或HOME等</p></li><li><p>进程启动后，堆栈中的信息会传递给 main( )函数（即argc和argv）</p></li></ul><hr></li><li><p>Linux内核装载ELF文件：</p><ul><li><p>装载系统调用：int <strong>execve</strong>(const char* filename,char <em>const argv[ ], char </em>const envp[ ]);</p></li><li><p>装载流程：在进入execve( )系统调用后：</p><ol type="1"><li><p>execve( )调用sys_execve( )，sys_execve( )接着调用do_execve()</p></li><li><p>do_execve()读取ELF文件的前128字节，通过ELF文件头的<strong>魔数</strong>判断<strong>文件类型</strong></p><p>如ELF魔数为 <u>0x7F、e、l、f</u>；Java魔数为<u>c、a、f、e</u>；shell脚本魔数为 <u>#!</u></p></li><li><p>do_execve( )调用search_binary_handle()匹配合适的<strong>装载处理函数</strong></p><p>如ELF对应load_elf_binary( )；脚本文件对应load_script( )</p></li><li><p>对于load_elf_binary( )，依次执行以下步骤：</p></li><li><p>检查ELF格式<strong>有效性</strong>（如魔数）</p></li><li><p>寻找 .interp 段，设置<strong>动态链接路径</strong></p></li><li><p>根据ELF程序头表，对ELF的代码和数据进行<strong>映射</strong></p></li><li><p>初始化ELF进程环境，将<strong>系统调用的返回地址</strong>设置为ELF的<strong>e_entry</strong></p></li><li><p>系统调用返回至sys_execve()后，直接跳转到<strong>e_entry</strong></p></li></ol></li></ul><hr></li><li><p>Windows装载PE文件</p><ul><li><p>PE文件在内存中是<strong>页对齐</strong>的，各段的长度都是页大小的整数倍</p></li><li><p>目标地址（targetaddress）与相对虚拟地址（RVA）：分别指文件在虚存中的<strong>基地址</strong>，以及<strong>文件内偏移量</strong></p><p><strong>注意</strong>：由于PE文件<u>装载的<strong>基地址</strong>可能发生变化</u>，所以引入了RVA</p></li><li><p>装载流程：</p><ol type="1"><li>读取文件的<strong>第一页</strong>，即DOS头、PE头与段表</li><li>若进程地址空间中目标地址被占用，则要<strong>另选一个装载地址</strong></li><li>根据段表信息，将PE文件中的各段<strong>映射</strong>到虚存地址空间中</li><li>若装载地址不是目标地址，则进行<strong>Rebasing</strong></li><li>装载所有PE文件所需的<strong>DLL文件</strong></li><li>对PE文件中所有导入符号进行<strong>解析</strong></li><li>根据PE头中指定的参数，<strong>初始化栈和堆</strong>，最后<strong>启动进程</strong></li></ol></li><li><p>PE扩展头（PE OptionalHeader）：含有与<strong>装载</strong>相关的信息</p><ul><li>Image Base ：若该地址未被占用，则优先尝试将PE装载到该处</li><li>AddressOfEntryPoint：PE文件第一条运行指令的<strong>RVA</strong></li><li>SectionAlignment：段对齐粒度，一般即系统<strong>页大小</strong></li><li>SizeOfImage ：内存中经过节对齐的<strong>映像体大小</strong></li><li>SizeOfCode与SizeOfInitializedData：<strong>代码段长度</strong>与<strong>初始化的数据段长度</strong></li><li>BaseOfCode ：代码段始址的<strong>RVA</strong></li><li>BaseOfData ：数据段始址的<strong>RVA</strong></li></ul></li></ul></li></ul></li></ul><hr><h3 id="二动态链接">二、动态链接</h3><ul><li><p>动态链接的概念：与静态链接不同，动态链接等到<strong>程序开始运行时</strong>才将各目标文件进行链接</p></li><li><p>动态链接的应用：</p><ul><li>节省磁盘与内存空间：被多个程序共享的目标文件<strong>仅保留一个副本</strong>，通过复用共享节省空间</li><li>程序开发与发布：程序更新<u>不必发布完整的文件</u>，只需要发布已更新的目标文件即可</li><li>程序可扩展性和兼容性：<ol type="1"><li>扩展性：将程序模块做成<strong>插件</strong>，动态载入程序</li><li>兼容性：不同的平台提供<strong>相同的动态链接库</strong>，使程序可以运行在不同的平台上</li></ol></li></ul></li><li><p>动态链接文件：</p><ul><li>Linux ：动态共享对象（DSO），以“.so”为扩展名</li><li>Windows ：动态链接库（DLL），以“.dll”为扩展名</li></ul><p><strong>注意</strong>：在使用动态链接库时，程序被分成了<u>可执行模块</u>和<u>共享对象</u>两类<strong>模块</strong>；静态链接下可执行文件是一个<strong>整体</strong></p><p><u>与可执行文件不同，共享对象的最终装载地址在编译阶段是<strong>不确定</strong>的</u></p><p>C语言库的运行库glibc的<strong>动态链接形式</strong>为libc.so（整个系统唯一的副本）</p></li><li><p>动态链接器：</p><ul><li><p>链接规则：若引用符号来自<strong>静态目标文件</strong>，链接器会在链接时重定位</p><p>若引用符号来自<strong>动态共享对象</strong>，链接器会在<strong>装载时重定位</strong></p></li></ul><p><strong>注意</strong>：动态链接器也会被映射入进程地址空间，在程序运行前完成动态链接工作</p><hr></li><li><p>装载时重定位：链接时将所有对<strong>绝对地址的重定位</strong>延后到装载时完成</p><p>待装载的目标地址确定后，再根据文件中各符号的<strong>相对偏移量</strong>进行重定位</p><p><strong>注意</strong>：<u>装载时重定位比地址无关速度更快</u>（省去了计算间接跳转），但无法实现代码共享</p></li><li><p>地址无关代码（PIC）：共享对象中，将指令中<strong>需要修改的部分</strong>分离出来，与数据放在一起</p><ul><li><p>模块内部的函数调用：调用者与被调用者<strong>相对偏移</strong>保持不变，可以直接<strong>相对寻址</strong>，<u><strong>无需重定位</strong></u></p><p><strong>注意</strong>：其它模块可能<u>覆盖本模块的函数</u>，故实际上只能把同模块符号当作<strong>外部符号</strong>处理</p><p>可以考虑将同模块下的被调用函数设置为<strong>static</strong>的，保证其不被覆盖，无需重定位，可提高效率</p></li><li><p>模块内部的数据访问：访问指令（.text）和被访问数据（.data）的<strong>相对偏移</strong>保持不变：</p><ol type="1"><li>调用 __i686.get_pc_thunk.cx函数，获取<strong>当前访问指令的PC</strong>于 %ecx 寄存器</li><li>当前访问指令的地址 + <strong>相对偏移</strong> =被访问数据的地址</li></ol><p><strong>注意</strong>：由于共享目标的装载地址不确定，所以不能直接使用绝对地址访问时据</p></li><li><p>模块间的数据访问：将<u>地址相关</u>的部分放在<strong>数据段中的全局偏移表</strong>，实现代码地址无关</p><ul><li>全局偏移表（GOT）：指向外部变量的<strong>指针数组</strong>，装载时填写数组各表项</li><li>访问数据流程：GOT与访问代码的<strong>相对偏移</strong>保持不变<ol type="1"><li>根据当前访问指令PC和相对偏移求出<u>变量地址在GOT中的位置</u></li><li>根据<strong>对应表项中存放的变量地址</strong>访问数据（间接访问）</li></ol></li></ul></li><li><p>模块间的函数调用：与跨模块访问数据类似，同样使用GOT间接查找地址：</p><ol type="1"><li>根据当前访问指令PC和相对偏移求出<u>函数地址在GOT中的位置</u></li><li>根据<strong>对应表项中存放的函数地址</strong>跳转访问（间接跳转）</li></ol><p><strong>注意</strong>：共享对象中<strong>地址无关的代码段</strong>可由多个进程共享；共享对象中的<strong>数据段</strong>在多个进程中有独立副本</p><hr></li><li><p>-shared和-fPIC ：gcc的两个与动态链接有关的参数</p><ul><li>-shared：产生共享对象（如 .so）</li><li>-fPIC：指示GCC产生地址无关代码</li></ul></li></ul><hr></li><li><p>数据段的地址无关性</p><ul><li>方案：<strong>装载时重定位</strong>，即在共享对象装载时填补重定位入口</li><li>重定位表：记录共享对象的重定位入口信息</li></ul></li></ul><hr><h3 id="三延迟绑定">三、延迟绑定</h3><ul><li><p>延迟绑定的实现：将函数引用的链接延后，直到函数<strong>第一次被调用</strong>时才进行绑定（重定位）</p><p><strong>注意</strong>：延迟绑定可以防止<u>因函数引用过多</u>导致程序运行前<u>链接开销过大</u>，减缓性能</p></li><li><p>PLT （Procedure LinkageTable）：ELF中的GOT被拆分成两个独立的段，分别为.got和.got.plt</p><ul><li><p>.got保存<strong>外部变量引用</strong>的地址；.got.plt保存<strong>外部函数引用</strong>的地址</p></li><li><p>.got.plt的结构：</p><ol type="1"><li><p>Address of .dynamic：存放.dynamic段的地址</p></li><li><p>Module ID：本模块的ID，其地址位于 (GOT + 4)</p></li><li><p>_dl_runtime_resolve( )的地址：其地址位于 (GOT + 8)</p><p>_dl_runtime_resolve( )负责将函数地址填入.got.plt中的表项</p></li><li><p>其它外部函数引用的地址</p></li></ol></li><li><p>实现延迟绑定的流程，通过地址 bar@plt 实现间接跳转</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">PTL0:<br><span class="hljs-comment">/* 将本模块的ID压入 _dl_runtime_resolve() 的栈帧 */</span><br>push *(GOT + <span class="hljs-number">4</span>)<br><span class="hljs-comment">/* 跳转至 _dl_runtime_resolve() */</span><br>jmp *(GOT + <span class="hljs-number">8</span>)<br>...<br>    <br>bar@plt:<br><span class="hljs-comment">/* 目标模块第二次调用 bar@plt，会直接跳转到.got.plt中的正确地址 */</span><br>jmp *(bar@GOT)<br><span class="hljs-comment">/* 将外部函数引用在重定位表.rel.plt中的下标 n 压入 _dl_runtime_resolve() 的栈帧 */</span><br>push n<br><span class="hljs-comment">/* 目标模块第一次调用 bar@plt，会先跳转到 PLT0 进行延迟绑定 */</span><br>jmp PLT0<br>...<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="四动态链接的相关结构">四、动态链接的相关结构</h3><ul><li><p>“.interp”段：即解释器（interpreter），保存可执行文件的<strong>动态链接器的路径</strong></p></li><li><p>“.dynamic”段：保存动态链接器所需的信息，本质上是Elf32_Dyn结构的数组</p></li><li><p>Elf32_Dyn：属性值（d_tag） + 数值（d_val）或指针变量（d_ptr）</p><ul><li>属性值（d_tag）：<ul><li>DT_REL：动态链接<u><strong>重定位表</strong></u>的地址</li><li>DT_SYMTAB：动态链接<u><strong>符号表</strong></u>的地址，对应的d_ptr表示<strong>.dynsym的地址</strong></li><li>DT_STRTAB：动态链接<u><strong>字符串表</strong></u>的地址，对应的d_ptr表示<strong>.dynstr的地址</strong></li><li>DT_STRSZ：动态链接字符串表的大小，对应的d_val表示<strong>表大小</strong></li><li>DT_INIT：初始化代码地址</li><li>DT_NEED：依赖的共享对象文件，对应的d_ptr表示<strong>依赖文件名</strong></li></ul></li></ul></li><li><p>动态符号表（.dynsym）：仅保存与<strong>动态链接相关</strong>的符号，不包含内部私有符号</p></li><li><p>动态符号字符串表（.dynstr）：用于查找动态链接符号</p><p><strong>注意</strong>：<u>静态链接</u>下的符号表（.symtab）与字符串表（.strtab）包含了<strong>所有</strong>的符号信息（包括动态链接符号）</p></li><li><p>动态链接重定位表：确定<strong>动态导入符号</strong>的运行地址，包括符号名、重定位地址修正方式等信息</p><p><strong>注意</strong>：对于使用<u>地址无关技术</u>的ELF，由于<strong>数据段</strong>（含绝对地址）的存在，仍需要<strong>装载时重定位</strong></p><ul><li><p>.rel.dyn：对<strong>外部数据引用</strong>修正的重定位表，修正的位置位于<strong>.got及数据段</strong></p></li><li><p>.rel.plt：对<strong>外部函数引用</strong>修正的重定位表，修正的位置位于<strong>.got.plt</strong></p><hr></li><li><p>重定位地址修正方式：新增R_386_RELATIVE、R_386_GLOB_DAT、R_386_JUMP_SLOT重定位入口类型</p><ol type="1"><li>R_386_RELATIVE：装载目标基地址 +内部变量的偏移量，即<strong>基址重置</strong>（Rebasing）</li><li>R_386_GLOB_DAT：将<strong>变量</strong>绝对地址填入<strong>.got</strong>中的对应表项</li><li>R_386_JUMP_SLOT：将<strong>函数</strong>绝对地址填入<strong>.got.plt</strong>中的对应表项</li></ol></li></ul><hr></li><li><p>动态链接时进程堆栈初始化：保存<strong>动态链接器</strong>所需的辅助信息</p><ul><li><p>辅助信息数组（AuxiliaryVector）：<strong>存于栈中</strong>，本质上是一个Elf32_auxv_t结构体数组</p></li><li><p>Elf32_auxv_t：类型值（a_type）+ 属性值（a_val）</p><ul><li>类型值（a_type）：<ul><li>AT_NULL（0）：对应属性值为辅助信息数组的结束</li><li>AT_EXEFD（2）：可执行文件的<strong>文件句柄</strong>；动态链接器使用文件句柄访问文件</li><li>AT_PHDR（3）：可执行文件的<strong>程序头表</strong>；动态链接器也可通过内存映像访问文件</li><li>AT_PHENT（4）：对应属性值为程序头表中每个<strong>表项的大小</strong></li><li>AT_PHNUM（5）：对应属性值为程序头表中<strong>表项的数量</strong></li><li>AT_BASE（7）：对应属性值为<u>动态链接器的<strong>装载地址</strong></u></li><li>AT_ENTRY（9）：对应属性值为可执行文件的<strong>启动入口地址</strong></li></ul></li></ul><p><strong>注意</strong>：辅助信息存储在<u>栈中环境变量指针的上方，命令行信息的下方</u></p></li></ul></li></ul><hr><h3 id="五动态链接的步骤与实现三步走">五、动态链接的步骤与实现：“三步走”</h3><ul><li><p>动态链接器的自举（bootstrap）：</p><ul><li>自举：动态链接器的装载重定位工作不依赖于其它任何共享对象</li><li>自举流程：动态链接器<strong>独立完成</strong>其自身全局变量与静态变量的<strong>重定位</strong><ol type="1"><li>自举代码找到<strong>自己的GOT</strong>，再通过.got.plt的第一个表项找到.dynamic段的地址</li><li>通过.dynamic段可以找到动态链接器<u>自身的<strong>重定位表</strong>和<strong>符号表</strong></u>，并对自身执行重定位</li></ol></li></ul></li><li><p>装载共享对象：将共享对象的代码与数据映射到进程地址空间中</p><ul><li><p>符号的装填：将<strong>所有</strong>模块以及动态链接器的符号合并入<strong>全局符号表</strong></p><ol type="1"><li>动态链接器将<u>可执行文件和自身的符号表</u>合并入全局符号表</li><li>动态链接器根据.dynamic段中的DT_NEED项获得所有需要的共享对象</li><li>每装载一个新的共享对象，就会将其符号表合并入<strong>全局符号表</strong></li></ol><p><strong>注意</strong>：由于共享对象也可能依赖于共享对象，所以装载的过程实际可看作<strong>遍历图</strong>的过程</p></li><li><p>全局符号介入：对于多模块定义的<strong>同名符号</strong></p><p>若同名符号在<u>先前装载中已经加入全局符号表</u>，则后加入的符号<strong>被覆盖忽略</strong></p><p><strong>注意</strong>：“覆盖优先级”问题会引发<u>全局的同名函数</u>因被覆盖而失效</p></li></ul></li><li><p>重定位与初始化：自举、装载完毕后，动态链接器开始执行重定位操作</p><ul><li>重定位：动态链接器遍历所有可执行文件和共享对象的<strong>重定位表</strong>，修正它们的<strong>GOT</strong>表项</li><li>初始化：重定位完成后，执行每个共享对象的 <strong>.init</strong>段代码，进行初始化操作</li></ul><hr></li><li><p>Linux 动态链接器</p><ul><li><p>软链接：Linux动态链接器的路径/lib/ld-linux.so.2是软链接，指向了真正的链接/lib/ld-x.y.z.so</p></li><li><p>ld.so的运作流程：动态链接器本身是一种特殊的<strong>可执行文件</strong>，内核会为其安排一个合适的装载地址</p><ol type="1"><li>入口 _start 调用 _do_start( )函数独立进行重定位（即<strong>自举</strong>）</li><li>进入 _dl_main()，进行<strong>共享对象的装载</strong>、<strong>符号解析</strong>与<strong>重定位</strong>等多个任务</li></ol><p><strong>注意</strong>：动态链接器本身必须是<strong>静态链接</strong>（staticallylinked）的，不依赖于其它共享对象</p></li></ul></li></ul><hr><h3 id="六显式运行时链接">六、显式运行时链接</h3><ul><li><p>动态链接库：在程序<strong>运行时</strong>可以控制加载（或卸载）的共享对象</p><ul><li>动态库的装载：由<u>动态链接器</u>提供的API实现（以下四种）</li></ul><hr></li><li><p>dlopen()：<strong>打开并加载</strong>一个动态库到进程地址空间</p><ul><li><p>C函数原型：void* dlopen(const char* filename, int flag);</p></li><li><p>filename：动态库的路径（绝对路径 or 相对路径）</p><p><strong>注意</strong>：若该参数传入NULL，则会返回<strong>全局符号表</strong>的句柄</p></li><li><p>函数符号解析方式（flag）：延迟绑定（第一次调用才绑定）or加载时立即绑定</p></li><li><p>返回值：被加载模块的句柄，如加载失败则返回NULL</p></li></ul></li><li><p>dlsym( )：寻找所需要的符号</p><ul><li>C函数原型：void* dlsym(void* handle, char* symbol);</li><li>handle：由dlopen()打开的文件的句柄，若为NULL则在全局符号表中查找</li><li>symbol：被查找的字符串</li><li>返回值：若查找<strong>函数</strong>符号。则返回函数地址；若查找<strong>变量</strong>符号，则返回变量地址</li></ul></li><li><p>dlclose()：将已加载的模块卸载，取消进程地址空间于该模块间的映射关系</p><ul><li><p>加载引用计数器：调用dlopen()加载某模块时，计数器<u>自增</u>；调用dlclose()卸载某模块时，计数器<u>自减</u><br><u>计数器减至0时</u>，对应模块被真正卸载</p></li><li><p>C函数原型：int dlclose(void* handle);</p></li><li><p>handle：已打开模块的句柄</p></li><li><p>返回值：返回 0 表示成功关闭；返回非 0表示关闭出现错误，可通过dlerror( )捕获错误信息</p></li></ul></li><li><p>dlerror( )：在调用了dlopen( )，dlsym( )或dlclose()后，可通过调用dlerror( )判断是否<strong>调用成功</strong><br>调用成功返回NULL，调用错误则返回对应的<strong>报错信息</strong></p></li><li><p>C函数原型：char* dlerror(void);</p></li></ul><hr><h3 id="七linux共享库">七、Linux共享库</h3><ul><li><p>共享库的版本兼容性：</p><ul><li>共享库的版本更新：兼容更新（增量开发）&amp;不兼容更新（改变原版本）</li><li>改变C语言共享库ABI的行为<ol type="1"><li>导出函数的<strong>行为发生改变</strong>，其功能与旧版本的函数功能不一致</li><li>导出函数被<strong>删除</strong></li><li>导出数据的结构发生变化，如结构成员删除</li><li>导出函数的接口发生变化，如函数参数或函数返回值发生变化</li></ol></li></ul></li><li><p>共享库版本命名：libname.so<strong>.x.y.z</strong></p><ul><li>库名称：以“lib”为前缀开头，中间是库的名字name和后缀名.so</li><li>主版本号（x）：表示库的<strong>重大升级</strong>，不同主版本号间的共享库不兼容</li><li>次版本号（y）：表示库的<strong>增量升级</strong>，即在保持原有库不变的基础上增加新接口</li><li>发布版本号（z）：表示库的<strong>错误修正或性能改进</strong>，即不增不改</li></ul><p><strong>注意</strong>：依赖于<strong>旧的次版本号</strong>的共享库可以兼容<strong>新的次版本号</strong>的共享库，不同发布版本号的共享库之间都可以互相兼容</p></li><li><p>SO-NAME：把完整版本名的次版本号和发布版本号去掉，作为<strong>指向最新版本库</strong>的<strong>软连接</strong></p><p>ldconfig：当Linux系统安装或更新一个共享库时，就会使所有软连接指向最新版的共享库</p></li><li><p>次版本号交会问题：程序使用了高次版本号中的接口，而系统中只有低次版本号的共享库</p><hr></li><li><p>基于符号的版本机制：解决<u>次版本号交会问题</u></p><ul><li><p>Solaris中的符号版本机制</p><ul><li>符号版本脚本：实现了<strong>版本内部符号的定义</strong>与<strong>版本间符号的继承</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/* 定义符号SUNW_1.1 */</span><br>SUMW_1<span class="hljs-number">.1</span> &#123;<br>    global:<br>    global_symbol1;<br>    ...<br>    local:<br>    local_symbol1;<br>    ...<br>&#125;<br><span class="hljs-comment">/* SUNW_1.2 继承了 SUNW_1.1的所有符号 */</span><br>SUNW_1<span class="hljs-number">.2</span> &#123;<br>    global:<br>    global_symbol2;<br>    ...<br>    local:<br>    local_symbol2:<br>    ...<br>&#125; SUNW_1<span class="hljs-number">.1</span>;<br></code></pre></td></tr></table></figure><ul><li>范围机制：将共享库中的部分符号设置为<strong>local</strong>的，防止共享库的调用者使用这些局部函数</li><li>构建时，链接器可以记录最终输出文件中<strong>依赖的最低版本号</strong>对应的共享库<br>运行时，链接器会根据记录的最低版本号，检查当前共享库中的符号集合是否包含所需的版本</li></ul><hr></li><li><p>Linux中的符号版本机制</p><ul><li><p>GCC对Solaris符号版本机制的<u>两个扩展</u></p><ol type="1"><li><p>.symver汇编宏：对符号sym设置符号标签，如<code>.symver sym, sym@VERS_1.1</code></p></li><li><p>允许多个版本的同一符号处于<strong>同一个共享库</strong>中，如：</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 将sym的1.1版本导出为old_sym */</span><br><span class="hljs-keyword">asm</span>(<span class="hljs-string">&quot;.symver old_sym, sym@VERS_1.1&quot;</span>);<br><span class="hljs-comment">/* 将sym的1.2版本导出为new_sym */</span><br><span class="hljs-keyword">asm</span>(<span class="hljs-string">&quot;.symver new_sym, sym@VERS_1.2&quot;</span>);<br>...<br><span class="hljs-type">void</span> <span class="hljs-title function_">old_sym</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">new_sym</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><ul><li>符号重载：同一个符号可拥有不同的版本号，将共享库的更新粒度缩减为<strong>接口层面</strong><br>如使用1.1版本的sym就会链接old_sym()，使用1.2版本的sym就会链接new_sym( )</li></ul></li></ul></li></ul><hr></li><li><p>共享库系统路径</p><ul><li><p>File HierarchyStandard：规定了系统中系统文件应如何存放，促进了各开源系统间的<strong>兼容性</strong>FHS做出以下规定：</p><ol type="1"><li>/lib：存放最关键的<strong>基础共享库</strong>，如动态链接器、C语言运行库等</li><li>/usr/lib：存放非系统运行所需的关键性<strong>共享库</strong></li><li>/usr/local/lib：存放<strong>第三方应用程序</strong>的库，如python解释器</li></ol><p><strong>注意</strong>：共享库对应的可执行文件一般放在lib对应的<strong>bin目录</strong>下</p></li></ul></li><li><p>共享库的查找</p><ul><li><p>查找方式：根据.dynamic段中的<strong>DT_NEED项保存的路径</strong>搜索对应的共享库</p><ul><li>绝对路径：动态链接器直接按照该绝对路径查找</li><li>相对路径：动态链接器在/lib、/usr/lib、以及<u>/ld.so.conf配置文件指定的路径</u>中查找</li></ul></li><li><p>ldconfig ：该程序主要有两个用途</p><ul><li>调整SO_NAME：负责各共享库 SO_NAME 的创建、删除或更新</li><li>调整/etc/ld.so.cache：将各共享库的 SO_NAME收集起来，存放在<strong>缓存目录</strong> /ld.so.cache 中</li></ul><p><strong>注意</strong>：动态链接器的查找顺序为<strong>/etc/ld.so.cache</strong> <span class="math inline">\(\rightarrow\)</span> /usr/lib or /lib<br>/etc/ld.so.cache 缓存加快了动态链接器搜索共享库的速度</p></li></ul></li><li><p>环境变量：主要有以下三种</p><ul><li><p>LD_LIBRARY_PATH：存放<strong>若干个路径</strong>构成的环境变量，每个路径之间由冒号分割动态链接器会优先在该环境变量保存到路径中查找共享库（比/etc/ld.so.cache优先级更高）</p></li><li><p>LD_PRELOAD：在动态链接器开始装载共享库之前，会提前预装该环境变量中保存的共享库根据<strong>全局符号介入</strong>机制，预装共享库包含的符号可以覆盖所有后装载的符号</p><p><strong>注意</strong>：正常情况下不应使用LD_LIBRARY_PATH和LD_PRELOAD</p></li><li><p>LD_DEBUG：打开动态链接器的调试功能，根据<strong>不同参数</strong>打印链接信息：</p><ul><li><p>bindings：显示动态链接器的<strong>符号绑定</strong>过程</p></li><li><p>libs：显示<strong>共享库的查找</strong>过程</p></li><li><p>versions：显示各符号的<strong>版本依赖关系</strong></p></li><li><p>reloc：显示<strong>重定位</strong>过程</p></li><li><p>symbols：显示<strong>符号表查找</strong>过程</p><p><strong>...</strong></p></li></ul></li></ul></li></ul><hr><h3 id="八windows下的动态链接">八、Windows下的动态链接</h3><ul><li><p>基地址与RVA：对于可执行exe文件，ImageBase =0x400000；对于共享库dll文件，ImageBase = 0x10000000</p><p>RVA：相对基地址的偏移量</p><p><strong>注意</strong>：对于dll文件，如果其优先基地址已被占据，则PE装载器会选用其它空闲地址</p></li><li><p>导入与导出：DLL中需要<strong>显示</strong>地告诉编译器导出哪些符号；ELF中默认导出所有全局符号</p><ul><li>__declspec：用于指定变量或函数符号的<strong>导入或导出</strong><ol type="1"><li>__declspec(dllexport)：表示从本DLL导出的符号</li><li>__declspec(dllimport)：表示从其它DLL导入的符号</li></ol></li></ul></li><li><p>DLL显示<strong>运行时</strong>链接：Windows提供了3个支持运行时链接的API：</p><ul><li>LoadLibrary( )：装载一个DLL到进程的地址空间，与dlopen( )类似</li><li>GetProcAddress( )：在DLL中查找一个符号，与dlsym( )类似</li><li>FreeLibrary( )：卸载某个已经加载的模块，与dlclose( )类似</li></ul><hr></li><li><p>导出表（IMAGE_EXPORT_DIRECTORY）：PE文件头中DataDirectory数组的<strong>第一项</strong></p><ul><li>导出地址表（EAT）：存放各导出函数的<strong>RVA</strong></li><li>函数名表（Name Table）：存放各导出函数的<strong>名称</strong></li><li>序号表（Name-OrderedTable）：存放各导出函数<strong>名称对应的序号</strong></li></ul></li><li><p>序号：导出函数的序号 = 函数<strong>在EAT中的下标</strong> +1</p></li><li><p>导入符号流程：动态链接器需要查找导入符号的RVA</p><ol type="1"><li>模块A导入b.dll中的foo函数，并在A的导入表中记录函数名“foo”</li><li>动态链接时，动态链接器在b.dll的函数名表中查找“foo”，再根据<strong>序号表</strong>找到对应的序号</li><li>根据序号算出函数<strong>在EAT中的下标</strong>，从而获得其RVA</li></ol></li><li><p>EXP文件：链接器创建DLL的同时得到的<strong>临时文件</strong>，其中经过两遍扫描：</p><ol type="1"><li>第一遍：扫描并收集所有目标文件的<u>导出符号信息</u>，创建DLL导出表，并将导出表放入<strong>EXP文件</strong></li><li>第二遍：将EXP文件与其它目标文件链接在一起，输出为<strong>DLL文件的导出表</strong></li></ol></li><li><p>导出重定向：EAT中存的并不是函数的RVA，而是指向<strong>导出表</strong>中的某个字符串</p><p>该字符串是<u>符号重定向后</u>指向的“<strong>模块名 +函数名</strong>”</p></li><li><p>导入表：保存了模块使用的<u>来自DLL</u>的变量或函数信息，本质上是IMAGE_IMPORT_DESCRIPTOR结构数组<br1>数组元素结构如下：</br1></p><ul><li>FirstThunk：指向导入地址数组（IAT）</li><li>OriginalFirstThunk：指向导入名称表（INT）；INT是与IAT完全相同的副本</li></ul></li><li><p>导入地址数组（IAT）：每个表项对应一个<strong>被导入的符号</strong></p><ol type="1"><li>装载但未重定位时：表项元素值为对应<u>导入符号的序号或符号名</u></li><li>链接完成后：表项元素值改写为对应<u>导入符号的真正地址</u></li></ol><hr></li><li><p>重定基地址（Rebasing）：</p><ul><li>PE中的DLL代码段<strong>不是地址无关</strong>的，拥有<strong>固定的装载基地址</strong>0x10000000</li><li>装载时重定位：若DLL模块的目标地址被占用，系统会为其选择<strong>新的装载地址</strong>，对所有绝对地址重定位</li><li>改变默认基址：在装载前直接改变DLL的装载基地址</li><li>系统DLL：系统在进程中划出 0x70000000 ~ 0x80000000的区域映射常用的系统DLL，如kernel32.dll</li></ul><hr></li><li><p>导入函数绑定：在<u>符号解析与重定位之前</u>直接将外部函数的地址存入<strong>导入表</strong>中</p><ul><li>DLL绑定：遍历被绑定程序的导入表，将符号的<strong>目标地址</strong>写入被绑定程序的导入表（<strong>INT</strong>）内</li><li>绑定失效：符号绑定存在以下两种失效的可能：<ul><li>DLL更新：被依赖的DLL更新导致DLL的<strong>导出函数地址改变</strong></li><li>DLL装载时重定位：被依赖的DLL的<strong>装载地址与被绑定时不一致</strong></li></ul></li><li>绑定失效的解决方案：<ol type="1"><li>绑定时：将导入DLL的<u>时间戳（Timestamp）与校验和(Checksum)</u>存入被绑定文件的导入表中</li><li>装载时：确认被装载的DLL<strong>未被更新</strong>，且<strong>未发生装载时重定位</strong></li></ol></li></ul><hr></li><li><p>DLL HELL ：DLL版本不兼容问题</p><ul><li><p>DLL HELL发生的主要原因：</p><ul><li>应用程序安装时<u>新版本的DLL覆盖了旧版本的DLL</u>，导致只能依赖旧版本DLL的程序崩溃</li><li>新版本的DLL的安装引入了一个<u>新的BUG</u></li><li>DLL缺失或误删、操作系统更新<strong>...</strong></li></ul></li><li><p>DLL HELL解决方法：</p><ul><li>静态链接：通过<strong>静态链接</strong>的方法链接其所需要的所有库，避免使用DLL</li><li>防止DLL覆盖：Windows文件保护技术（WFP）可以阻止未授权的第三方应用覆盖系统DLL</li><li>解决DLL冲突：让每个程序拥有自己专门依赖的DLL，隔离不同版本的DLL</li></ul></li><li><p>.NET框架下DLL HELL解决方案：</p><ul><li><p>程序集：可执行文件集（.exe） or 库程序集（DLL动态链接库）</p></li><li><p>Manifest文件：描述程序集的<strong>清单文件</strong></p><ul><li><p>文件内容：程序集名称、版本号、成员列表、依赖资源等；&lt;XML&gt;格式</p></li><li><p>强文件名：系统类型 + 文件名 + 版本号 + 平台环境 + 公钥</p><p><strong>注意</strong>：强文件名允许<strong>不同版本的相同库共存</strong>而不发生冲突如目录下每个DLL都拥有以其强文件名命名的<strong>独立目录</strong></p></li></ul></li><li><p>SxSManager：并行（Side-By-Side）管理器，根据应用程序的<strong>manifest</strong>加载版本正确的DLL</p></li></ul><p><strong>注意</strong>：Manifest机制要求应用程序在系统中必须拥有与manifest中指定的<strong>完全相同的DLL</strong>包括版本一致、编译平台一致等</p></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>link and load</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>『link and load-1』static link</title>
    <link href="/2023/07/20/link_and_load/static-link/"/>
    <url>/2023/07/20/link_and_load/static-link/</url>
    
    <content type="html"><![CDATA[<h2 id="静态链接">静态链接</h2><h3 id="一编译与链接">一、编译与链接</h3><ul><li><p>GCC编译过程分解：</p><figure style="text-align:center;"><p><img src="/2023/07/20/link_and_load/static-link/编译过程分解.png" width="80%" height="80%"></p><figcaption><p>编译过程图示</p></figcaption></figure><hr></li><li><p>预编译：处理源代码文件中以“#”开头的<strong>预编译指令</strong></p><ol type="1"><li>展开所有的<strong>宏定义</strong> #define</li><li>处理所有的<strong>条件预编译</strong>指令，如#if、#ifdef、#elif、#endif 等</li><li><u>递归</u>处理<strong>预编译</strong>指令#include，将被包含文件插入到预编译指令的位置</li><li>删除所有<strong>注释</strong></li><li>添加<strong>行号信息</strong>和<strong>文件名标识</strong>，便于编译器产生调试所用的行号信息</li><li>保留所有的<strong>编译器指令</strong>#pragma（编译器之后会使用这些指令）</li></ol></li><li><p>编译：对预处理的文件进行<u>词法分析、语法分析、语义分析、指令优化</u>等操作，转化为<strong>汇编代码</strong></p><p>Linux下C语言的编译程序是cc1、C++是cc1plus、Java是jc1</p><p><strong>注意</strong>：gcc只是<u>多个后台命令的包装</u>，会根据<strong>传入参数</strong>调用编译程序cc1，汇编器as或链接器ld</p></li><li><p>汇编：将汇编代码转变为<strong>机器可执行</strong>的命令（即翻译）</p></li><li><p>链接：将每个源代码模块独立地编译，再将各模块正确地衔接</p><hr></li><li><p>静态链接：地址和空间分配 + 符号决议 + 重定位</p><ul><li>重定位：链接时将<strong>跨模块调用</strong>的地址补充完整（填补之前地址一般为0）</li></ul></li></ul><hr><h3 id="二目标文件">二、目标文件</h3><ul><li><p>可执行文件格式：<u>Portable Executable</u> (Windows) +<u>Executable Linkable Format</u> (ELF)</p><p>动态链接库（DLL）和静态链接库（SLL）也可以按可执行文件格式存储</p><table><thead><tr class="header"><th style="text-align: center;">ELF文件格式</th><th style="text-align: center;">描述</th><th style="text-align: center;">实例</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">可重定位文件</td><td style="text-align: center;">包含代码和数据，可<strong>链接</strong>成可执行文件</td><td style="text-align: center;">Linux的.o &amp; Windows的.obj</td></tr><tr class="even"><td style="text-align: center;">可执行文件</td><td style="text-align: center;">可以<strong>直接执行</strong>的程序</td><td style="text-align: center;">Linux的/bin/bash &amp;Windows的.exe</td></tr><tr class="odd"><td style="text-align: center;">共享目标文件</td><td style="text-align: center;">能与其它可<strong>重定位文件</strong>链接成新的目标文件，或与其它<strong>可执行文件</strong>链接成新的进程映像文件</td><td style="text-align: center;">Linux的.so &amp; Windows的DLL</td></tr><tr class="even"><td style="text-align: center;">核心转储文件</td><td style="text-align: center;">进程<u>意外终止</u>时可将其地址空间内容转储到核心转储文件</td><td style="text-align: center;">Linux下的core dump</td></tr></tbody></table></li><li><p>目标文件格式：按文件信息的不同属性分为“段”或“节”（表示一定长度）</p><ul><li><p>ELF文件头：描述了整个文件的信息，以及段表</p></li><li><p>代码段（.code &amp;.text）：存放编译后的<strong>机器指令</strong></p></li><li><p>数据段（.data）：存放<u>初始化</u>的<strong>全局变量</strong>和<strong>局部静态变量</strong></p></li><li><p>只读数据段（.rodata）：存放只读数据（如<u>const</u>修饰的变量或<u>字符串常量</u>）</p></li><li><p>.bss段：预留<u>未初始化</u>的<strong>全局变量</strong>和<strong>局部静态变量</strong>的位置（本身无数据）</p></li><li><p>.comment段：存放编译器版本信息</p></li><li><p>.dynamic段：动态链接信息</p><p><strong>...</strong></p><p><strong>注意</strong>：段名都以“.”作为前缀，表示<strong>系统保留字</strong>；应用程序的<u>自定义段名</u>不能用“.”作为前缀</p></li></ul></li><li><p>文件分段的好处：为何要将指令（.text +.code）和数据段（.data）分离？</p><ul><li>指令一般是<strong>只读的</strong>，数据一般是<strong>可写的</strong>，便于分别设置权限</li><li>现代CPU一般都有<u>指令cache</u>和<u>数据cache</u>，将指令和数据分离有助于提高缓存命中率</li><li>作为只读区域，指令便于共享，可以节省空间</li></ul></li><li><p>自定义段：可以指定变量所处的段，如利用gcc扩展机制，可将变量var放入<u>自定义的name段</u></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">__attribute__((section(<span class="hljs-string">&quot;name&quot;</span>))) <span class="hljs-type">int</span> var = <span class="hljs-number">1</span>;<br>__attribute__((section(<span class="hljs-string">&quot;func&quot;</span>))) <span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;&#125;<br></code></pre></td></tr></table></figure><hr></li><li><p>ELF文件结构：可使用binutils中的readelf命令查看ELF文件</p><ul><li><p>文件头（Elf32_Ehdr）：包括ELF魔数、机器字节长度、运行平台，程序入口与长度等信息</p><ul><li><p>ELF魔数（16位）：<strong>前四个字节相同</strong>，为0x7f、0x45、0x4c、0x46，分别表示DEL、E、L、F</p><p>第5个字节标识文件类型：0x01表示32位、0x02表示64位</p><p>第6个字节标识字节序：0x01表示小端、0x02表示大端</p></li><li><p>文件类型（e_type）：ET_REL指可重定位、ET_EXEC指可执行、ET_DTN指共享目标文件</p></li><li><p>机器类型（e_machine）：如EM_386表示文件可以在Intelx86机器上运行</p><p><strong>注意</strong>：不同机器上的ELF文件都遵循<u>同一套ELF标准</u></p></li><li><p>程序虚拟入口（e_entry）：进程开始执行的指令虚拟地址；可重定位文件的入口一般设0</p><p><strong>...</strong></p></li></ul><p><strong>注意</strong>：ELF头中使用了typedef定义了自定义变量体系，使得在不同编译环境下都有<strong>相同的字段长度</strong></p><p>如Elf32_Addr类型表示原始的uint32_t类型（4字节）；Elf32_Half表示原始的uint16_t类型（2字节）</p></li><li><p>段表：保存各段的基本属性（段名、段长、段偏移等），<u>ELF头的e_shoff指明了段表在ELF文件的位置</u></p><p>段表本质上是一个以Elf32_Shdr结构体为元素的<strong>数组</strong>；Elf32_Shdr结构称作<strong>段描述符</strong>，<u>对应了一个段</u></p><p>ELF头的e_shnum表示ELF中拥有的<strong>段数量</strong>，即段表内的元素个数</p></li><li><p>段描述符：即Elf32_Shdr结构体</p><ul><li><p>段名（sh_name）：一个指向“.shstrtab”字符串表的<strong>偏移量</strong>（注意是<strong>段表</strong>字符串表）</p></li><li><p>段类型（sh_type）：以关键字“SHT”开头，如代码段和数据段的类型都是SHT_PROGBITS.hash段的段类型为SHT_HASH；.bss段的段类型为SHT_NOBITS等</p><p><strong>注意</strong>：段名（像.text）并不能真正表示段的类型</p></li><li><p>段的标志位（sh_flag）：以关键字“SHF”开头，表示段在<u>进程虚拟地址空间中的属性</u>SHF_WRITE指该段<strong>可写</strong>、SHF_ALLOC指需要在进程地址空间中为该段<strong>分配空间</strong>（如.data、.text、<strong>.bss</strong>）、SHF_EXECINSTR指可执行代码（如.text）</p><p><strong>注意</strong>：只有<u>段类型</u>和<u>段标志位</u>对操作系统是有意义的，段名只对编译器和链接器有意义</p></li><li><p>段的链接信息（sh_link、sh_info）：标明<strong>与链接相关</strong>的段的信息，如SH_REL段（重定位表）</p></li><li><p>段偏移（sh_offset）与段地址（sh_addr）：分别表示该段在ELF文件中位置的<strong>偏移</strong>；段在<strong>进程虚拟地址空间中的虚拟地址</strong></p></li><li><p>段地址对齐（sh_addralign）：<strong>对齐</strong>的段地址需满足sh_addr % (2 ^ addralign) = 0 若无需对齐，sh_addralign取0或1</p></li></ul></li><li><p>重定位表（.rel.xxx）：包含<strong>对应段xxx</strong>在<strong>链接过程</strong>中的重定位信息，用于填补目标文件中的<u>绝对地址引用</u>；一张<u>重定位表</u>也是ELF文件中的<u>一个段</u></p></li><li><p>字符串表（.strtab）与段表字符串表（.shstrtab）：保存ELF文件中符号的集合</p><ul><li><p>字符串表：保存ELF文件中普通的字符串</p></li><li><p>段表字符串表：保存<strong>段表</strong>中用到的字符串（如段名)</p><p><strong>注意</strong>：ELF头中的e_shoff表示段表位置；e_shstrndx表示.shstrtab段<u>在段表中对应的下标</u><br>我们使用字符串<strong>在字符串表中的<u>下标</u></strong>来引用对应的符号</p></li></ul></li></ul><hr></li><li><p>符号：链接的接口</p><ul><li><p>定义与引用：设目标文件B使用了目标文件A中的函数foo目标文件A定义了函数foo 目标文件B引用了函数foo</p></li><li><p>符号与符号值：“符号”指函数或变量，“符号值”一般指函数或变量的地址</p><ul><li><strong>全局符号</strong>：<strong>定义在本目标文件</strong>的全局符号，<u>可被其它目标文件引用</u></li><li><strong>外部符号</strong>：<strong>在本目标文件中引用</strong>的全局符号，<u>但没定义在本目标文件</u></li><li>段名：其值是<u>段的起始地址</u>（如.text）</li><li>局部符号：不可被外部链接的符号（如static修饰的符号）</li><li>行号信息：<u>目标文件指令</u>和<u>源代码</u>间<strong>行的对应关系</strong></li></ul></li><li><p>ELF符号表结构：符号表本身是一个<strong>段</strong>，段名为.symtab</p><p>符号表是一个元素为结构体Elf32_Sym的<strong>数组</strong>（其首元素总是未定义的）</p></li><li><p>符号结构体：对应于ELF文件中的符号</p><ul><li><p>符号名（st_name）：一个指向该符号<strong>在字符串表中的下标</strong></p></li><li><p>符号所在段（st_shndx）：对于变量或函数的<strong>定义</strong>，其表示<strong>符号所在段在段表中的<u>下标</u></strong>，特殊情况下：</p><ul><li>SHN_ABS：绝对的值，如ELF文件名</li><li>SHN_COMMON：表示<strong>COMMON块类型</strong>的符号，如<u>未初始化的全局变量</u></li><li>SHN_UNDEF（0）：表示该符号未定义，如<strong>被引用</strong>的符号</li></ul></li><li><p>符号值（st_value）：对于变量和函数的<strong>定义</strong>，其值是该符号的<strong>地址</strong>，具体讨论如下：</p><ul><li>在本目标文件定义的非COMMON块符号，其值是st_shndx<strong>指定段中的偏移量</strong></li><li>目标文件中的COMMON块符号，st_value表示该符号的<strong>对齐属性</strong></li><li>在可执行文件中，st_value是<strong>虚拟地址</strong></li></ul></li><li><p>符号类型与绑定信息（st_info）：低4位表符号类型，高28位表绑定信息</p><ul><li>符号类型：以“STT”关键字开头，如： STT_OBJECT：指变量或数组STT_FUNC：指函数或可执行代码STT_SECTION：表示一个段（其符号总是STB_LOCAL）STT_FILE：表示源文件名（其符号总是STB_LOCAL的，其st_shndx总是SHN_ABS）</li><li>符号绑定信息：以“STB”关键字开头，如：<br>STB_LOCAL：指外部不可见的<strong>局部变量</strong><br>STB_GLOBAL：指外部可见的<strong>全局变量</strong></li></ul></li></ul><hr></li><li><p>特殊符号：被定义在ld链接器的链接脚本中，可在程序中直接声明引用；以下特殊符号均表示<strong>虚拟地址</strong></p><ul><li>__executable_start：程序起始地址（而非入口地址）</li><li>__extext：<strong>代码段</strong>结束地址</li><li>_edata：<strong>数据段</strong>结束地址</li><li>_end：程序结束地址</li></ul><hr></li><li><p>符号修饰与函数签名：</p><ul><li><p>符号修饰：修饰原始的符号名，防止<strong>同名</strong>函数冲突（_Z）</p></li><li><p>函数签名：函数名 + 参数类型 + 所在命名空间（或类）</p><p><strong>注意</strong>：函数签名指向了<strong>唯一的函数</strong></p></li><li><p>extern"C"：在C++中声明一个代码块，将代码块中的代码按C语言代码处理</p></li></ul><hr></li><li><p>弱符号与强符号：仅讨论<strong>定义</strong>（而非引用）的符号<strong>初始化</strong>的全局变量称为强符号，<strong>未初始化</strong>的全局变量为弱符号链接时选择<strong>多次定义</strong>的强弱符号遵循以下规则：</p><ul><li>不同的目标文件中<strong>不能有同名</strong>的强符号（否则链接器会报重复定义错误）</li><li>若某个符号<u>在某个目标文件中是强符号</u>，在其它文件中都是弱符号，则链接时<strong>选择强符号</strong></li><li>若某个符号<u>在所有目标文件中都是弱符号</u>，则选择<strong>占用空间最大</strong>的弱符号</li></ul><p><strong>注意</strong>：可以使用__attribute__((weak)) var = 1将强符号var转化为弱符号</p></li><li><p>弱引用与强引用：链接器需要针对所有的<strong>外部引用符号</strong>找到其<strong>符号定义</strong></p><ul><li>强引用：引用的外部符号在链接时<u>未找到定义则<strong>报错</strong></u></li><li>弱引用：引用的外部符号若<u>被定义则根据其符号规则决议</u>；若<u>未被定义也<strong>不报错</strong></u>，为其分配一个特殊值</li></ul></li><li><p>弱符号与弱引用的用途：</p><ul><li>用户自定义的强符号可以覆盖标准库的弱符号</li><li>将对扩展模块的引用声明为弱引用，便于<u>扩展模块的装卸</u></li></ul><p><strong>注意</strong>：可以使用 __attribute__((weakref)) void foo();将外部引用的函数转为弱引用</p></li></ul><hr></li><li><p>调试信息：包括源代码映射、堆栈跟踪信息、函数参数或局部变量等</p><ul><li><p>调试：设置断点、监视变量变化、单步行进等</p></li><li><p>调试前提：编译器记录了<u>源代码</u>和<u>目标代码</u>间的关系</p></li><li><p>在目标文件中<strong>添加</strong>调试信息：“-g”参数；<strong>删除</strong>目标文件中的调试信息：“strip”命令</p><p><strong>注意</strong>：调试信息占用空间很大且对用户无用处，应该在发布前被删除</p></li></ul></li></ul><hr><h3 id="三静态链接">三、静态链接</h3><ul><li><p>空间与地址分配：将多个目标文件合并为一个输出文件，并为其分配空间</p><ul><li><p>按序叠加：直接将多个目标文件按次序合并，非常浪费空间</p></li><li><p><strong>相似段合并</strong>：将各目标文件中<strong>相同的段</strong>合并为一个段，一般分两步：</p><ol type="1"><li>空间与地址分配：获得各输入文件的段长度，合并后计算各段合并后的长度与地址</li><li>符号解析与<strong>重定位</strong>：读取输入文件中的重定位信息，解析符号、调整代码地址、进行重定位</li></ol><p><strong>注意</strong>：各段合并后（链接后）所使用的地址是<strong>进程中的虚拟地址</strong></p><hr></li><li><p>确定<strong>符号</strong>地址：这里指加载到进程地址空间中的虚拟地址</p><ol type="1"><li>第一步：确定合并后<strong>各段的起始虚拟地址</strong></li><li>第二步：根据各符号于其所在段的<strong>偏移量</strong>，通过<u>叠加段始址</u>计算各符号的虚拟地址</li></ol></li></ul><hr></li><li><p>符号解析与重定位：</p><ul><li><p>重定位：填补本目标文件中<strong>外部引用的地址</strong></p></li><li><p>重定位表：保存<strong>有关重定位信息</strong>的表，专门占有一个段“.rel.xxx”重定位表项是元素类型为Elf32_Rel结构的数组，一个<u>结构体元素</u>对应一个<u>重定位入口</u></p><ul><li>重定位入口：指代码中需要被重定位的位置，其包含的外部引用地址将会被填补</li><li>重定位入口的偏移（r_offset）：0x04: call &lt;addr&gt; EC<strong>00</strong> 00 00 00 <span class="math inline">\(\rightarrow\)</span> r_offset = 0x05<ol type="1"><li>可重定位文件：代表<u>待修正地址</u>的<strong>首字节</strong>相对<strong>段始址</strong>的偏移数</li><li>可执行文件：代表<u>待修正地址</u>的<strong>首字节</strong>的<strong>虚拟地址</strong></li></ol></li><li>重定位入口的类型与符号（r_info）：<ol type="1"><li>低8位：表示重定位入口<strong>类型</strong></li><li>高24位：表示重定位入口的符号<strong>在符号表中的下标</strong></li></ol></li></ul><hr></li><li><p>符号解析：全局<u>undefined</u>的符号（即外部引用）应当于链接后在<strong>全局符号表</strong>中找到，否则会报<strong>未定义错误</strong></p><hr></li><li><p>指令修正方式：<strong>链接完成后</strong>，修正<u>重定位入口</u>中包含的地址，以x86_32为例：</p><ul><li><p>绝对寻址（mov）：直接根据<strong>实际虚拟地址</strong>取值</p></li><li><p>绝对寻址修正（R_386_32）：<strong>符号实际虚拟地址</strong> +<strong>待修正位置的值</strong></p><hr></li><li><p>相对寻址（call）：<strong>实际虚拟地址</strong>（即跳转地址） =call的<strong>下一条指令</strong>地址 +<strong>相对地址</strong></p></li><li><p>相对寻址修正（R_386_PC32）：<strong>符号实际虚拟地址</strong> +<strong>待修正位置的值</strong> - <strong>被修正位置</strong>的虚址</p><p><strong>注意</strong>：<u>绝对修正</u>后的地址即为<strong>实际地址</strong>；<u>相对修正</u>后的地址为符号位置离被修正位置的<strong>地址差</strong></p><p>特别注意“被修正位置”指的是<strong>待填写地址首字节</strong>的位置，而不是所在指令的首地址</p></li></ul></li></ul><figure style="text-align:center;"><p><img src="/2023/07/20/link_and_load/static-link/表间关系.png" width="80%" height="80%"></p><figcaption><p>各表间关系图示</p></figcaption></figure><hr></li><li><p>COMMON块</p><ul><li><p>未初始化的全局变量：链接前不分配段空间，并标记为<strong>SHN_COMMON</strong></p><p>不把未初始化的全局变量<u>直接分配在目标文件.bss段</u>的原因：</p><p>未初始化的全局变量是<strong>弱符号</strong>，链接前不知道各目标文件<strong>同名弱符号的相对大小</strong>；链接器选出了<strong>最大的弱符号</strong>后，才可将其分配在输出文件的.bss段中</p><p><strong>注意</strong>：链接时不允许有弱符号的大小大于强符号，否则会报错</p></li></ul><hr></li><li><p>API与ABI：</p><ul><li><p>API：<strong>源代码级别</strong>的接口，遵循相同API标准的系统拥有相同的接口函数原型</p></li><li><p>ABI：<strong>二进制层面</strong>的接口，涉及内存分布、函数调用方式、寄存器使用约定等问题，比API更严格</p><p><strong>注意</strong>：即便API相同，ABI也不一定相同；硬件、编程语言、编译器、操作系统都可能影响ABI</p></li></ul></li></ul><hr><ul><li><p>静态库链接</p><ul><li><p>静态库：一组<strong>目标文件</strong>的压缩集合，一个<u>目标文件</u>包含一个<u>函数</u>（节省空间、便于管理）</p></li><li><p>glibc：GNU发布的libc库，glibc是Linux系统中最底层的<strong>API</strong></p></li><li><p>libc.a：Linux中最常用的C语言静态库文件，是glibc项目的一部分，共包含1400个目标文件</p><p>如何使用静态库函数？将<strong>源目标文件</strong>和<strong>libc.a</strong>链接即可</p></li></ul><hr></li><li><p>链接过程控制：</p><ul><li><p>如何控制连接过程？</p><ul><li>为链接器ld传递参数</li><li>将链接指令放在目标文件中（如COFF中的.drectve段）</li><li>使用<strong>链接控制脚本</strong></li></ul></li><li><p>链接脚本：默认链接脚本存放在/usr/lib/ldscripts路径下，负责<strong>指示链接器ld如何进行链接</strong></p><p>ld会根据<strong>命令行要求</strong>使用相应的链接脚本文件控制连接过程：</p><ul><li>elf_i386.x：生成<u>可执行文件</u>的链接脚本</li><li>elf_i386.xs：生成<u>共享目标文件</u>的链接脚本</li><li>自定义脚本：使用ld命令的 “<strong>-T</strong>” 参数指定自定义的.lds</li></ul></li><li><p>ld链接脚本的使用：<strong>输入</strong>目标文件和库文件，<strong>输出</strong>可执行文件</p><ul><li><p>链接脚本<strong>扩展名</strong>：.lds</p></li><li><p>链接脚本语法：由一系列<u>命令语句 + 赋值语句</u>组成</p><ul><li><p>赋值语句：点符号 <strong>.</strong>表示<strong>当前虚拟地址</strong>，指定后续输出段的始址</p></li><li><p>ENTRY(symbol)：指定符号symbol的值作为<strong>入口虚拟地址</strong>，指定入口的优先级：</p><ol type="1"><li>ld命令行的 <strong>-e</strong> 选项</li><li>链接脚本中存在命令语句<strong>ENTRY(symbol)</strong></li><li>若定义了**_start** 符号，则使用符号 _start 的值</li><li>若存在 <strong>.text</strong> 段，则使用.text段的首字节地址</li><li>使用<strong>默认值0</strong></li></ol></li><li><p>STARTUP(filename)：将文件filename作为链接中的<strong>第一个输入文件</strong></p></li><li><p>SEARCH_DIR(path)：将路径path加入到ld链接器中的<strong>库查找目录</strong>（以寻找对应库）</p></li><li><p>INPUT(file1, file2,...)：指定若干文件作为<strong>链接输入</strong></p></li><li><p>INCLUDE filename：将文件filename包含入本链接脚本</p></li><li><p>PROVIDE(symbol)：在链接脚本中<strong>定义符号</strong>，如特殊符号__executable_start</p><hr></li><li><p>SECTIONS命令语句：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">SECTIONS<br>&#123;<br>    ...<br>     <span class="hljs-comment">/* secname 表示输出段的段名 */</span><br>     <span class="hljs-comment">/* contents 表示若干个输出段应符合的条件 */</span><br>     secname : &#123; contents &#125;<br>    ...<br>     <span class="hljs-comment">/* DISCARD 段表示丢弃符合条件的输入文件，不作链接 */</span><br>     /DISCARD/ : &#123; contents &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><pre><code class="hljs">      下面是规则**contents**的语法示例：将**符合条件**的所有段**合并为输出段secname**</code></pre><ul><li>file1.o(.data)：输入文件file1.o中的.data段符合条件</li><li>file1.o(.data, .rodata)：输入文件file1.o中的.data 或.rodata段符合条件</li><li>file1.o：输入文件file1.o的<strong>所有段</strong>都符合条件</li><li>*(.data)：表示所有输入文件的.data段都符合条件</li></ul></li></ul><p><strong>注意</strong>：ld链接脚本的语法风格类似C语言，且支持<strong>正则表达式</strong>匹配</p><hr></li><li><p>BFD库（Binary File DescriptorLibrary）：通过<strong>统一的接口</strong>处理<strong>不同的目标文件格式</strong></p><ul><li>BFD库的目的：解决<u>不同硬件/软件平台</u>下目标文件格式的差异</li><li>BFD库的优势：将编译器和链接器本身与目标文件<strong>隔离</strong>，便于扩展支持新的目标文件格式</li><li>BFD库的使用：安装BFD开发库后，#include "BFD.h"</li></ul></li></ul></li></ul><hr><h3 id="四windows-pecoff">四、Windows PE/COFF</h3><ul><li><p>PE与COFF：</p><p>“PE”（PortableExecutable）：<u>微软</u>引入的一种<strong>可执行文件</strong>格式（Win32平台）</p><p>“COFF”（Common Object FileFormat）：PE格式（Windows）和ELF格式（Linux格式）的<strong>共同起源</strong></p><p><strong>注意</strong>：PE/COFF格式同样以<strong>段</strong>的格式组织，代码段为.code、数据段为.data</p></li><li><p>Microsoft VisualC++编译环境：编译器cl（compiler）、链接器（link），可执行文件查看器（dumpbin）</p><hr></li><li><p>COFF文件结构：文件头 + 若干个段</p><ul><li><p>文件头：映像头 + 段表</p><ul><li><p>映像头（IMAGE_FILE_HEADER）：与Elf32_Ehdr的作用类似</p><ul><li>Machine：目标机器类型，如x86、ARM等</li><li>NumberOfSections：目标文件中段的数量</li><li>TimeDateStamp ：PE文件的创建时间</li><li>PointerToSymbolTable：符号表在PE文件中的偏移</li></ul><hr></li><li><p>段表：记录每个段的信息，是一个IMAGE_SECTION_HEADER结构的数组</p></li><li><p>段表项（IMAGE_SECTION_HEADER）：一个<u>段表项</u>对应一个<u>段</u></p><ul><li>VirtualSize：该段被加载到内存后的<strong>大小</strong></li><li>VirtualAddress：该段被加载到内存后的<strong>虚拟地址</strong></li><li>SizeOfRawData：该段<strong>在文件中的大小</strong>（由于.bss段的存在，SizeOfRawData不一定与VirtualSize相等）</li><li>Characteristics：段的<strong>属性</strong>，如段类型、对齐方式、读写权限等</li></ul></li></ul><hr></li><li><p>段：COFF各段的存储方式和内容与ELF几乎相同，新增了“.drectve”段和“.debug$...”段</p></li><li><p>.drectve段：包含了编译器向链接器<strong>传递的链接指令</strong></p></li><li><p>.debug$段：以“.debug$”关键字开头的段，如：</p><ul><li>.debug$S：表示<strong>符号</strong>相关的调试信息段</li><li>.debug$P；表示<strong>预编译头文件</strong>的调试信息段</li><li>.debug$T：表示包含<strong>类型</strong>相关的调试信息段</li></ul><p><strong>注意</strong>：.drectve段和.debug$段的文件数据都位于SECTIONHEADER下方的RAW DATA中</p><hr></li><li><p>符号表：与ELF文件符号表类似，包含符号名、符号类型、是否可外部链接等信息</p></li></ul><hr></li><li><p>PE文件结构：基于COFF的扩展</p><ul><li><p>DOSMZ可执行文件格式的文件头和桩代码：Windows为<u>适应传统的DOS</u>而扩展的文件头DOS桩代码的<u>唯一功能</u>是向终端输出“当前文件无法在DOS上运行”的信息</p></li><li><p>IMAGE_NT_HEADERS：PE文件头，在COFF的IMAGE_FILE_HEADER基础上<strong>新增了PE扩展头部</strong></p><ul><li>标记：常量值0x00004550（即'P'、'E'、'\0'、'\0'）</li><li>映像头（IMAGE_FILE_HEADER）：即原先COFF中的映像头</li><li>PE扩展头部（IMAGE_OPTIONAL_HEADER）：包括数据目录、导入导出表、重定位表等</li></ul></li><li><p>PE数据目录（IMAGE_DATA_DIRECTORY[]）：PE扩展头部的成员结构，名称为DateDirectory的<strong>数组</strong></p><ul><li>虚拟地址（VirtualAddress）：PE文件的装载虚拟地址</li><li>长度（Size）：PE文件装载所占内存大小</li></ul><p><strong>注意</strong>：DateDirectory元素中的各<u>表项</u>对应一个<u>表的地址和大小信息</u>（如导出表、重定位表等）</p></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>link and load</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>『machine learning-2』model selection and evaluation</title>
    <link href="/2023/07/20/machine_learning/model-selection-and-evaluation/"/>
    <url>/2023/07/20/machine_learning/model-selection-and-evaluation/</url>
    
    <content type="html"><![CDATA[<h2 id="模型评估与选择">模型评估与选择</h2><h3 id="一误差">一、误差</h3><ul><li><p>误差：学习器<strong>实际预测输出</strong>与<strong>样本真实输出</strong>之间的差异</p></li><li><p>训练误差（经验误差）：学习器在<strong>训练集</strong>上的误差</p></li><li><p>测试误差（泛化误差）：学习器在<strong>测试集或新样本</strong>上的误差</p><p><strong>注意</strong>：由于新样本是未知的，故常用 min(测试误差) 代替min(泛化误差)</p></li></ul><hr><h3 id="二模型选择">二、模型选择</h3><ul><li><p>对于同一个问题，可以选择多种<strong>算法</strong></p></li><li><p>对于同一个算法，选择不同的<strong>参数</strong>配置</p><p><strong>注意</strong>：对于机器学习问题，本质都是寻找一个<u><strong>映射</strong></u><span class="math inline">\(f: X \rightarrow Y\)</span></p></li></ul><hr><h3 id="三数据集划分">三、数据集划分</h3><ul><li><p>目标：将数据集 D 划分为<u>训练集 S</u>和<u>测试集T</u>两部分</p></li><li><p>原则：测试集与训练集应尽量<strong>互斥</strong>，测试样本尽量不在训练集中出现</p><hr></li><li><p>留出法：将 D <strong>随机划分</strong>为训练集（<span class="math inline">\(\dfrac{2}{3}\)</span>）和测试集（<span class="math inline">\(\dfrac{1}{3}\)</span>）；使用训练集导出模型，用测试集估计泛化误差</p></li><li><p>随机子抽样：将留出法<strong>重复进行k次</strong>，总准确率取各次准确率的<strong>平均值</strong></p></li><li><p>k折交叉验证：将 D 划分为 k 个大小相似、互不相交的子集（“折”）<br>第 i 次迭代时，取<u>第 i折</u>作为测试集，<u>其余子集</u>作为训练集；取 k次测试的<strong>平均值</strong></p></li><li><p>留一法：k折交叉验证中，令 |D| = k，将 D 均分为 k折，每一折仅有一个样本</p></li><li><p>自助法：从 D 中<strong>有放回</strong>地均匀抽样；采样 |D|次后可获得大小为 |D| 的训练样本集 <br>没有进入训练集的样本形成测试集</p><ul><li>优点：可产生<strong>多个不同</strong>的训练样本集；对于小数据集自助法效果胜过交叉验证</li><li>缺点：改变了数据集分布（随机抽样），会引入估计偏差</li></ul></li></ul><hr><h3 id="四性能度量">四、性能度量</h3><ul><li><p>回归任务：采用<strong>均方误差</strong> <span class="math inline">\(E(f:D) = \dfrac{1}{d} \sum_{i=1}^{d}(f(x_i -y_i))^2\)</span></p></li><li><p>分类任务：采用<strong>错误率</strong> <span class="math inline">\(E(f:D) = \dfrac{1}{d}\sum_{i=1}^{d} (f(x_i) \ney_i)\)</span></p><p><br>其中 <span class="math inline">\(f\)</span> 是训练的学习器、<span class="math inline">\(D\)</span> 为初始样本集、<span class="math inline">\(y_i\)</span> 表示样本输入 <span class="math inline">\(x_i\)</span> 的真实标记</p><p><strong>注意</strong>：错误率和精度仅能评估<strong>是否正确分类</strong>，不能提供更精细的评估（如查全率、查准率等）</p><hr></li><li><p>混淆矩阵：设仅有正负样本两类，分类表示方法为<strong>&lt;预测正误&gt; + &lt;预测结果&gt;</strong></p><ul><li>真正例TP：被正确分类的正例</li><li>假负例FN：被错误标记为负例的正例</li><li>假正例FP：被错误标记为正例的负例</li><li>真负例TN：被正确分类的负例</li></ul><figure style="text-align:center"><p><img src="/2023/07/20/machine_learning/model-selection-and-evaluation/混淆矩阵.png" width="75%" height="75%"></p></figure></li><li><p>敏感性（查全率）：评估分类器正确<strong>识别正例</strong>的能力（即将<u>尽可能多</u>的正例挑选出来），避免<strong><u>漏识别</u></strong><span class="math display">\[\text{recall} = \frac{\text{TP}}{\text{P}}\]</span></p></li><li><p>特异性：评估分类器正确<strong>识别负例</strong>的能力（即将<u>尽可能多</u>的负例挑选出来）<span class="math display">\[\text{SP} = \frac{\text{TN}}{\text{N}}\]</span></p></li><li><p>准确率：评估分类器正确<strong>识别正负样本</strong>的能力（即正确/ 全体） <span class="math display">\[\text{accuracy} = \frac{\text{TP + TN}}{\text{P + N}}\]</span></p></li><li><p>精度（查准率）：评估挑选出的正例中有多少是<strong>真正的正例</strong>，避免<strong><u>误识别</u></strong><span class="math display">\[\text{presicion} = \frac{\text{TP}}{\text{TP + FP}}\]</span> <strong>注意</strong>：查全率和查准率相互矛盾，此消彼长<br>要想查全率提高，只要将<strong>尽可能多</strong>的样本判断为正例，此时查准率下降<br>要想查准率提高，只能将<strong>最有把握</strong>的样本判断为正例，此时查全率下降</p><hr></li><li><p>P-R曲线：以召回率R为横轴、准确率P为纵轴的曲线图；曲线下方面积大、平衡点越大的模型效果越好</p></li><li><p><span class="math inline">\(\text{F}_1\)</span>度量：精确率与召回率的调和值，推荐系统中常用<span class="math display">\[\text{F}_1 = \frac{2 \times \text{precision} \times\text{recall}}{\text{precision} + \text{recall}}\]</span> <span class="math inline">\(\text{F}_\beta\)</span>度量：<span class="math inline">\(\text{F}_1\)</span>度量的一般化形式，利用参数<span class="math inline">\(\beta\)</span>控制查全率对查准率的相对重要性，<span class="math inline">\(\beta \gt1\)</span>说明查全率更重要 <span class="math display">\[\text{F}_{\beta} = \frac{(1 + \beta^2) \times \text{precision} \times\text{recall}}{\beta^2 \times \text{precision} + \text{recall}}\]</span></p></li><li><p>代价敏感性度量：引入<strong>预测错误</strong>的代价风险，<span class="math inline">\(\text{cost}_\text{FN}\)</span>表示<u>将正例预测为负例</u>的代价，<span class="math inline">\(\text{cost}_\text{FP}\)</span> 则相反 <span class="math display">\[E(f:D) = \frac{1}{d} (\sum_{x_i \in D^+}(f(x_i) \ne y_i)\times\text{cost}_\text{FN} + \sum_{x_i \in D^-}(f(x_i) \ne y_i) \times\text{cost}_\text{FP})\]</span></p></li><li><p>ROC曲线：TPR-FPR曲线</p><ul><li><p>绘制流程：初始状态 = (0,0)，根据预测结果从大到小排序，将各分类阈值依次设在每个样例上，即依次将每个样例划分为正例</p><ul><li>若当前样例是TP，对应标记点是<span class="math inline">\((\text{x},\text{y} + \dfrac{1}{\text{m}^+})\)</span>，即向上平移，其中<span class="math inline">\(\text{m}^+\)</span>表示正例数量</li><li>若当前样例是FP，对应标记点是<span class="math inline">\((\text{x}+\dfrac{1}{\text{m}^-},\text{y})\)</span>，即向右平移，其中<span class="math inline">\(\text{m}^-\)</span>表示负例数量</li></ul><p><img src="/2023/07/20/machine_learning/model-selection-and-evaluation/ROC.png" width="80%"></p></li><li><p>AUC：ROC曲线下方的面积，越大越好</p></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>machine learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>『machine learning-1』overview</title>
    <link href="/2023/07/20/machine_learning/overview/"/>
    <url>/2023/07/20/machine_learning/overview/</url>
    
    <content type="html"><![CDATA[<h2 id="概述">概述</h2><h3 id="一与机器学习相关的学科">一、与机器学习相关的学科</h3><ul><li>人工智能</li><li>智能信息处理</li><li>模式识别</li><li>数据挖掘</li><li>计算机视觉</li><li>自然语言处理</li></ul><hr><h3 id="二机器学习算法">二、机器学习算法</h3><ul><li><p>机器学习的主要问题：</p><figure style="text-align:center;"><p><img src="/2023/07/20/machine_learning/overview/典型算法.png" width="75%" height="75%"></p><figcaption><p>机器学习典型算法</p></figcaption></figure></li><li><p>监督学习：利用<strong>已标记</strong>的数据训练模型；<span class="math inline">\(\{\text{x}_i \in \mathbb{R}^d, y_i \in \mathbb{R}\}_{i=1}^N\)</span></p><figure style="text-align:center;"><p><img src="/2023/07/20/machine_learning/overview/监督学习.png" width="75%" height="75%"></p><figcaption><p>监督学习</p></figcaption></figure></li><li><p>非监督学习：利用<strong>未标记</strong>的数据训练模型，需要模型<strong>自行发掘</strong>数据中的特征；<span class="math inline">\(\{\text{x}_i \in\mathbb{R}^d\}_{i=1}^N\)</span></p><figure style="text-align:center;"><p><img src="/2023/07/20/machine_learning/overview/非监督学习.png" width="75%" height="75%"></p><figcaption><p>非监督学习</p></figcaption></figure></li><li><p>半监督学习：训练数据集中同时混有<strong>已标记和未标记</strong>的数据</p><p><strong>注意</strong>：“监督学习”与“非监督学习”的差异在于训练集中是否含有<strong>目标值</strong></p></li></ul><hr><h3 id="三训练与测试">三、训练与测试</h3><ul><li><p>No Free Lunch：没有一种<strong>单一</strong>的机器学习算法能够在<strong>所有</strong>问题上表现得最好</p></li><li><p>影响机器学习结果的因素：</p><ol type="1"><li>训练的类型</li><li><strong>初始背景知识</strong>的形式与范围</li><li>训练<strong>反馈</strong>的类型</li><li>机器学习<strong>算法</strong></li></ol></li><li><p>机器学习的目标：</p><ul><li>监督学习：尽可能缩小<strong>测试集</strong>上的预测误差，其中测试集误差<span class="math inline">\(\text{Error}_{out} = \dfrac{1}{N}\sum_{i=1}^N (y_i \ne g(x_i))\)</span></li><li>非监督学习：缺少预先定义的<strong>标准答案</strong>；一般结合实际领域与需求对测试结果进行解释与判断</li></ul></li><li><p>“偏差”与“方差”：</p><ul><li>偏差：用所有可能的训练集训练出的<strong>所有模型的输出<u>平均值</u></strong>与真实模型输出值之间的差异</li><li>方差：用<strong>不同训练集</strong>训练出的模型输出值之间的差异</li></ul></li><li><p>“过拟合”与“欠拟合”：</p><ul><li><p>过拟合：模型过于<strong>复杂</strong>，学习了训练集中大量无关特征（噪声）<br>特点：低偏差 + 高方差（抗噪性弱）、低训练集误差 +高测试集误差</p></li><li><p>欠拟合：模型过于简单，无法充分学习数据中相关特征<br>特点：高偏差（算法拟合能力差） + 低方差、高训练集误差 +高测试集误差</p><p><strong>注意</strong>：“偏差”与“方差”是矛盾的</p></li></ul><figure style="text-align:center;"><p><img src="/2023/07/20/machine_learning/overview/模型复杂度.png" width="75%" height="75%"></p><figcaption><p>训练集误差（Ein）、测试集误差（Eout）与模型复杂度（dvc）之间的关系</p></figcaption></figure></li><li><p>泛化误差：<span class="math inline">\(\text{GE} = \text{noise}^2+ \text{bias}^2 + \text{variance}\)</span> <br>其中 noise是<strong>训练集的噪声</strong>，不可避免；bias由<strong>模型错误的假设</strong>造成；variance由各<strong>训练集间</strong>的偏差造成</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>machine learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
